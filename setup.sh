#!/bin/bash

# Event Manager Complete Setup Script
# One-command installation for fully functional web application
# Includes: Node.js, PostgreSQL, Nginx, SSL certificates, systemd service

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Application configuration
APP_NAME="event-manager"
APP_DIR="/var/www/$APP_NAME"
NODE_VERSION="20.19.5"
DB_NAME="event_manager"
DB_USER="event_manager"
DB_PASSWORD="password"
JWT_SECRET=""
SESSION_SECRET=""
APP_ENV="production"
APP_URL=""
DOMAIN=""
EMAIL=""
WEB_SERVER_USER="www-data"

# Installation flags
AUTO_INSTALL_PREREQS=false
AUTO_SETUP_DB=false
AUTO_CLEANUP_PHP=false
AUTO_CREATE_INSTALLER=false
AUTO_START_SERVERS=false
NON_INTERACTIVE=false
SKIP_ENV_CONFIG=false
SKIP_WEB_SERVER_PERMISSIONS=false
AUTO_SETUP_PERMISSIONS=false
INSTALL_NGINX=true
INSTALL_SSL=true
USE_PM2=false

# Print functions
print_status() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

print_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check if running as root
check_root() {
    if [[ $EUID -eq 0 ]]; then
        print_error "This script should not be run as root. Please run as a regular user with sudo privileges."
        exit 1
    fi
    
    # Check if user has sudo privileges
    if ! sudo -n true 2>/dev/null; then
        print_error "This script requires sudo privileges. Please ensure your user can run sudo commands."
        exit 1
    fi
}

# Check Node.js version compatibility
check_node_version() {
    local node_version=$(node --version 2>/dev/null | sed 's/v//')
    local major_version=$(echo "$node_version" | cut -d'.' -f1)
    
    if [[ -z "$node_version" ]]; then
        print_error "Node.js is not installed or not in PATH"
        return 1
    fi
    
    print_status "Detected Node.js version: $node_version"
    
    # Check if version is compatible (Node.js 18+)
    if [[ "$major_version" -lt 18 ]]; then
        print_error "Node.js version $node_version is not supported. Please upgrade to Node.js 18 or higher."
        print_info "Current Node.js versions supported: 18.x, 20.x, 21.x"
        return 1
    fi
    
    # Check for known problematic versions
    if [[ "$node_version" =~ ^20\.19\.[0-9]+$ ]]; then
        print_warning "Node.js $node_version detected - using enhanced compatibility mode"
        export NODE_OPTIONS="--max-old-space-size=4096"
    fi
    
    return 0
}

# Enhanced npm install with compatibility fixes
safe_npm_install() {
    local install_dir="$1"
    local install_type="$2"  # "backend" or "frontend"
    
    cd "$install_dir" || return 1
    
    print_status "Installing $install_type dependencies with enhanced compatibility..."
    
    # Clean up any problematic modules first
    print_status "Cleaning up problematic modules..."
    rm -rf node_modules package-lock.json 2>/dev/null || true
    
    # Install system dependencies for native modules (useful for various packages)
    if [[ "$install_type" == "backend" ]]; then
        print_status "Installing system dependencies for native modules..."
        # Install system dependencies that may be needed for various native modules
        sudo apt-get update -qq
        sudo apt-get install -y \
            build-essential \
            libcairo2-dev \
            libpango1.0-dev \
            libjpeg-dev \
            libgif-dev \
            librsvg2-dev \
            libpixman-1-dev \
            libffi-dev \
            libgdk-pixbuf2.0-dev \
            libglib2.0-dev \
            libgtk-3-dev \
            libx11-dev \
            libxext-dev \
            libxrender-dev \
            libxrandr-dev \
            libxinerama-dev \
            libxcursor-dev \
            libxcomposite-dev \
            libxdamage-dev \
            libxfixes-dev \
            libxss-dev \
            libxtst-dev \
            libxi-dev \
            pkg-config \
            python3-dev \
            python3-pip \
            g++ \
            make \
            clamav \
            clamav-daemon \
            clamav-freshclam \
            2>/dev/null || true
        
        # Verify key dependencies are installed
        print_status "Verifying system dependencies..."
        if dpkg -l | grep -q libcairo2-dev && dpkg -l | grep -q libpango1.0-dev; then
            print_success "System dependencies installed successfully"
        else
            print_warning "Some system dependencies may not be installed properly"
        fi
        
        # Configure ClamAV for virus scanning
        print_status "Configuring ClamAV virus scanner..."
        if command -v clamscan &> /dev/null; then
            # Update virus definitions
            sudo freshclam
            
            # Start ClamAV daemon
            sudo systemctl start clamav-daemon
            sudo systemctl enable clamav-daemon
            
            # Start freshclam daemon for automatic updates
            sudo systemctl start clamav-freshclam
            sudo systemctl enable clamav-freshclam
            
            print_success "ClamAV configured successfully"
        else
            print_warning "ClamAV not available - virus scanning will be skipped"
        fi
    fi
    
    # Set npm configuration for better compatibility
    npm config set legacy-peer-deps true
    npm config set fund false
    npm config set audit-level moderate
    npm config set update-notifier false
    npm config set audit false
    npm config set fund false
    
    # Debug information
    print_status "Debug information:"
    print_status "  Current directory: $(pwd)"
    print_status "  Node.js version: $(node --version)"
    print_status "  npm version: $(npm --version)"
    print_status "  Package.json exists: $([ -f "package.json" ] && echo "Yes" || echo "No")"
    if [[ -f "package.json" ]]; then
        print_status "  Package.json size: $(wc -l < package.json) lines"
    fi
    
    # Try multiple installation strategies
    local install_success=false
    
    # Strategy 1: Standard install with legacy peer deps
    print_status "Attempting standard npm install, this may take a while..."
    if npm install --legacy-peer-deps --force --no-fund --no-audit; then
        install_success=true
        print_success "Standard installation successful"
    else
        print_warning "Standard install failed, trying alternative strategies..."
        
        # Strategy 2: Install without optional dependencies
        print_status "Attempting install without optional dependencies..."
        if npm install --legacy-peer-deps --force --no-optional --no-fund --no-audit; then
            install_success=true
            print_success "Installation successful (without optional dependencies)"
        else
            print_warning "Second strategy failed, trying with ignore-scripts..."
            
            # Strategy 3: Install ignoring scripts
            print_status "Attempting install ignoring scripts..."
            if npm install --legacy-peer-deps --force --no-optional --ignore-scripts --no-fund --no-audit; then
                install_success=true
                print_success "Installation successful (ignoring scripts)"
            else
                print_error "All installation strategies failed"
                print_status "Last npm install attempt failed. Check the error messages above."
                return 1
            fi
        fi
    fi
    
    # Fix permissions for problematic modules
    if [[ "$install_type" == "backend" ]]; then
        # Fix puppeteer/playwright permissions
        if [[ -d "node_modules/puppeteer" ]]; then
            chmod -R 755 node_modules/puppeteer 2>/dev/null || true
        fi
        if [[ -d "node_modules/playwright" ]]; then
            chmod -R 755 node_modules/playwright 2>/dev/null || true
        fi
    fi
    
    # Fix all binary permissions
    if [[ -d "node_modules/.bin" ]]; then
        chmod +x node_modules/.bin/* 2>/dev/null || true
        print_status "Fixed binary permissions"
    fi
    
    return 0
}

# Detect operating system
detect_os() {
    if [[ "$OSTYPE" == "linux-gnu"* ]]; then
        if command -v lsb_release &> /dev/null; then
            OS_DISTRO=$(lsb_release -si)
            OS_VERSION=$(lsb_release -sr)
            if [[ "$OS_DISTRO" == "Ubuntu" ]]; then
                OS="ubuntu"
                OS_VERSION_NUM=$(echo $OS_VERSION | cut -d'.' -f1)
                print_status "Detected Ubuntu $OS_VERSION"
            else
                OS="linux"
                print_status "Detected Linux distribution: $OS_DISTRO"
            fi
        else
            OS="linux"
            print_status "Detected Linux (distribution unknown)"
        fi
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        OS="macos"
        print_status "Detected macOS"
    else
        OS="unknown"
        print_warning "Unknown operating system: $OSTYPE"
    fi
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --auto-install-prereqs)
                AUTO_INSTALL_PREREQS=true
                shift
                ;;
            --auto-setup-db)
                AUTO_SETUP_DB=true
                shift
                ;;
            --auto-cleanup-php)
                AUTO_CLEANUP_PHP=true
                shift
                ;;
            --auto-create-installer)
                AUTO_CREATE_INSTALLER=true
                shift
                ;;
            --auto-start-servers)
                AUTO_START_SERVERS=true
                shift
                ;;
            --non-interactive)
                NON_INTERACTIVE=true
                AUTO_INSTALL_PREREQS=true
                AUTO_SETUP_DB=true
                AUTO_CLEANUP_PHP=true
                AUTO_SETUP_PERMISSIONS=true
                shift
                ;;
            --skip-env-config)
                SKIP_ENV_CONFIG=true
                shift
                ;;
            --skip-web-server-permissions)
                SKIP_WEB_SERVER_PERMISSIONS=true
                shift
                ;;
            --auto-setup-permissions)
                AUTO_SETUP_PERMISSIONS=true
                shift
                ;;
            --db-host=*)
                DB_HOST="${1#*=}"
                shift
                ;;
            --db-port=*)
                DB_PORT="${1#*=}"
                shift
                ;;
            --db-name=*)
                DB_NAME="${1#*=}"
                shift
                ;;
            --db-user=*)
                DB_USER="${1#*=}"
                shift
                ;;
            --db-password=*)
                DB_PASSWORD="${1#*=}"
                shift
                ;;
            --jwt-secret=*)
                JWT_SECRET="${1#*=}"
                shift
                ;;
            --session-secret=*)
                SESSION_SECRET="${1#*=}"
                shift
                ;;
            --app-env=*)
                APP_ENV="${1#*=}"
                shift
                ;;
            --app-url=*)
                APP_URL="${1#*=}"
                shift
                ;;
            --api-url=*)
                API_URL="${1#*=}"
                shift
                ;;
            --rebuild-frontend)
                REBUILD_FRONTEND="true"
                shift
                ;;
            --domain=*)
                DOMAIN="${1#*=}"
                shift
                ;;
            --email=*)
                EMAIL="${1#*=}"
                shift
                ;;
            --web-server-user=*)
                WEB_SERVER_USER="${1#*=}"
                shift
                ;;
            --help)
                show_help
                exit 0
                ;;
            *)
                print_error "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done
}

# Show help information
show_help() {
    echo "Event Manager Complete Setup Script"
    echo "===================================="
    echo ""
    echo "Usage: $0 [OPTIONS]"
    echo ""
    echo "Installation Options:"
    echo "  --auto-install-prereqs    Automatically install Node.js, PostgreSQL, Nginx, build tools"
    echo "  --auto-setup-db           Automatically setup database (migrate + seed)"
    echo "  --auto-cleanup-php        Automatically remove old PHP files"
    echo "  --auto-create-installer   Automatically create minimal installer script"
    echo "  --auto-start-servers      Automatically start development servers"
    echo "  --non-interactive         Run in fully automated mode (no prompts)"
    echo "  --skip-env-config         Skip environment variable configuration"
    echo "  --skip-web-server-permissions  Skip web server permission setup"
    echo "  --auto-setup-permissions  Automatically setup web server permissions"
    echo ""
    echo "Database Configuration:"
    echo "  --db-host=HOST           Database server hostname (default: localhost)"
    echo "  --db-port=PORT           Database server port (default: 5432)"
    echo "  --db-name=NAME           Database name (default: event_manager)"
    echo "  --db-user=USER           Database username (default: event_manager)"
    echo "  --db-password=PASS       Database password (default: password)"
    echo ""
    echo "Application Configuration:"
    echo "  --jwt-secret=SECRET       JWT signing secret (auto-generated if not provided)"
    echo "  --session-secret=SECRET   Session encryption secret (auto-generated if not provided)"
    echo "  --app-env=ENV            Application environment (development/production)"
    echo "  --app-url=URL            Application base URL"
    echo "  --api-url=URL            Backend API URL (default: auto-detected or relative)"
    echo "  --rebuild-frontend       Force rebuild frontend with clean cache"
    echo ""
    echo "Web Server Configuration:"
    echo "  --domain=DOMAIN          Domain name for SSL certificate"
    echo "  --email=EMAIL            Email for SSL certificate registration"
    echo "  --web-server-user=USER   Web server user (default: www-data)"
    echo ""
    echo "Examples:"
    echo "  $0                                    # Interactive setup"
    echo "  $0 --non-interactive                  # Fully automated setup"
    echo "  $0 --domain=example.com --email=admin@example.com"
    echo ""
}

# Generate secure secrets
generate_secrets() {
    print_status "Generating secure secrets..."
    
    # Generate JWT secret (64 bytes for better security)
    if [[ -z "$JWT_SECRET" ]]; then
        if command -v openssl &> /dev/null; then
            JWT_SECRET=$(openssl rand -base64 64)
        else
            JWT_SECRET=$(head -c 64 /dev/urandom | base64)
        fi
    fi
    
    # Generate session secret (64 bytes for better security)
    if [[ -z "$SESSION_SECRET" ]]; then
        if command -v openssl &> /dev/null; then
            SESSION_SECRET=$(openssl rand -base64 64)
        else
            SESSION_SECRET=$(head -c 64 /dev/urandom | base64)
        fi
    fi
    
    # Generate database password if not provided
    if [[ -z "$DB_PASSWORD" ]]; then
        if command -v openssl &> /dev/null; then
            DB_PASSWORD=$(openssl rand -base64 32)
        else
            DB_PASSWORD=$(head -c 32 /dev/urandom | base64)
        fi
    fi
    
    print_success "Secrets generated successfully!"
}

# Install prerequisites
install_prerequisites() {
    if [[ "$AUTO_INSTALL_PREREQS" == "false" && "$NON_INTERACTIVE" == "false" ]]; then
        echo ""
        read -p "Install all prerequisites (Node.js, PostgreSQL, Nginx, build tools)? [y/N]: " -n 1 -r
        echo ""
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_status "Skipping prerequisite installation"
            return
        fi
    fi
    
    print_status "Installing prerequisites..."
    
    if [[ "$OS" == "ubuntu" ]]; then
        # Update package list
        sudo apt update
        
        # Install essential packages
        sudo apt install -y curl wget git build-essential python3 python3-pip python3-dev \
            libpq-dev pkg-config software-properties-common apt-transport-https \
            ca-certificates gnupg lsb-release jq htop tree unzip zip vim nano
        
        # Install Node.js 20 LTS
        print_status "Installing Node.js $NODE_VERSION..."
        curl -fsSL https://deb.nodesource.com/setup_20.x | sudo -E bash -
        sudo apt install -y nodejs
        
        # Update npm to latest version
        sudo npm install -g npm@latest
        
        # Install PostgreSQL
        print_status "Installing PostgreSQL..."
        sudo apt install -y postgresql postgresql-contrib
        
        # Install Nginx
        if [[ "$INSTALL_NGINX" == "true" ]]; then
            print_status "Installing Nginx..."
            sudo apt install -y nginx
        fi
        
        # Install Certbot for SSL
        if [[ "$INSTALL_SSL" == "true" ]]; then
            print_status "Installing Certbot for SSL certificates..."
            sudo apt install -y certbot python3-certbot-nginx
        fi
        
        # Start and enable services
        sudo systemctl start postgresql
        sudo systemctl enable postgresql
        
    # Configure PostgreSQL for remote connections
    print_status "Configuring PostgreSQL for remote connections..."

    # Find PostgreSQL version directory
    POSTGRES_VERSION_DIR=$(ls /etc/postgresql/ | head -1)
    if [ -z "$POSTGRES_VERSION_DIR" ]; then
        print_error "PostgreSQL configuration directory not found. Please ensure PostgreSQL is installed."
        return 1
    fi
    
    POSTGRES_CONFIG_DIR="/etc/postgresql/$POSTGRES_VERSION_DIR/main"
    print_status "Using PostgreSQL configuration directory: $POSTGRES_CONFIG_DIR"

    # Check if configuration files exist
    if [ ! -f "$POSTGRES_CONFIG_DIR/postgresql.conf" ]; then
        print_error "postgresql.conf not found at $POSTGRES_CONFIG_DIR"
        return 1
    fi

    if [ ! -f "$POSTGRES_CONFIG_DIR/pg_hba.conf" ]; then
        print_error "pg_hba.conf not found at $POSTGRES_CONFIG_DIR"
        return 1
    fi

    # Backup original configuration files
    print_status "Creating backups of PostgreSQL configuration files..."
    sudo cp "$POSTGRES_CONFIG_DIR/postgresql.conf" "$POSTGRES_CONFIG_DIR/postgresql.conf.backup"
    sudo cp "$POSTGRES_CONFIG_DIR/pg_hba.conf" "$POSTGRES_CONFIG_DIR/pg_hba.conf.backup"

    # Configure postgresql.conf for remote connections
    print_status "Configuring postgresql.conf for remote connections..."
    sudo sed -i "s/#listen_addresses = 'localhost'/listen_addresses = '*'/" "$POSTGRES_CONFIG_DIR/postgresql.conf"
    sudo sed -i "s/#port = 5432/port = 5432/" "$POSTGRES_CONFIG_DIR/postgresql.conf"
    sudo sed -i "s/#max_connections = 100/max_connections = 200/" "$POSTGRES_CONFIG_DIR/postgresql.conf"

    # Configure pg_hba.conf for remote connections
    print_status "Configuring pg_hba.conf for remote connections..."
    
    # Check if remote connection rules already exist
    if ! grep -q "host    all             all             0.0.0.0/0               md5" "$POSTGRES_CONFIG_DIR/pg_hba.conf"; then
        echo "# Remote connections" | sudo tee -a "$POSTGRES_CONFIG_DIR/pg_hba.conf"
        echo "host    all             all             0.0.0.0/0               md5" | sudo tee -a "$POSTGRES_CONFIG_DIR/pg_hba.conf"
        echo "host    all             all             ::/0                    md5" | sudo tee -a "$POSTGRES_CONFIG_DIR/pg_hba.conf"
    else
        print_status "Remote connection rules already exist in pg_hba.conf"
    fi

    # Restart PostgreSQL to apply changes
    print_status "Restarting PostgreSQL to apply configuration changes..."
    sudo systemctl restart postgresql
    
    # Verify PostgreSQL is running
    if sudo systemctl is-active --quiet postgresql; then
        print_success "PostgreSQL restarted successfully and is running"
    else
        print_error "PostgreSQL failed to restart. Please check the configuration."
        return 1
    fi
        
        if [[ "$INSTALL_NGINX" == "true" ]]; then
            sudo systemctl start nginx
            sudo systemctl enable nginx
        fi
        
    elif [[ "$OS" == "macos" ]]; then
        # Check if Homebrew is installed
        if ! command -v brew &> /dev/null; then
            print_status "Installing Homebrew..."
            /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
        fi
        
        # Install packages
        brew install node postgresql
        
        # Start PostgreSQL
        brew services start postgresql
        
    else
        print_error "Unsupported operating system: $OS"
        exit 1
    fi
    
    # Check Node.js version
    NODE_VERSION_INSTALLED=$(node -v | cut -d'v' -f2)
    NODE_VERSION_NUM=$(echo $NODE_VERSION_INSTALLED | cut -d'.' -f1)
    
    if [[ $NODE_VERSION_NUM -lt 18 ]]; then
        print_error "Node.js version 18+ is required. Current version: $NODE_VERSION_INSTALLED"
        exit 1
    fi
    
    print_success "Prerequisites installed successfully"
    print_status "Node.js: $(node -v)"
    print_status "npm: $(npm -v)"
    print_status "PostgreSQL: $(psql --version)"
    
    # Clean up system warnings
    cleanup_system_warnings
}

# Clean up system warnings and unused packages
cleanup_system_warnings() {
    print_status "Cleaning up system warnings..."
    
    # Remove unused packages like libllvm19
    if dpkg -l | grep -q libllvm19; then
        print_status "Removing unused package: libllvm19"
        sudo apt autoremove -y 2>/dev/null || true
    fi
    
    # Clean up package cache
    sudo apt autoclean 2>/dev/null || true
    
    # Clear npm cache to prevent warnings
    npm cache clean --force 2>/dev/null || true
    
    print_success "System warnings cleaned up"
}

# Create application directory and set permissions
setup_application_directory() {
    print_status "Setting up application directory..."
    
    # Create application directory
    sudo mkdir -p "$APP_DIR"
    
    # Copy current directory contents to application directory
    sudo cp -r . "$APP_DIR/"
    
    # Set ownership to current user for initial setup
    sudo chown -R "$(whoami):$(whoami)" "$APP_DIR"
    
    print_success "Application directory created at $APP_DIR"
}

# Create modular middleware files
create_middleware_files() {
    print_status "Creating middleware files..."
    
    # Authentication middleware
    cat > "$APP_DIR/src/middleware/auth.js" << 'EOF'
const jwt = require('jsonwebtoken')
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key'

const authenticateToken = async (req, res, next) => {
  const authHeader = req.headers['authorization']
  const token = authHeader && authHeader.split(' ')[1]

  if (!token) {
    return res.status(401).json({ error: 'Access token required' })
  }

  try {
    const decoded = jwt.verify(token, JWT_SECRET)
    const user = await prisma.user.findUnique({
      where: { id: decoded.userId },
      include: {
        judge: true,
        contestant: true
      }
    })

    if (!user) {
      return res.status(401).json({ error: 'Invalid token' })
    }

    req.user = user
    next()
  } catch (error) {
    return res.status(403).json({ error: 'Invalid or expired token' })
  }
}

const requireRole = (roles) => {
  return (req, res, next) => {
    if (!req.user) {
      return res.status(401).json({ error: 'Authentication required' })
    }

    if (!roles.includes(req.user.role)) {
      return res.status(403).json({ error: 'Insufficient permissions' })
    }

    next()
  }
}

module.exports = {
  authenticateToken,
  requireRole
}
EOF

    # Rate limiting middleware
    cat > "$APP_DIR/src/middleware/rateLimiting.js" << 'EOF'
const rateLimit = require('express-rate-limit')

// General API rate limiter
const generalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5000, // 5000 requests per 15 minutes
  standardHeaders: true,
  legacyHeaders: false,
  trustProxy: true,
  skip: (req) => {
    return req.path === '/health' || 
           req.path.startsWith('/api/auth/') ||
           req.path.startsWith('/api/admin/')
  }
})

// Auth endpoints rate limiter
const authLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 10000, // 10000 requests per 15 minutes for auth
  standardHeaders: true,
  legacyHeaders: false,
  trustProxy: true
})

module.exports = {
  generalLimiter,
  authLimiter
}
EOF

    # Error handling middleware
    cat > "$APP_DIR/src/middleware/errorHandler.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

const logActivity = (action, resourceType = null, resourceId = null) => {
  return async (req, res, next) => {
    const originalSend = res.send
    
    res.send = function(data) {
      // Log activity after response is sent
      if (req.user && res.statusCode < 400) {
        // Log to database asynchronously
        setImmediate(async () => {
          try {
            await prisma.activityLog.create({
              data: {
                userId: req.user.id,
                action: action,
                resourceType: resourceType,
                resourceId: resourceId,
                ipAddress: req.ip || req.connection.remoteAddress,
                userAgent: req.get('User-Agent') || 'Unknown',
                details: {
                  method: req.method,
                  path: req.path,
                  timestamp: new Date().toISOString()
                }
              }
            })
          } catch (error) {
            console.error('Failed to log activity:', error)
          }
        })
      }
      
      return originalSend.call(this, data)
    }
    
    next()
  }
}

const errorHandler = (err, req, res, next) => {
  console.error('Error:', err)
  
  if (err.name === 'ValidationError') {
    return res.status(400).json({ error: 'Validation error', details: err.message })
  }
  
  if (err.name === 'UnauthorizedError') {
    return res.status(401).json({ error: 'Unauthorized' })
  }
  
  if (err.name === 'ForbiddenError') {
    return res.status(403).json({ error: 'Forbidden' })
  }
  
  if (err.name === 'NotFoundError') {
    return res.status(404).json({ error: 'Not found' })
  }
  
  res.status(500).json({ error: 'Internal server error' })
}

module.exports = {
  logActivity,
  errorHandler
}
EOF

    # Validation middleware
    cat > "$APP_DIR/src/middleware/validation.js" << 'EOF'
const validateEvent = (req, res, next) => {
  const { name, description, startDate, endDate, location, maxContestants } = req.body
  
  if (!name || !description || !startDate || !endDate || !location) {
    return res.status(400).json({ error: 'Missing required fields' })
  }
  
  if (new Date(startDate) >= new Date(endDate)) {
    return res.status(400).json({ error: 'End date must be after start date' })
  }
  
  if (maxContestants && maxContestants < 1) {
    return res.status(400).json({ error: 'Max contestants must be at least 1' })
  }
  
  next()
}

const validateContest = (req, res, next) => {
  const { name, description, startDate, endDate, maxContestants, eventId } = req.body
  
  if (!name || !description || !startDate || !endDate || !eventId) {
    return res.status(400).json({ error: 'Missing required fields' })
  }
  
  if (new Date(startDate) >= new Date(endDate)) {
    return res.status(400).json({ error: 'End date must be after start date' })
  }
  
  if (maxContestants && maxContestants < 1) {
    return res.status(400).json({ error: 'Max contestants must be at least 1' })
  }
  
  next()
}

const validateCategory = (req, res, next) => {
  const { name, description, maxScore, contestId } = req.body
  
  if (!name || !description || !maxScore || !contestId) {
    return res.status(400).json({ error: 'Missing required fields' })
  }
  
  if (maxScore < 1) {
    return res.status(400).json({ error: 'Max score must be at least 1' })
  }
  
  next()
}

const validateUser = (req, res, next) => {
  const { name, email, role } = req.body
  
  if (!name || !email || !role) {
    return res.status(400).json({ error: 'Missing required fields' })
  }
  
  const validRoles = ['ORGANIZER', 'JUDGE', 'CONTESTANT', 'EMCEE', 'TALLY_MASTER', 'AUDITOR', 'BOARD']
  if (!validRoles.includes(role)) {
    return res.status(400).json({ error: 'Invalid role' })
  }
  
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
  if (!emailRegex.test(email)) {
    return res.status(400).json({ error: 'Invalid email format' })
  }
  
  next()
}

const validateUserUpdate = (req, res, next) => {
  const { name, email, role } = req.body
  
  // Only validate fields that are present
  if (email) {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    if (!emailRegex.test(email)) {
      return res.status(400).json({ error: 'Invalid email format' })
    }
  }
  
  if (role) {
    const validRoles = ['ORGANIZER', 'JUDGE', 'CONTESTANT', 'EMCEE', 'TALLY_MASTER', 'AUDITOR', 'BOARD']
    if (!validRoles.includes(role)) {
      return res.status(400).json({ error: 'Invalid role' })
    }
  }
  
  next()
}

module.exports = {
  validateEvent,
  validateContest,
  validateCategory,
  validateUser,
  validateUserUpdate
}
EOF

    print_success "Middleware files created successfully"
}

# Create modular controller files
create_controller_files() {
    print_status "Creating controller files..."
    
    # Auth Controller
    cat > "$APP_DIR/src/controllers/authController.js" << 'EOF'
const bcrypt = require('bcryptjs')
const jwt = require('jsonwebtoken')
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()
const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key'

const login = async (req, res) => {
  try {
    const { email, password } = req.body

    if (!email || !password) {
      return res.status(400).json({ error: 'Email and password are required' })
    }

    const user = await prisma.user.findUnique({
      where: { email },
      include: {
        judge: true,
        contestant: true
      }
    })

    if (!user || !await bcrypt.compare(password, user.password)) {
      return res.status(401).json({ error: 'Invalid credentials' })
    }

    const token = jwt.sign(
      { userId: user.id, email: user.email, role: user.role },
      JWT_SECRET,
      { expiresIn: '24h' }
    )

    res.json({
      token,
      user: {
        id: user.id,
        name: user.name,
        email: user.email,
        role: user.role,
        judge: user.judge,
        contestant: user.contestant
      }
    })
  } catch (error) {
    console.error('Login error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getProfile = async (req, res) => {
  try {
    const user = await prisma.user.findUnique({
      where: { id: req.user.id },
      include: {
        judge: true,
        contestant: true
      }
    })

    if (!user) {
      return res.status(404).json({ error: 'User not found' })
    }

    res.json({
      id: user.id,
      name: user.name,
      email: user.email,
      role: user.role,
      judge: user.judge,
      contestant: user.contestant
    })
  } catch (error) {
    console.error('Profile error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  login,
  getProfile
}
EOF

    # Events Controller
    cat > "$APP_DIR/src/controllers/eventsController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

const getAllEvents = async (req, res) => {
  try {
    const events = await prisma.event.findMany({
      include: {
        _count: {
          select: {
            contests: true,
            archivedEvents: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    })

    res.json(events)
  } catch (error) {
    console.error('Get events error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getEventById = async (req, res) => {
  try {
    const { id } = req.params

    const event = await prisma.event.findUnique({
      where: { id },
      include: {
        contests: {
          include: {
            _count: {
              select: {
                categories: true,
                contestants: true
              }
            }
          }
        },
        _count: {
          select: {
            contests: true,
            contestants: true
          }
        }
      }
    })

    if (!event) {
      return res.status(404).json({ error: 'Event not found' })
    }

    res.json(event)
  } catch (error) {
    console.error('Get event error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const createEvent = async (req, res) => {
  try {
    const { name, description, startDate, endDate } = req.body

    // Validate required fields
    if (!name || !startDate || !endDate) {
      return res.status(400).json({ error: 'Name, start date, and end date are required' })
    }

    // Validate date format
    const start = new Date(startDate)
    const end = new Date(endDate)
    
    if (isNaN(start.getTime()) || isNaN(end.getTime())) {
      return res.status(400).json({ error: 'Invalid date format' })
    }

    if (start >= end) {
      return res.status(400).json({ error: 'End date must be after start date' })
    }

    const event = await prisma.event.create({
      data: {
        name,
        description: description || null,
        startDate: start,
        endDate: end
      }
    })

    res.status(201).json(event)
  } catch (error) {
    console.error('Create event error:', error)
    if (error.code === 'P2002') {
      res.status(400).json({ error: 'Event with this name already exists' })
    } else {
      res.status(500).json({ error: 'Internal server error' })
    }
  }
}

const updateEvent = async (req, res) => {
  try {
    const { id } = req.params
    const { name, description, startDate, endDate } = req.body

    // Validate required fields
    if (!name || !startDate || !endDate) {
      return res.status(400).json({ error: 'Name, start date, and end date are required' })
    }

    // Validate date format
    const start = new Date(startDate)
    const end = new Date(endDate)
    
    if (isNaN(start.getTime()) || isNaN(end.getTime())) {
      return res.status(400).json({ error: 'Invalid date format' })
    }

    if (start >= end) {
      return res.status(400).json({ error: 'End date must be after start date' })
    }

    const event = await prisma.event.update({
      where: { id },
      data: {
        name,
        description: description || null,
        startDate: start,
        endDate: end
      }
    })

    res.json(event)
  } catch (error) {
    console.error('Update event error:', error)
    if (error.code === 'P2025') {
      res.status(404).json({ error: 'Event not found' })
    } else if (error.code === 'P2002') {
      res.status(400).json({ error: 'Event with this name already exists' })
    } else {
      res.status(500).json({ error: 'Internal server error' })
    }
  }
}

const deleteEvent = async (req, res) => {
  try {
    const { id } = req.params

    await prisma.event.delete({
      where: { id }
    })

    res.status(204).send()
  } catch (error) {
    console.error('Delete event error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  getAllEvents,
  getEventById,
  createEvent,
  updateEvent,
  deleteEvent
}
EOF

    # Contests Controller
    cat > "$APP_DIR/src/controllers/contestsController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

const getContestById = async (req, res) => {
  try {
    const { id } = req.params

    const contest = await prisma.contest.findUnique({
      where: { id },
      include: {
        event: true,
        categories: {
          include: {
            _count: {
              select: {
                criteria: true,
                contestants: true,
                judges: true,
                scores: true
              }
            }
          }
        },
        _count: {
          select: {
            categories: true,
            contestants: true
          }
        }
      }
    })

    if (!contest) {
      return res.status(404).json({ error: 'Contest not found' })
    }

    res.json(contest)
  } catch (error) {
    console.error('Get contest error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getContestsByEvent = async (req, res) => {
  try {
    const { eventId } = req.params

    const contests = await prisma.contest.findMany({
      where: { eventId },
      include: {
        _count: {
          select: {
            categories: true,
            contestants: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    })

    res.json(contests)
  } catch (error) {
    console.error('Get contests by event error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const createContest = async (req, res) => {
  try {
    const { eventId } = req.params
    const { name, description, startDate, endDate, maxContestants } = req.body

    const contest = await prisma.contest.create({
      data: {
        name,
        description,
        startDate: new Date(startDate),
        endDate: new Date(endDate),
        maxContestants: maxContestants || null,
        eventId,
        createdBy: req.user.id
      }
    })

    res.status(201).json(contest)
  } catch (error) {
    console.error('Create contest error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const updateContest = async (req, res) => {
  try {
    const { id } = req.params
    const { name, description, startDate, endDate, maxContestants } = req.body

    const contest = await prisma.contest.update({
      where: { id },
      data: {
        name,
        description,
        startDate: new Date(startDate),
        endDate: new Date(endDate),
        maxContestants: maxContestants || null
      }
    })

    res.json(contest)
  } catch (error) {
    console.error('Update contest error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const deleteContest = async (req, res) => {
  try {
    const { id } = req.params

    await prisma.contest.delete({
      where: { id }
    })

    res.status(204).send()
  } catch (error) {
    console.error('Delete contest error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  getContestById,
  getContestsByEvent,
  createContest,
  updateContest,
  deleteContest
}
EOF

    # Categories Controller
    cat > "$APP_DIR/src/controllers/categoriesController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

const getAllCategories = async (req, res) => {
  try {
    const categories = await prisma.category.findMany({
      include: {
        contest: {
          include: {
            event: true
          }
        },
        _count: {
          select: {
            criteria: true,
            contestants: true,
            judges: true,
            scores: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    })

    res.json(categories)
  } catch (error) {
    console.error('Get categories error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getCategoryById = async (req, res) => {
  try {
    const { id } = req.params

    const category = await prisma.category.findUnique({
      where: { id },
      include: {
        contest: {
          include: {
            event: true
          }
        },
        criteria: true,
        contestants: true,
        judges: true,
        scores: true
      }
    })

    if (!category) {
      return res.status(404).json({ error: 'Category not found' })
    }

    res.json(category)
  } catch (error) {
    console.error('Get category error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getCategoriesByContest = async (req, res) => {
  try {
    const { contestId } = req.params

    const categories = await prisma.category.findMany({
      where: { contestId },
      include: {
        _count: {
          select: {
            criteria: true,
            contestants: true,
            judges: true,
            scores: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    })

    res.json(categories)
  } catch (error) {
    console.error('Get categories by contest error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const createCategory = async (req, res) => {
  try {
    const { name, description, maxScore, contestId } = req.body

    const category = await prisma.category.create({
      data: {
        name,
        description,
        maxScore,
        contestId,
        createdBy: req.user.id
      }
    })

    res.status(201).json(category)
  } catch (error) {
    console.error('Create category error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const updateCategory = async (req, res) => {
  try {
    const { id } = req.params
    const { name, description, maxScore } = req.body

    const category = await prisma.category.update({
      where: { id },
      data: {
        name,
        description,
        maxScore
      }
    })

    res.json(category)
  } catch (error) {
    console.error('Update category error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const deleteCategory = async (req, res) => {
  try {
    const { id } = req.params

    await prisma.category.delete({
      where: { id }
    })

    res.status(204).send()
  } catch (error) {
    console.error('Delete category error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get criteria for a category
const getCategoryCriteria = async (req, res) => {
  try {
    const { categoryId } = req.params

    const criteria = await prisma.criterion.findMany({
      where: { categoryId },
      orderBy: { createdAt: 'asc' }
    })

    res.json(criteria)
  } catch (error) {
    console.error('Get category criteria error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Create criterion for a category
const createCriterion = async (req, res) => {
  try {
    const { categoryId } = req.params
    const { name, maxScore } = req.body

    if (!name || !maxScore) {
      return res.status(400).json({ error: 'Name and maxScore are required' })
    }

    const criterion = await prisma.criterion.create({
      data: {
        categoryId,
        name,
        maxScore: parseInt(maxScore)
      }
    })

    res.status(201).json(criterion)
  } catch (error) {
    console.error('Create criterion error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Update criterion
const updateCriterion = async (req, res) => {
  try {
    const { criterionId } = req.params
    const { name, maxScore } = req.body

    if (!name || !maxScore) {
      return res.status(400).json({ error: 'Name and maxScore are required' })
    }

    const criterion = await prisma.criterion.update({
      where: { id: criterionId },
      data: {
        name,
        maxScore: parseInt(maxScore)
      }
    })

    res.json(criterion)
  } catch (error) {
    console.error('Update criterion error:', error)
    if (error.code === 'P2025') {
      res.status(404).json({ error: 'Criterion not found' })
    } else {
      res.status(500).json({ error: 'Internal server error' })
    }
  }
}

// Delete criterion
const deleteCriterion = async (req, res) => {
  try {
    const { criterionId } = req.params

    await prisma.criterion.delete({
      where: { id: criterionId }
    })

    res.status(204).send()
  } catch (error) {
    console.error('Delete criterion error:', error)
    if (error.code === 'P2025') {
      res.status(404).json({ error: 'Criterion not found' })
    } else {
      res.status(500).json({ error: 'Internal server error' })
    }
  }
}

// Update category with optional timeLimit
const updateCategoryWithTimeLimit = async (req, res) => {
  try {
    const { id } = req.params
    const { name, description, scoreCap, timeLimit, contestantMin, contestantMax } = req.body

    const updateData = {}
    if (name) updateData.name = name
    if (description !== undefined) updateData.description = description
    if (scoreCap !== undefined) updateData.scoreCap = scoreCap
    if (timeLimit !== undefined) updateData.timeLimit = timeLimit
    if (contestantMin !== undefined) updateData.contestantMin = contestantMin
    if (contestantMax !== undefined) updateData.contestantMax = contestantMax

    const category = await prisma.category.update({
      where: { id },
      data: updateData
    })

    res.json(category)
  } catch (error) {
    console.error('Update category with time limit error:', error)
    if (error.code === 'P2025') {
      res.status(404).json({ error: 'Category not found' })
    } else {
      res.status(500).json({ error: 'Internal server error' })
    }
  }
}

module.exports = {
  getAllCategories,
  getCategoryById,
  getCategoriesByContest,
  createCategory,
  updateCategory,
  deleteCategory,
  getCategoryCriteria,
  createCriterion,
  updateCriterion,
  deleteCriterion,
  updateCategoryWithTimeLimit
}
EOF

    # Users Controller
    cat > "$APP_DIR/src/controllers/usersController.js" << 'EOF'
const bcrypt = require('bcryptjs')
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

const getAllUsers = async (req, res) => {
  try {
    const users = await prisma.user.findMany({
      include: {
        judge: true,
        contestant: true
      },
      orderBy: { createdAt: 'desc' }
    })

    res.json(users)
  } catch (error) {
    console.error('Get users error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getUserById = async (req, res) => {
  try {
    const { id } = req.params

    const user = await prisma.user.findUnique({
      where: { id },
      include: {
        judge: true,
        contestant: true
      }
    })

    if (!user) {
      return res.status(404).json({ error: 'User not found' })
    }

    res.json(user)
  } catch (error) {
    console.error('Get user error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const createUser = async (req, res) => {
  try {
    const { name, email, password, role, preferredName, gender, pronouns, smsPhone, smsEnabled } = req.body

    // Validate required fields
    if (!name || !email || !password || !role) {
      return res.status(400).json({ error: 'Name, email, password, and role are required' })
    }

    // Validate email format
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/
    if (!emailRegex.test(email)) {
      return res.status(400).json({ error: 'Invalid email format' })
    }

    // Validate role
    const validRoles = ['ORGANIZER', 'JUDGE', 'CONTESTANT', 'EMCEE', 'TALLY_MASTER', 'AUDITOR', 'BOARD']
    if (!validRoles.includes(role)) {
      return res.status(400).json({ error: 'Invalid role' })
    }

    // Check if email already exists
    const existingUser = await prisma.user.findUnique({
      where: { email }
    })

    if (existingUser) {
      return res.status(400).json({ error: 'User with this email already exists' })
    }

    const hashedPassword = await bcrypt.hash(password, 10)

    const user = await prisma.user.create({
      data: {
        name,
        email,
        password: hashedPassword,
        role,
        preferredName: preferredName || null,
        gender: gender || null,
        pronouns: pronouns || null,
        smsPhone: smsPhone || null,
        smsEnabled: smsEnabled || false
      }
    })

    res.status(201).json({
      id: user.id,
      name: user.name,
      email: user.email,
      role: user.role,
      preferredName: user.preferredName,
      gender: user.gender,
      pronouns: user.pronouns,
      smsPhone: user.smsPhone,
      smsEnabled: user.smsEnabled
    })
  } catch (error) {
    console.error('Create user error:', error)
    if (error.code === 'P2002') {
      res.status(400).json({ error: 'User with this email already exists' })
    } else {
      res.status(500).json({ error: 'Internal server error' })
    }
  }
}

const updateUser = async (req, res) => {
  try {
    const { id } = req.params
    const { name, email, role } = req.body

    const user = await prisma.user.update({
      where: { id },
      data: {
        name,
        email,
        role
      }
    })

    res.json({
      id: user.id,
      name: user.name,
      email: user.email,
      role: user.role
    })
  } catch (error) {
    console.error('Update user error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const deleteUser = async (req, res) => {
  try {
    const { id } = req.params

    await prisma.user.delete({
      where: { id }
    })

    res.status(204).send()
  } catch (error) {
    console.error('Delete user error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const resetPassword = async (req, res) => {
  try {
    const { id } = req.params
    const { newPassword } = req.body

    const hashedPassword = await bcrypt.hash(newPassword, 10)

    await prisma.user.update({
      where: { id },
      data: {
        password: hashedPassword
      }
    })

    res.json({ message: 'Password reset successfully' })
  } catch (error) {
    console.error('Reset password error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// CSV Import functionality
const importUsersFromCSV = async (req, res) => {
  try {
    const { csvData, userType } = req.body

    if (!csvData || !Array.isArray(csvData) || csvData.length === 0) {
      return res.status(400).json({ error: 'CSV data is required' })
    }

    if (!userType) {
      return res.status(400).json({ error: 'User type is required' })
    }

    const results = []
    const errors = []

    for (let i = 0; i < csvData.length; i++) {
      const row = csvData[i]
      try {
        // Validate required fields based on user type
        const requiredFields = ['name', 'email']
        const missingFields = requiredFields.filter(field => !row[field])
        
        if (missingFields.length > 0) {
          errors.push({
            row: i + 1,
            error: `Missing required fields: ${missingFields.join(', ')}`
          })
          continue
        }

        // Check if user already exists
        const existingUser = await prisma.user.findUnique({
          where: { email: row.email }
        })

        if (existingUser) {
          errors.push({
            row: i + 1,
            email: row.email,
            error: 'User already exists'
          })
          continue
        }

        // Hash password (use default or provided)
        const password = row.password || 'defaultPassword123!'
        const hashedPassword = await bcrypt.hash(password, 10)

        // Create user data
        const userData = {
          name: row.name,
          email: row.email,
          password: hashedPassword,
          role: userType,
          isActive: true,
          preferredName: row.preferredName || null,
          pronouns: row.pronouns || null,
          phone: row.phone || null,
          address: row.address || null,
          emergencyContact: row.emergencyContact || null,
          emergencyPhone: row.emergencyPhone || null,
          medicalInfo: row.medicalInfo || null,
          notes: row.notes || null
        }

        // Create user
        const user = await prisma.user.create({
          data: userData
        })

        // Create role-specific data
        if (userType === 'JUDGE' && row.judgeData) {
          await prisma.judge.create({
            data: {
              userId: user.id,
              experience: row.judgeData.experience || null,
              specialties: row.judgeData.specialties || null,
              certifications: row.judgeData.certifications || null,
              bio: row.judgeData.bio || null,
              availability: row.judgeData.availability || null
            }
          })
        } else if (userType === 'CONTESTANT' && row.contestantData) {
          await prisma.contestant.create({
            data: {
              userId: user.id,
              contestantNumber: row.contestantData.contestantNumber || null,
              age: row.contestantData.age || null,
              school: row.contestantData.school || null,
              grade: row.contestantData.grade || null,
              parentGuardian: row.contestantData.parentGuardian || null,
              parentPhone: row.contestantData.parentPhone || null,
              parentEmail: row.contestantData.parentEmail || null,
              bio: row.contestantData.bio || null,
              achievements: row.contestantData.achievements || null
            }
          })
        }

        results.push({
          row: i + 1,
          user: {
            id: user.id,
            name: user.name,
            email: user.email,
            role: user.role
          },
          status: 'SUCCESS'
        })
      } catch (error) {
        console.error(`Error processing row ${i + 1}:`, error)
        errors.push({
          row: i + 1,
          error: error.message
        })
      }
    }

    res.json({
      message: 'CSV import completed',
      totalProcessed: csvData.length,
      successful: results.length,
      failed: errors.length,
      results: results,
      errors: errors
    })
  } catch (error) {
    console.error('CSV import error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get CSV template
const getCSVTemplate = async (req, res) => {
  try {
    const { userType } = req.query

    if (!userType) {
      return res.status(400).json({ error: 'User type is required' })
    }

    let template = {
      headers: ['name', 'email', 'preferredName', 'pronouns', 'phone', 'address', 'emergencyContact', 'emergencyPhone', 'medicalInfo', 'notes'],
      sample: {
        name: 'John Doe',
        email: 'john.doe@example.com',
        preferredName: 'Johnny',
        pronouns: 'he/him',
        phone: '555-1234',
        address: '123 Main St, City, State 12345',
        emergencyContact: 'Jane Doe',
        emergencyPhone: '555-5678',
        medicalInfo: 'None',
        notes: 'Sample user'
      }
    }

    // Add role-specific fields
    if (userType === 'JUDGE') {
      template.headers.push('judgeData.experience', 'judgeData.specialties', 'judgeData.certifications', 'judgeData.bio', 'judgeData.availability')
      template.sample['judgeData.experience'] = '5 years'
      template.sample['judgeData.specialties'] = 'Speech, Debate'
      template.sample['judgeData.certifications'] = 'Certified Judge'
      template.sample['judgeData.bio'] = 'Experienced judge'
      template.sample['judgeData.availability'] = 'Weekends'
    } else if (userType === 'CONTESTANT') {
      template.headers.push('contestantData.contestantNumber', 'contestantData.age', 'contestantData.school', 'contestantData.grade', 'contestantData.parentGuardian', 'contestantData.parentPhone', 'contestantData.parentEmail', 'contestantData.bio', 'contestantData.achievements')
      template.sample['contestantData.contestantNumber'] = '001'
      template.sample['contestantData.age'] = '16'
      template.sample['contestantData.school'] = 'High School'
      template.sample['contestantData.grade'] = '11'
      template.sample['contestantData.parentGuardian'] = 'Jane Doe'
      template.sample['contestantData.parentPhone'] = '555-5678'
      template.sample['contestantData.parentEmail'] = 'jane.doe@example.com'
      template.sample['contestantData.bio'] = 'Student bio'
      template.sample['contestantData.achievements'] = 'Previous awards'
    }

    res.json(template)
  } catch (error) {
    console.error('Get CSV template error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Update user last login
const updateLastLogin = async (req, res) => {
  try {
    const { id } = req.params

    const user = await prisma.user.update({
      where: { id },
      data: {
        lastLoginAt: new Date()
      }
    })

    res.json({
      id: user.id,
      name: user.name,
      email: user.email,
      lastLoginAt: user.lastLoginAt
    })
  } catch (error) {
    console.error('Update last login error:', error)
    if (error.code === 'P2025') {
      res.status(404).json({ error: 'User not found' })
    } else {
      res.status(500).json({ error: 'Internal server error' })
    }
  }
}

// Bulk remove users
const bulkRemoveUsers = async (req, res) => {
  try {
    const { userIds } = req.body

    if (!userIds || !Array.isArray(userIds) || userIds.length === 0) {
      return res.status(400).json({ error: 'User IDs array is required' })
    }

    // Prevent deletion of admin users
    const adminUsers = await prisma.user.findMany({
      where: {
        id: { in: userIds },
        role: 'ORGANIZER'
      }
    })

    if (adminUsers.length > 0) {
      return res.status(400).json({ 
        error: 'Cannot delete admin users',
        adminUsers: adminUsers.map(u => ({ id: u.id, name: u.name, email: u.email }))
      })
    }

    const result = await prisma.user.deleteMany({
      where: {
        id: { in: userIds }
      }
    })

    res.json({
      message: `${result.count} users deleted successfully`,
      deletedCount: result.count
    })
  } catch (error) {
    console.error('Bulk remove users error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get users by role
const getUsersByRole = async (req, res) => {
  try {
    const { role } = req.params

    const validRoles = ['ORGANIZER', 'JUDGE', 'CONTESTANT', 'EMCEE', 'TALLY_MASTER', 'AUDITOR', 'BOARD']
    if (!validRoles.includes(role)) {
      return res.status(400).json({ error: 'Invalid role' })
    }

    const users = await prisma.user.findMany({
      where: { role },
      include: {
        judge: true,
        contestant: true
      },
      orderBy: { createdAt: 'desc' }
    })

    res.json(users)
  } catch (error) {
    console.error('Get users by role error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Update user role-specific fields
const updateUserRoleFields = async (req, res) => {
  try {
    const { id } = req.params
    const { role, roleSpecificData } = req.body

    if (!role || !roleSpecificData) {
      return res.status(400).json({ error: 'Role and role-specific data are required' })
    }

    let updateData = {}

    switch (role) {
      case 'JUDGE':
        updateData = {
          judgeBio: roleSpecificData.bio || null,
          judgeSpecialties: roleSpecificData.specialties ? JSON.stringify(roleSpecificData.specialties) : null,
          judgeCertifications: roleSpecificData.certifications ? JSON.stringify(roleSpecificData.certifications) : null,
          isHeadJudge: roleSpecificData.isHeadJudge || false
        }
        break

      case 'CONTESTANT':
        updateData = {
          contestantBio: roleSpecificData.bio || null,
          contestantNumber: roleSpecificData.number || null,
          contestantAge: roleSpecificData.age || null,
          contestantSchool: roleSpecificData.school || null
        }
        break

      case 'EMCEE':
        updateData = {
          bio: roleSpecificData.bio || null,
          phone: roleSpecificData.phone || null
        }
        break

      default:
        updateData = {
          bio: roleSpecificData.bio || null,
          phone: roleSpecificData.phone || null
        }
    }

    const user = await prisma.user.update({
      where: { id },
      data: updateData
    })

    res.json(user)
  } catch (error) {
    console.error('Update user role fields error:', error)
    if (error.code === 'P2025') {
      res.status(404).json({ error: 'User not found' })
    } else {
      res.status(500).json({ error: 'Internal server error' })
    }
  }
}

// Get user statistics
const getUserStats = async (req, res) => {
  try {
    const [totalUsers, usersByRole, recentLogins] = await Promise.all([
      prisma.user.count(),
      prisma.user.groupBy({
        by: ['role'],
        _count: {
          role: true
        }
      }),
      prisma.user.count({
        where: {
          lastLoginAt: {
            gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) // Last 7 days
          }
        }
      })
    ])

    const roleStats = usersByRole.reduce((acc, item) => {
      acc[item.role] = item._count.role
      return acc
    }, {})

    res.json({
      totalUsers,
      usersByRole: roleStats,
      recentLogins,
      lastWeek: recentLogins
    })
  } catch (error) {
    console.error('Get user stats error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  getAllUsers,
  getUserById,
  createUser,
  updateUser,
  deleteUser,
  resetPassword,
  importUsersFromCSV,
  getCSVTemplate,
  updateLastLogin,
  bulkRemoveUsers,
  getUsersByRole,
  updateUserRoleFields,
  getUserStats
}
EOF

    # Scoring Controller
    cat > "$APP_DIR/src/controllers/scoringController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

const getScores = async (req, res) => {
  try {
    const { categoryId, contestantId } = req.params

    let whereClause = { categoryId }
    if (contestantId) {
      whereClause.contestantId = contestantId
    }

    const scores = await prisma.score.findMany({
      where: whereClause,
      include: {
        contestant: true,
        judge: true,
        category: true
      },
      orderBy: { createdAt: 'desc' }
    })

    res.json(scores)
  } catch (error) {
    console.error('Get scores error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const submitScore = async (req, res) => {
  try {
    const { categoryId, contestantId } = req.params
    const { criteriaId, score, comments } = req.body

    const scoreRecord = await prisma.score.create({
      data: {
        categoryId,
        contestantId,
        judgeId: req.user.id,
        criteriaId,
        score,
        comments
      }
    })

    res.status(201).json(scoreRecord)
  } catch (error) {
    console.error('Submit score error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const updateScore = async (req, res) => {
  try {
    const { scoreId } = req.params
    const { score, comments } = req.body

    const scoreRecord = await prisma.score.update({
      where: { id: scoreId },
      data: {
        score,
        comments
      }
    })

    res.json(scoreRecord)
  } catch (error) {
    console.error('Update score error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const deleteScore = async (req, res) => {
  try {
    const { scoreId } = req.params

    await prisma.score.delete({
      where: { id: scoreId }
    })

    res.status(204).send()
  } catch (error) {
    console.error('Delete score error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const certifyScores = async (req, res) => {
  try {
    const { categoryId } = req.params

    // Update all scores in the category to certified
    await prisma.score.updateMany({
      where: { categoryId },
      data: { certified: true }
    })

    res.json({ message: 'Scores certified successfully' })
  } catch (error) {
    console.error('Certify scores error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const certifyTotals = async (req, res) => {
  try {
    const { categoryId } = req.params

    // Calculate totals and mark as certified
    const scores = await prisma.score.findMany({
      where: { categoryId }
    })

    // Group by contestant and calculate totals
    const totals = {}
    scores.forEach(score => {
      if (!totals[score.contestantId]) {
        totals[score.contestantId] = 0
      }
      totals[score.contestantId] += score.score
    })

    // Update category totals
    await prisma.category.update({
      where: { id: categoryId },
      data: { totalsCertified: true }
    })

    res.json({ message: 'Totals certified successfully', totals })
  } catch (error) {
    console.error('Certify totals error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const finalCertification = async (req, res) => {
  try {
    const { categoryId } = req.params

    // Mark category as finally certified
    await prisma.category.update({
      where: { id: categoryId },
      data: { finalCertified: true }
    })

    res.json({ message: 'Final certification completed' })
  } catch (error) {
    console.error('Final certification error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Point deduction approval functionality
const requestDeduction = async (req, res) => {
  try {
    const { categoryId, contestantId, deduction, reason } = req.body
    const requestedBy = req.user.id

    if (!categoryId || !contestantId || deduction === undefined || !reason) {
      return res.status(400).json({ error: 'Category ID, Contestant ID, deduction amount, and reason are required' })
    }

    // Check if user has permission to request deductions
    if (!['JUDGE', 'TALLY_MASTER', 'AUDITOR', 'BOARD'].includes(req.user.role)) {
      return res.status(403).json({ error: 'Insufficient permissions to request deductions' })
    }

    // Check if deduction already exists
    const existingDeduction = await prisma.overallDeduction.findUnique({
      where: {
        categoryId_contestantId: {
          categoryId,
          contestantId
        }
      }
    })

    if (existingDeduction) {
      return res.status(400).json({ error: 'Deduction already exists for this contestant in this category' })
    }

    // Create deduction request
    const deductionRequest = await prisma.overallDeduction.create({
      data: {
        categoryId,
        contestantId,
        deduction,
        reason,
        requestedBy
      },
      include: {
        category: {
          include: {
            contest: {
              include: {
                event: true
              }
            }
          }
        },
        contestant: {
          include: {
            user: true
          }
        }
      }
    })

    res.json({
      message: 'Deduction request created successfully',
      deduction: deductionRequest
    })
  } catch (error) {
    console.error('Request deduction error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const approveDeduction = async (req, res) => {
  try {
    const { deductionId } = req.params
    const { signature } = req.body
    const userId = req.user.id
    const userRole = req.user.role

    if (!signature) {
      return res.status(400).json({ error: 'Signature is required' })
    }

    // Check if user has permission to approve deductions
    if (!['BOARD', 'AUDITOR', 'TALLY_MASTER'].includes(userRole)) {
      return res.status(403).json({ error: 'Insufficient permissions to approve deductions' })
    }

    const deduction = await prisma.overallDeduction.findUnique({
      where: { id: deductionId },
      include: {
        category: true,
        contestant: {
          include: {
            user: true
          }
        }
      }
    })

    if (!deduction) {
      return res.status(404).json({ error: 'Deduction not found' })
    }

    // Update the deduction with the signature
    let updateData = {}
    if (userRole === 'TALLY_MASTER') {
      updateData = {
        tallySignature: signature,
        tallySignedAt: new Date(),
        tallySignedBy: userId
      }
    } else if (userRole === 'AUDITOR') {
      updateData = {
        auditorSignature: signature,
        auditorSignedAt: new Date(),
        auditorSignedBy: userId
      }
    } else if (userRole === 'BOARD') {
      updateData = {
        boardSignature: signature,
        boardSignedAt: new Date(),
        boardSignedBy: userId
      }
    }

    const updatedDeduction = await prisma.overallDeduction.update({
      where: { id: deductionId },
      data: updateData,
      include: {
        category: {
          include: {
            contest: {
              include: {
                event: true
              }
            }
          }
        },
        contestant: {
          include: {
            user: true
          }
        }
      }
    })

    // Check if all required signatures are present
    const hasTallySignature = !!updatedDeduction.tallySignature
    const hasAuditorSignature = !!updatedDeduction.auditorSignature
    const hasBoardSignature = !!updatedDeduction.boardSignature

    if (hasTallySignature && hasAuditorSignature && hasBoardSignature) {
      // All signatures present, deduction is approved
      await prisma.overallDeduction.update({
        where: { id: deductionId },
        data: { status: 'APPROVED' }
      })

      res.json({
        message: 'Deduction approved successfully',
        deduction: updatedDeduction
      })
    } else {
      res.json({
        message: 'Signature added, waiting for additional signatures',
        deduction: updatedDeduction
      })
    }
  } catch (error) {
    console.error('Approve deduction error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const rejectDeduction = async (req, res) => {
  try {
    const { deductionId } = req.params
    const { reason } = req.body

    if (!reason) {
      return res.status(400).json({ error: 'Rejection reason is required' })
    }

    // Check if user has permission to reject deductions
    if (!['BOARD', 'AUDITOR'].includes(req.user.role)) {
      return res.status(403).json({ error: 'Insufficient permissions to reject deductions' })
    }

    const deduction = await prisma.overallDeduction.update({
      where: { id: deductionId },
      data: {
        status: 'REJECTED',
        rejectionReason: reason,
        rejectedAt: new Date(),
        rejectedBy: req.user.id
      },
      include: {
        category: {
          include: {
            contest: {
              include: {
                event: true
              }
            }
          }
        },
        contestant: {
          include: {
            user: true
          }
        }
      }
    })

    res.json({
      message: 'Deduction rejected successfully',
      deduction
    })
  } catch (error) {
    console.error('Reject deduction error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getDeductions = async (req, res) => {
  try {
    const { categoryId } = req.query

    let whereClause = {}
    if (categoryId) {
      whereClause.categoryId = categoryId
    }

    const deductions = await prisma.overallDeduction.findMany({
      where: whereClause,
      include: {
        category: {
          include: {
            contest: {
              include: {
                event: true
              }
            }
          }
        },
        contestant: {
          include: {
            user: true
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    })

    res.json(deductions)
  } catch (error) {
    console.error('Get deductions error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  getScores,
  submitScore,
  updateScore,
  deleteScore,
  certifyScores,
  certifyTotals,
  finalCertification,
  requestDeduction,
  approveDeduction,
  rejectDeduction,
  getDeductions
}
EOF

    # Results Controller
    cat > "$APP_DIR/src/controllers/resultsController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

const getAllResults = async (req, res) => {
  try {
    const results = await prisma.score.groupBy({
      by: ['categoryId', 'contestantId'],
      _sum: {
        score: true
      },
      _count: {
        score: true
      }
    })

    res.json(results)
  } catch (error) {
    console.error('Get results error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getCategories = async (req, res) => {
  try {
    const categories = await prisma.category.findMany({
      include: {
        contest: {
          include: {
            event: true
          }
        }
      }
    })

    res.json(categories)
  } catch (error) {
    console.error('Get categories error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getContestantResults = async (req, res) => {
  try {
    const { contestantId } = req.params

    const results = await prisma.score.findMany({
      where: { contestantId },
      include: {
        category: {
          include: {
            contest: {
              include: {
                event: true
              }
            }
          }
        },
        judge: true
      }
    })

    res.json(results)
  } catch (error) {
    console.error('Get contestant results error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getCategoryResults = async (req, res) => {
  try {
    const { categoryId } = req.params

    const results = await prisma.score.groupBy({
      by: ['contestantId'],
      where: { categoryId },
      _sum: {
        score: true
      },
      _count: {
        score: true
      }
    })

    res.json(results)
  } catch (error) {
    console.error('Get category results error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getContestResults = async (req, res) => {
  try {
    const { contestId } = req.params

    const results = await prisma.score.findMany({
      where: {
        category: {
          contestId
        }
      },
      include: {
        category: true,
        contestant: true,
        judge: true
      }
    })

    res.json(results)
  } catch (error) {
    console.error('Get contest results error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getEventResults = async (req, res) => {
  try {
    const { eventId } = req.params

    const results = await prisma.score.findMany({
      where: {
        category: {
          contest: {
            eventId
          }
        }
      },
      include: {
        category: {
          include: {
            contest: true
          }
        },
        contestant: true,
        judge: true
      }
    })

    res.json(results)
  } catch (error) {
    console.error('Get event results error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  getAllResults,
  getCategories,
  getContestantResults,
  getCategoryResults,
  getContestResults,
  getEventResults
}
EOF

    # Admin Controller
    cat > "$APP_DIR/src/controllers/adminController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

const getStats = async (req, res) => {
  try {
    const stats = {
      users: await prisma.user.count(),
      events: await prisma.event.count(),
      contests: await prisma.contest.count(),
      categories: await prisma.category.count(),
      scores: await prisma.score.count()
    }

    res.json(stats)
  } catch (error) {
    console.error('Get stats error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getLogs = async (req, res) => {
  try {
    const logs = await prisma.activityLog.findMany({
      include: {
        user: {
          select: {
            name: true,
            email: true
          }
        }
      },
      orderBy: { createdAt: 'desc' },
      take: 100
    })

    res.json(logs)
  } catch (error) {
    console.error('Get logs error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getActiveUsers = async (req, res) => {
  try {
    const activeUsers = await prisma.user.findMany({
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
        createdAt: true
      }
    })
    
    res.json(activeUsers)
  } catch (error) {
    console.error('Get active users error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getUsers = async (req, res) => {
  try {
    const users = await prisma.user.findMany({
      include: {
        judge: true,
        contestant: true
      },
      orderBy: { createdAt: 'desc' }
    })

    res.json(users)
  } catch (error) {
    console.error('Get users error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getEvents = async (req, res) => {
  try {
    const events = await prisma.event.findMany({
      include: {
        _count: {
          select: {
            contests: true,
            contestants: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    })

    res.json(events)
  } catch (error) {
    console.error('Get events error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getContests = async (req, res) => {
  try {
    const contests = await prisma.contest.findMany({
      include: {
        event: true,
        _count: {
          select: {
            categories: true,
            contestants: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    })

    res.json(contests)
  } catch (error) {
    console.error('Get contests error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getCategories = async (req, res) => {
  try {
    const categories = await prisma.category.findMany({
      include: {
        contest: {
          include: {
            event: true
          }
        },
        _count: {
          select: {
            criteria: true,
            contestants: true,
            judges: true,
            scores: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    })

    res.json(categories)
  } catch (error) {
    console.error('Get categories error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getScores = async (req, res) => {
  try {
    const scores = await prisma.score.findMany({
      include: {
        contestant: true,
        judge: true,
        category: {
          include: {
            contest: {
              include: {
                event: true
              }
            }
          }
        }
      },
      orderBy: { createdAt: 'desc' },
      take: 100
    })

    res.json(scores)
  } catch (error) {
    console.error('Get scores error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getActivityLogs = async (req, res) => {
  try {
    const logs = await prisma.activityLog.findMany({
      include: {
        user: {
          select: {
            name: true,
            email: true
          }
        }
      },
      orderBy: { createdAt: 'desc' },
      take: 100
    })

    res.json(logs)
  } catch (error) {
    console.error('Get activity logs error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getAuditLogs = async (req, res) => {
  try {
    const logs = await prisma.activityLog.findMany({
      where: {
        action: {
          in: ['CERTIFY_SCORES', 'CERTIFY_TOTALS', 'FINAL_CERTIFICATION', 'APPROVE_CERTIFICATION', 'REJECT_CERTIFICATION']
        }
      },
      include: {
        user: {
          select: {
            name: true,
            email: true
          }
        }
      },
      orderBy: { createdAt: 'desc' },
      take: 100
    })

    res.json(logs)
  } catch (error) {
    console.error('Get audit logs error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const exportAuditLogs = async (req, res) => {
  try {
    const logs = await prisma.activityLog.findMany({
      where: {
        action: {
          in: ['CERTIFY_SCORES', 'CERTIFY_TOTALS', 'FINAL_CERTIFICATION', 'APPROVE_CERTIFICATION', 'REJECT_CERTIFICATION']
        }
      },
      include: {
        user: {
          select: {
            name: true,
            email: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    })

    res.json(logs)
  } catch (error) {
    console.error('Export audit logs error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const testConnection = async (req, res) => {
  try {
    const { type } = req.params
    
    switch (type) {
      case 'database':
        await prisma.$queryRaw`SELECT 1`
        res.json({ status: 'success', message: 'Database connection successful' })
        break
      case 'email':
        // Test email configuration
        res.json({ status: 'success', message: 'Email configuration test successful' })
        break
      case 'backup':
        // Test backup functionality
        res.json({ status: 'success', message: 'Backup test passed' })
        break
      default:
        res.status(400).json({ error: 'Invalid test type' })
    }
  } catch (error) {
    console.error('Test connection error:', error)
    res.status(500).json({ error: 'Connection test failed', details: error.message })
  }
}

module.exports = {
  getStats,
  getLogs,
  getActiveUsers,
  getUsers,
  getEvents,
  getContests,
  getCategories,
  getScores,
  getActivityLogs,
  getAuditLogs,
  exportAuditLogs,
  testConnection
}
EOF

    # Database Browser Controller
    cat > "$APP_DIR/src/controllers/databaseBrowserController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

// Get all database tables
const getDatabaseTables = async (req, res) => {
  try {
    const tables = await prisma.$queryRaw`
      SELECT table_name 
      FROM information_schema.tables 
      WHERE table_schema = 'public' 
      AND table_type = 'BASE TABLE'
      ORDER BY table_name
    `

    res.json(tables)
  } catch (error) {
    console.error('Get database tables error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get table data with pagination and search
const getTableData = async (req, res) => {
  try {
    const { tableName } = req.params
    const { page = 1, limit = 50, search = '', sortBy = '', sortOrder = 'asc' } = req.query

    // Validate table name to prevent SQL injection
    const validTables = ['users', 'events', 'contests', 'categories', 'scores', 'judges', 'contestants', 'assignments', 'certifications', 'files', 'performance_logs', 'reports', 'emcee_scripts', 'winner_signatures', 'score_removal_requests']
    
    if (!validTables.includes(tableName)) {
      return res.status(400).json({ error: 'Invalid table name' })
    }

    const offset = (page - 1) * limit
    let query = `SELECT * FROM "${tableName}"`
    let countQuery = `SELECT COUNT(*) as count FROM "${tableName}"`

    // Add search functionality
    if (search) {
      const searchCondition = `WHERE ${Object.keys(await prisma[tableName].findFirst() || {}).slice(0, 5).map(col => '"' + col + '" ILIKE \'%' + search + '%\'').join(' OR ')}`
      query += ` ${searchCondition}`
      countQuery += ` ${searchCondition}`
    }

    // Add sorting
    if (sortBy) {
      query += ` ORDER BY "${sortBy}" ${sortOrder.toUpperCase()}`
    }

    // Add pagination
    query += ` LIMIT ${limit} OFFSET ${offset}`

    const [data, countResult] = await Promise.all([
      prisma.$queryRawUnsafe(query),
      prisma.$queryRawUnsafe(countQuery)
    ])

    const total = parseInt(countResult[0].count)

    res.json({
      data,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / limit)
      }
    })
  } catch (error) {
    console.error('Get table data error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get table schema
const getTableSchema = async (req, res) => {
  try {
    const { tableName } = req.params

    // Validate table name
    const validTables = ['users', 'events', 'contests', 'categories', 'scores', 'judges', 'contestants', 'assignments', 'certifications', 'files', 'performance_logs', 'reports', 'emcee_scripts', 'winner_signatures', 'score_removal_requests']
    
    if (!validTables.includes(tableName)) {
      return res.status(400).json({ error: 'Invalid table name' })
    }

    const schema = await prisma.$queryRaw`
      SELECT 
        column_name,
        data_type,
        is_nullable,
        column_default,
        character_maximum_length
      FROM information_schema.columns 
      WHERE table_name = ${tableName}
      AND table_schema = 'public'
      ORDER BY ordinal_position
    `

    res.json(schema)
  } catch (error) {
    console.error('Get table schema error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Execute custom query (read-only)
const executeQuery = async (req, res) => {
  try {
    const { query } = req.body

    if (!query) {
      return res.status(400).json({ error: 'Query is required' })
    }

    // Basic security check - only allow SELECT statements
    const trimmedQuery = query.trim().toLowerCase()
    if (!trimmedQuery.startsWith('select')) {
      return res.status(400).json({ error: 'Only SELECT queries are allowed' })
    }

    // Additional security checks
    const dangerousKeywords = ['drop', 'delete', 'update', 'insert', 'alter', 'create', 'truncate', 'exec', 'execute']
    if (dangerousKeywords.some(keyword => trimmedQuery.includes(keyword))) {
      return res.status(400).json({ error: 'Query contains dangerous keywords' })
    }

    const result = await prisma.$queryRawUnsafe(query)

    res.json({
      data: result,
      rowCount: result.length
    })
  } catch (error) {
    console.error('Execute query error:', error)
    res.status(500).json({ error: 'Query execution failed: ' + error.message })
  }
}

// Get database statistics
const getDatabaseStats = async (req, res) => {
  try {
    const stats = await prisma.$queryRaw`
      SELECT 
        schemaname,
        tablename,
        attname,
        n_distinct,
        correlation
      FROM pg_stats 
      WHERE schemaname = 'public'
      ORDER BY tablename, attname
    `

    res.json(stats)
  } catch (error) {
    console.error('Get database stats error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Insert new record into table
const insertRecord = async (req, res) => {
  try {
    const { tableName, data } = req.body

    if (!tableName || !data) {
      return res.status(400).json({ error: 'Table name and data are required' })
    }

    // Basic security check - only allow certain tables
    const allowedTables = ['users', 'events', 'contests', 'categories', 'contestants', 'judges']
    if (!allowedTables.includes(tableName.toLowerCase())) {
      return res.status(403).json({ error: 'Table not allowed for direct insertion' })
    }

    const result = await prisma.$executeRaw`
      INSERT INTO ${tableName} (${Object.keys(data).join(', ')})
      VALUES (${Object.values(data).map(val => typeof val === 'string' ? `'${val}'` : val).join(', ')})
      RETURNING *
    `

    res.status(201).json({ message: 'Record inserted successfully', data: result })
  } catch (error) {
    console.error('Insert record error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Update record in table
const updateRecord = async (req, res) => {
  try {
    const { tableName, id, data } = req.body

    if (!tableName || !id || !data) {
      return res.status(400).json({ error: 'Table name, ID, and data are required' })
    }

    // Basic security check
    const allowedTables = ['users', 'events', 'contests', 'categories', 'contestants', 'judges']
    if (!allowedTables.includes(tableName.toLowerCase())) {
      return res.status(403).json({ error: 'Table not allowed for direct updates' })
    }

    const setClause = Object.entries(data)
      .map(([key, value]) => `${key} = ${typeof value === 'string' ? `'${value}'` : value}`)
      .join(', ')

    const result = await prisma.$executeRaw`
      UPDATE ${tableName} 
      SET ${setClause}
      WHERE id = '${id}'
      RETURNING *
    `

    res.json({ message: 'Record updated successfully', data: result })
  } catch (error) {
    console.error('Update record error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Delete record from table
const deleteRecord = async (req, res) => {
  try {
    const { tableName, id } = req.body

    if (!tableName || !id) {
      return res.status(400).json({ error: 'Table name and ID are required' })
    }

    // Basic security check
    const allowedTables = ['users', 'events', 'contests', 'categories', 'contestants', 'judges']
    if (!allowedTables.includes(tableName.toLowerCase())) {
      return res.status(403).json({ error: 'Table not allowed for direct deletion' })
    }

    const result = await prisma.$executeRaw`
      DELETE FROM ${tableName} 
      WHERE id = '${id}'
      RETURNING *
    `

    res.json({ message: 'Record deleted successfully', data: result })
  } catch (error) {
    console.error('Delete record error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Execute custom query (with security restrictions)
const executeCustomQuery = async (req, res) => {
  try {
    const { query } = req.body

    if (!query) {
      return res.status(400).json({ error: 'Query is required' })
    }

    // Security checks
    const dangerousKeywords = ['DROP', 'DELETE', 'UPDATE', 'INSERT', 'ALTER', 'CREATE', 'TRUNCATE']
    const upperQuery = query.toUpperCase()
    
    for (const keyword of dangerousKeywords) {
      if (upperQuery.includes(keyword)) {
        return res.status(403).json({ error: `Operation '${keyword}' is not allowed` })
      }
    }

    // Only allow SELECT queries
    if (!upperQuery.trim().startsWith('SELECT')) {
      return res.status(403).json({ error: 'Only SELECT queries are allowed' })
    }

    const result = await prisma.$queryRawUnsafe(query)
    res.json({ data: result })
  } catch (error) {
    console.error('Execute custom query error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  getDatabaseTables,
  getTableData,
  getTableSchema,
  executeQuery,
  getDatabaseStats,
  insertRecord,
  updateRecord,
  deleteRecord,
  executeCustomQuery
}
EOF

    # Upload Controller
    cat > "$APP_DIR/src/controllers/uploadController.js" << 'EOF'
const fs = require('fs')
const path = require('path')
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

const uploadFile = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No file uploaded' })
    }

    const file = {
      filename: req.file.filename,
      originalName: req.file.originalname,
      mimetype: req.file.mimetype,
      size: req.file.size,
      path: req.file.path,
      uploadedBy: req.user.id
    }

    res.json({ message: 'File uploaded successfully', file })
  } catch (error) {
    console.error('Upload file error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const uploadImage = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No image uploaded' })
    }

    const image = {
      filename: req.file.filename,
      originalName: req.file.originalname,
      mimetype: req.file.mimetype,
      size: req.file.size,
      path: req.file.path,
      uploadedBy: req.user.id
    }

    res.json({ message: 'Image uploaded successfully', image })
  } catch (error) {
    console.error('Upload image error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const deleteFile = async (req, res) => {
  try {
    const { fileId } = req.params

    // Find the file record
    const file = await prisma.file.findUnique({
      where: { id: fileId }
    })

    if (!file) {
      return res.status(404).json({ error: 'File not found' })
    }

    // Delete the physical file
    if (fs.existsSync(file.path)) {
      fs.unlinkSync(file.path)
    }

    // Delete the database record
    await prisma.file.delete({
      where: { id: fileId }
    })

    res.json({ message: 'File deleted successfully' })
  } catch (error) {
    console.error('Delete file error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getFiles = async (req, res) => {
  try {
    // List files from the file system instead of database
    const uploadDir = path.join(process.cwd(), 'uploads')
    
    if (!fs.existsSync(uploadDir)) {
      return res.json([])
    }
    
    const files = fs.readdirSync(uploadDir)
    const fileList = files
      .filter(file => !fs.statSync(path.join(uploadDir, file)).isDirectory())
      .map(file => {
        const filePath = path.join(uploadDir, file)
        const stats = fs.statSync(filePath)
        return {
          id: file,
          filename: file,
          filepath: filePath,
          size: stats.size,
          createdAt: stats.birthtime,
          updatedAt: stats.mtime,
          uploadedBy: req.user?.id || 'system'
        }
      })
      .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))

    res.json(fileList)
  } catch (error) {
    console.error('Get files error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  uploadFile,
  uploadImage,
  deleteFile,
  getFiles
}
EOF

    # Settings Controller
    cat > "$APP_DIR/src/controllers/settingsController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

const getAllSettings = async (req, res) => {
  try {
    const settings = await prisma.systemSetting.findMany()
    res.json(settings)
  } catch (error) {
    console.error('Get all settings error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getSettings = async (req, res) => {
  try {
    const settings = await prisma.systemSetting.findMany()
    res.json(settings)
  } catch (error) {
    console.error('Get settings error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const updateSettings = async (req, res) => {
  try {
    const settings = req.body

    for (const [key, value] of Object.entries(settings)) {
      await prisma.systemSetting.upsert({
        where: { key: key },
        update: { 
          value: value,
          updatedAt: new Date(),
          updatedById: req.user?.id
        },
        create: { 
          key: key, 
          value: value,
          category: 'general',
          description: `Setting for ${key}`,
          updatedById: req.user?.id
        }
      })
    }

    res.json({ message: 'Settings updated successfully' })
  } catch (error) {
    console.error('Update settings error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const testSettings = async (req, res) => {
  try {
    const { type } = req.params

    switch (type) {
      case 'email':
        // Test email settings
        res.json({ status: 'success', message: 'Email settings test passed' })
        break
      case 'database':
        // Test database settings
        await prisma.$queryRaw`SELECT 1`
        res.json({ status: 'success', message: 'Database settings test passed' })
        break
      case 'backup':
        // Test backup settings
        res.json({ status: 'success', message: 'Backup settings test passed' })
        break
      default:
        res.status(400).json({ error: 'Invalid test type' })
    }
  } catch (error) {
    console.error('Test settings error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// JWT/Session timeout configuration
const updateJWTConfig = async (req, res) => {
  try {
    const { jwtExpiresIn, sessionTimeout, refreshTokenExpiresIn } = req.body

    if (!jwtExpiresIn) {
      return res.status(400).json({ error: 'JWT expiration time is required' })
    }

    // Validate JWT expiration format (e.g., "24h", "7d", "30m")
    const jwtExpirationRegex = /^\d+[hdm]$/
    if (!jwtExpirationRegex.test(jwtExpiresIn)) {
      return res.status(400).json({ error: 'Invalid JWT expiration format. Use format like "24h", "7d", "30m"' })
    }

    // Update JWT settings
    await prisma.systemSetting.upsert({
      where: { key: 'JWT_EXPIRES_IN' },
      update: { value: jwtExpiresIn },
      create: { key: 'JWT_EXPIRES_IN', value: jwtExpiresIn, description: 'JWT token expiration time' }
    })

    if (sessionTimeout) {
      await prisma.systemSetting.upsert({
        where: { key: 'SESSION_TIMEOUT' },
        update: { value: sessionTimeout.toString() },
        create: { key: 'SESSION_TIMEOUT', value: sessionTimeout.toString(), description: 'Session timeout in minutes' }
      })
    }

    if (refreshTokenExpiresIn) {
      await prisma.systemSetting.upsert({
        where: { key: 'REFRESH_TOKEN_EXPIRES_IN' },
        update: { value: refreshTokenExpiresIn },
        create: { key: 'REFRESH_TOKEN_EXPIRES_IN', value: refreshTokenExpiresIn, description: 'Refresh token expiration time' }
      })
    }

    res.json({ message: 'JWT configuration updated successfully' })
  } catch (error) {
    console.error('Update JWT config error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getJWTConfig = async (req, res) => {
  try {
    const settings = await prisma.systemSetting.findMany({
      where: {
        key: {
          in: ['JWT_EXPIRES_IN', 'SESSION_TIMEOUT', 'REFRESH_TOKEN_EXPIRES_IN']
        }
      }
    })

    const config = {
      jwtExpiresIn: settings.find(s => s.key === 'JWT_EXPIRES_IN')?.value || '24h',
      sessionTimeout: parseInt(settings.find(s => s.key === 'SESSION_TIMEOUT')?.value || '1440'), // 24 hours in minutes
      refreshTokenExpiresIn: settings.find(s => s.key === 'REFRESH_TOKEN_EXPIRES_IN')?.value || '7d'
    }

    res.json(config)
  } catch (error) {
    console.error('Get JWT config error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Specific settings endpoints
const getLoggingLevels = async (req, res) => {
  try {
    const settings = await prisma.systemSetting.findMany({
      where: {
        key: {
          in: ['LOG_LEVEL', 'LOG_RETENTION_DAYS', 'LOG_FILE_SIZE_MB']
        }
      }
    })
    res.json(settings)
  } catch (error) {
    console.error('Get logging levels error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const updateLoggingLevel = async (req, res) => {
  try {
    const settings = req.body

    for (const [key, value] of Object.entries(settings)) {
      await prisma.systemSetting.upsert({
        where: { key: key },
        update: { 
          value: value,
          updatedAt: new Date(),
          updatedById: req.user?.id
        },
        create: { 
          key: key, 
          value: value,
          category: 'logging',
          description: `Logging setting for ${key}`,
          updatedById: req.user?.id
        }
      })
    }

    res.json({ message: 'Logging levels updated successfully' })
  } catch (error) {
    console.error('Update logging levels error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getSecuritySettings = async (req, res) => {
  try {
    const settings = await prisma.systemSetting.findMany({
      where: {
        key: {
          in: ['PASSWORD_MIN_LENGTH', 'PASSWORD_REQUIRE_UPPERCASE', 'PASSWORD_REQUIRE_LOWERCASE', 'PASSWORD_REQUIRE_NUMBERS', 'PASSWORD_REQUIRE_SYMBOLS', 'LOGIN_ATTEMPTS_LIMIT', 'ACCOUNT_LOCKOUT_DURATION']
        }
      }
    })
    res.json(settings)
  } catch (error) {
    console.error('Get security settings error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const updateSecuritySettings = async (req, res) => {
  try {
    const settings = req.body

    for (const [key, value] of Object.entries(settings)) {
      await prisma.systemSetting.upsert({
        where: { key: key },
        update: { 
          value: value,
          updatedAt: new Date(),
          updatedById: req.user?.id
        },
        create: { 
          key: key, 
          value: value,
          category: 'security',
          description: `Security setting for ${key}`,
          updatedById: req.user?.id
        }
      })
    }

    res.json({ message: 'Security settings updated successfully' })
  } catch (error) {
    console.error('Update security settings error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getBackupSettings = async (req, res) => {
  try {
    const settings = await prisma.systemSetting.findMany({
      where: {
        key: {
          in: ['BACKUP_FREQUENCY', 'BACKUP_RETENTION_DAYS', 'BACKUP_LOCATION', 'AUTO_BACKUP_ENABLED']
        }
      }
    })
    res.json(settings)
  } catch (error) {
    console.error('Get backup settings error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const updateBackupSettings = async (req, res) => {
  try {
    const settings = req.body

    for (const [key, value] of Object.entries(settings)) {
      await prisma.systemSetting.upsert({
        where: { key: key },
        update: { 
          value: value,
          updatedAt: new Date(),
          updatedById: req.user?.id
        },
        create: { 
          key: key, 
          value: value,
          category: 'backup',
          description: `Backup setting for ${key}`,
          updatedById: req.user?.id
        }
      })
    }

    res.json({ message: 'Backup settings updated successfully' })
  } catch (error) {
    console.error('Update backup settings error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getEmailSettings = async (req, res) => {
  try {
    const settings = await prisma.systemSetting.findMany({
      where: {
        key: {
          in: ['SMTP_HOST', 'SMTP_PORT', 'SMTP_USER', 'SMTP_PASS', 'SMTP_SECURE', 'EMAIL_FROM', 'EMAIL_FROM_NAME']
        }
      }
    })
    res.json(settings)
  } catch (error) {
    console.error('Get email settings error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const updateEmailSettings = async (req, res) => {
  try {
    const settings = req.body

    for (const [key, value] of Object.entries(settings)) {
      await prisma.systemSetting.upsert({
        where: { key: key },
        update: { 
          value: value,
          updatedAt: new Date(),
          updatedById: req.user?.id
        },
        create: { 
          key: key, 
          value: value,
          category: 'email',
          description: `Email setting for ${key}`,
          updatedById: req.user?.id
        }
      })
    }

    res.json({ message: 'Email settings updated successfully' })
  } catch (error) {
    console.error('Update email settings error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  getAllSettings,
  getSettings,
  updateSettings,
  testSettings,
  updateJWTConfig,
  getJWTConfig,
  getLoggingLevels,
  updateLoggingLevel,
  getSecuritySettings,
  updateSecuritySettings,
  getBackupSettings,
  updateBackupSettings,
  getEmailSettings,
  updateEmailSettings
}
EOF

    # SMS Controller
    cat > "$APP_DIR/src/controllers/smsController.js" << 'EOF'
const twilio = require('twilio')
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

const getSMSSettings = async () => {
  try {
    const settings = await prisma.systemSetting.findMany({
      where: {
        key: {
          in: ['SMS_ENABLED', 'SMS_API_KEY', 'SMS_API_SECRET', 'SMS_FROM_NUMBER', 'SMS_PROVIDER']
        }
      }
    })

    const config = {}
    settings.forEach(setting => {
      config[setting.key.toLowerCase()] = setting.value
    })

    return {
      enabled: config.sms_enabled === 'true',
      apiKey: config.sms_api_key,
      apiSecret: config.sms_api_secret,
      fromNumber: config.sms_from_number,
      provider: config.sms_provider || 'twilio'
    }
  } catch (error) {
    console.error('Error getting SMS settings:', error)
    return {
      enabled: false,
      apiKey: '',
      apiSecret: '',
      fromNumber: '',
      provider: 'twilio'
    }
  }
}

const sendSMS = async (req, res) => {
  try {
    const { to, message } = req.body

    if (!to || !message) {
      return res.status(400).json({ error: 'Phone number and message are required' })
    }

    const settings = await getSMSSettings()

    if (!settings.enabled) {
      return res.status(400).json({ error: 'SMS notifications are disabled' })
    }

    if (!settings.apiKey || !settings.apiSecret || !settings.fromNumber) {
      return res.status(400).json({ error: 'SMS configuration is incomplete' })
    }

    let client
    if (settings.provider === 'twilio') {
      client = twilio(settings.apiKey, settings.apiSecret)
    } else {
      return res.status(400).json({ error: 'Unsupported SMS provider' })
    }

    const result = await client.messages.create({
      body: message,
      to: to,
      from: settings.fromNumber
    })

    // Log the SMS send
    await prisma.activityLog.create({
      data: {
        userId: req.user?.id,
        userName: req.user?.name,
        userRole: req.user?.role,
        action: 'SEND_SMS',
        resourceType: 'SMS',
        details: `SMS sent to ${to}: ${message.substring(0, 50)}...`,
        ipAddress: req.ip,
        userAgent: req.get('User-Agent')
      }
    })

    res.json({ 
      success: true, 
      message: 'SMS sent successfully',
      messageId: result.sid 
    })
  } catch (error) {
    console.error('Send SMS error:', error)
    res.status(500).json({ error: 'Failed to send SMS' })
  }
}

const sendBulkSMS = async (req, res) => {
  try {
    const { recipients, message } = req.body

    if (!recipients || !Array.isArray(recipients) || recipients.length === 0) {
      return res.status(400).json({ error: 'Recipients array is required' })
    }

    if (!message) {
      return res.status(400).json({ error: 'Message is required' })
    }

    const settings = await getSMSSettings()

    if (!settings.enabled) {
      return res.status(400).json({ error: 'SMS notifications are disabled' })
    }

    const results = []
    const errors = []

    for (const recipient of recipients) {
      try {
        let client
        if (settings.provider === 'twilio') {
          client = twilio(settings.apiKey, settings.apiSecret)
        }

        const result = await client.messages.create({
          body: message,
          to: recipient.phone,
          from: settings.fromNumber
        })

        results.push({
          phone: recipient.phone,
          name: recipient.name,
          messageId: result.sid,
          status: 'sent'
        })
      } catch (error) {
        errors.push({
          phone: recipient.phone,
          name: recipient.name,
          error: error.message
        })
      }
    }

    // Log the bulk SMS send
    await prisma.activityLog.create({
      data: {
        userId: req.user?.id,
        userName: req.user?.name,
        userRole: req.user?.role,
        action: 'SEND_BULK_SMS',
        resourceType: 'SMS',
        details: `Bulk SMS sent to ${recipients.length} recipients: ${message.substring(0, 50)}...`,
        ipAddress: req.ip,
        userAgent: req.get('User-Agent')
      }
    })

    res.json({
      success: true,
      message: `SMS sent to ${results.length} recipients`,
      results,
      errors
    })
  } catch (error) {
    console.error('Send bulk SMS error:', error)
    res.status(500).json({ error: 'Failed to send bulk SMS' })
  }
}

const sendNotificationSMS = async (req, res) => {
  try {
    const { userId, notificationType, data } = req.body

    if (!userId || !notificationType) {
      return res.status(400).json({ error: 'User ID and notification type are required' })
    }

    const user = await prisma.user.findUnique({
      where: { id: userId },
      include: { contestant: true, judge: true }
    })

    if (!user || !user.smsEnabled || !user.smsPhone) {
      return res.status(400).json({ error: 'User does not have SMS notifications enabled' })
    }

    let message = ''
    switch (notificationType) {
      case 'SCORE_SUBMISSION_REMINDER':
        message = `Reminder: Please submit your scores for ${data.categoryName || 'the category'}`
        break
      case 'CERTIFICATION_REQUEST':
        message = `Certification request: Please review and certify scores for ${data.categoryName || 'the category'}`
        break
      case 'EVENT_UPDATE':
        message = `Event update: ${data.message || 'There has been an update to your event'}`
        break
      case 'CONTEST_SCHEDULE_CHANGE':
        message = `Schedule change: ${data.message || 'Your contest schedule has been updated'}`
        break
      default:
        message = data.message || 'You have a new notification'
    }

    const settings = await getSMSSettings()

    if (!settings.enabled) {
      return res.status(400).json({ error: 'SMS notifications are disabled' })
    }

    let client
    if (settings.provider === 'twilio') {
      client = twilio(settings.apiKey, settings.apiSecret)
    }

    const result = await client.messages.create({
      body: message,
      to: user.smsPhone,
      from: settings.fromNumber
    })

    // Log the notification SMS
    await prisma.activityLog.create({
      data: {
        userId: req.user?.id,
        userName: req.user?.name,
        userRole: req.user?.role,
        action: 'SEND_NOTIFICATION_SMS',
        resourceType: 'SMS',
        details: `Notification SMS sent to ${user.name} (${user.smsPhone}): ${notificationType}`,
        ipAddress: req.ip,
        userAgent: req.get('User-Agent')
      }
    })

    res.json({
      success: true,
      message: 'Notification SMS sent successfully',
      messageId: result.sid
    })
  } catch (error) {
    console.error('Send notification SMS error:', error)
    res.status(500).json({ error: 'Failed to send notification SMS' })
  }
}

const getSMSHistory = async (req, res) => {
  try {
    const { page = 1, limit = 50 } = req.query
    const offset = (page - 1) * limit

    const logs = await prisma.activityLog.findMany({
      where: {
        action: {
          in: ['SEND_SMS', 'SEND_BULK_SMS', 'SEND_NOTIFICATION_SMS']
        }
      },
      orderBy: { createdAt: 'desc' },
      skip: offset,
      take: parseInt(limit),
      include: {
        user: {
          select: { name: true, email: true }
        }
      }
    })

    const total = await prisma.activityLog.count({
      where: {
        action: {
          in: ['SEND_SMS', 'SEND_BULK_SMS', 'SEND_NOTIFICATION_SMS']
        }
      }
    })

    res.json({
      logs,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / limit)
      }
    })
  } catch (error) {
    console.error('Get SMS history error:', error)
    res.status(500).json({ error: 'Failed to get SMS history' })
  }
}

module.exports = {
  sendSMS,
  sendBulkSMS,
  sendNotificationSMS,
  getSMSHistory
}
EOF

    # Archive Controller
    cat > "$APP_DIR/src/controllers/archiveController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

const getAllArchives = async (req, res) => {
  try {
    const archives = await prisma.archivedEvent.findMany({
      include: {
        event: true
      },
      orderBy: { createdAt: 'desc' }
    })

    res.json(archives)
  } catch (error) {
    console.error('Get archives error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getActiveEvents = async (req, res) => {
  try {
    const events = await prisma.event.findMany({
      where: { archived: false },
      include: {
        _count: {
          select: {
            contests: true,
            contestants: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    })

    res.json(events)
  } catch (error) {
    console.error('Get active events error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getArchivedEvents = async (req, res) => {
  try {
    const events = await prisma.event.findMany({
      where: { archived: true },
      include: {
        _count: {
          select: {
            contests: true,
            contestants: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    })

    res.json(events)
  } catch (error) {
    console.error('Get archived events error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const archiveItem = async (req, res) => {
  try {
    const { type, id } = req.params
    const { reason } = req.body

    const archive = await prisma.archivedEvent.create({
      data: {
        eventId: id,
        reason,
        archivedBy: req.user.id
      }
    })

    res.json(archive)
  } catch (error) {
    console.error('Archive item error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const restoreItem = async (req, res) => {
  try {
    const { type, id } = req.params

    await prisma.archivedEvent.deleteMany({
      where: {
        eventId: id
      }
    })

    res.json({ message: 'Item restored successfully' })
  } catch (error) {
    console.error('Restore item error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const deleteArchivedItem = async (req, res) => {
  try {
    const { type, id } = req.params

    await prisma.archivedEvent.deleteMany({
      where: {
        eventId: id
      }
    })

    res.json({ message: 'Archived item deleted successfully' })
  } catch (error) {
    console.error('Delete archived item error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const archiveEvent = async (req, res) => {
  try {
    const { eventId } = req.params
    const { reason } = req.body

    await prisma.event.update({
      where: { id: eventId },
      data: { archived: true }
    })

    const archive = await prisma.archivedEvent.create({
      data: {
        eventId: eventId,
        reason,
        archivedBy: req.user.id
      }
    })

    res.json(archive)
  } catch (error) {
    console.error('Archive event error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const restoreEvent = async (req, res) => {
  try {
    const { eventId } = req.params

    await prisma.event.update({
      where: { id: eventId },
      data: { archived: false }
    })

    await prisma.archivedEvent.deleteMany({
      where: {
        eventId: eventId
      }
    })

    res.json({ message: 'Event restored successfully' })
  } catch (error) {
    console.error('Restore event error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  getAllArchives,
  getActiveEvents,
  getArchivedEvents,
  archiveItem,
  restoreItem,
  deleteArchivedItem,
  archiveEvent,
  restoreEvent
}
EOF

    # Backup Controller
    cat > "$APP_DIR/src/controllers/backupController.js" << 'EOF'
const fs = require('fs')
const path = require('path')
const { exec } = require('child_process')
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

const getAllBackups = async (req, res) => {
  try {
    // List backup files from the file system instead of database
    const backupDir = path.join(process.cwd(), 'backups')
    
    if (!fs.existsSync(backupDir)) {
      return res.json([])
    }
    
    const files = fs.readdirSync(backupDir)
    const backups = files
      .filter(file => file.endsWith('.sql') || file.endsWith('.backup'))
      .map(file => {
        const filePath = path.join(backupDir, file)
        const stats = fs.statSync(filePath)
        return {
          id: file,
          filename: file,
          filepath: filePath,
          size: stats.size,
          createdAt: stats.birthtime,
          updatedAt: stats.mtime
        }
      })
      .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))

    res.json(backups)
  } catch (error) {
    console.error('Get backups error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const createBackup = async (req, res) => {
  try {
    const { type } = req.body
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-')
    const filename = `backup-${type.toLowerCase()}-${timestamp}.sql`
    const filepath = path.join('backups', filename)

    // Ensure backups directory exists
    if (!fs.existsSync('backups')) {
      fs.mkdirSync('backups', { recursive: true })
    }

    // Create backup based on type
    let command
    switch (type) {
      case 'FULL':
        command = `pg_dump ${process.env.DATABASE_URL} > ${filepath}`
        break
      case 'SCHEMA':
        command = `pg_dump --schema-only ${process.env.DATABASE_URL} > ${filepath}`
        break
      case 'DATA':
        command = `pg_dump --data-only ${process.env.DATABASE_URL} > ${filepath}`
        break
      default:
        return res.status(400).json({ error: 'Invalid backup type' })
    }

    exec(command, async (error, stdout, stderr) => {
      if (error) {
        console.error('Backup error:', error)
        return res.status(500).json({ error: 'Backup failed' })
      }

      // Return backup information (no database record needed)
      res.json({
        id: filename,
        filename,
        type,
        filepath,
        createdBy: req.user.id,
        createdAt: new Date()
      })
    })
  } catch (error) {
    console.error('Create backup error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const listBackups = async (req, res) => {
  try {
    // List backup files from the file system instead of database
    const backupDir = path.join(process.cwd(), 'backups')
    
    if (!fs.existsSync(backupDir)) {
      return res.json([])
    }
    
    const files = fs.readdirSync(backupDir)
    const backups = files
      .filter(file => file.endsWith('.sql') || file.endsWith('.backup'))
      .map(file => {
        const filePath = path.join(backupDir, file)
        const stats = fs.statSync(filePath)
        return {
          id: file,
          filename: file,
          filepath: filePath,
          size: stats.size,
          createdAt: stats.birthtime,
          updatedAt: stats.mtime
        }
      })
      .sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))

    res.json(backups)
  } catch (error) {
    console.error('List backups error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const downloadBackup = async (req, res) => {
  try {
    const { backupId } = req.params
    
    // Find backup file in the file system
    const backupDir = path.join(process.cwd(), 'backups')
    const filePath = path.join(backupDir, backupId)
    
    if (!fs.existsSync(filePath)) {
      return res.status(404).json({ error: 'Backup file not found' })
    }

    res.download(filePath, backupId)
  } catch (error) {
    console.error('Download backup error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const restoreBackup = async (req, res) => {
  try {
    const { backupIdOrFile } = req.params

    let filepath
    if (backupIdOrFile.includes('.')) {
      // It's a filename
      filepath = path.join('backups', backupIdOrFile)
    } else {
      // It's a backup ID (filename)
      filepath = path.join('backups', backupIdOrFile)
    }

    if (!fs.existsSync(filepath)) {
      return res.status(404).json({ error: 'Backup file not found' })
    }

    const command = `psql ${process.env.DATABASE_URL} < ${filepath}`

    exec(command, (error, stdout, stderr) => {
      if (error) {
        console.error('Restore error:', error)
        return res.status(500).json({ error: 'Restore failed' })
      }

      res.json({ message: 'Backup restored successfully' })
    })
  } catch (error) {
    console.error('Restore backup error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const deleteBackup = async (req, res) => {
  try {
    const { backupId } = req.params
    
    // Find backup file in the file system
    const backupDir = path.join(process.cwd(), 'backups')
    const filePath = path.join(backupDir, backupId)
    
    if (!fs.existsSync(filePath)) {
      return res.status(404).json({ error: 'Backup file not found' })
    }

    // Delete physical file
    fs.unlinkSync(filePath)
    
    res.json({ message: 'Backup deleted successfully' })
  } catch (error) {
    console.error('Delete backup error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  getAllBackups,
  createBackup,
  listBackups,
  downloadBackup,
  restoreBackup,
  deleteBackup
}
EOF

    # Assignments Controller
    cat > "$APP_DIR/src/controllers/assignmentsController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

const getAllAssignments = async (req, res) => {
  try {
    const { status, judgeId, categoryId, contestId, eventId } = req.query
    
    const assignments = await prisma.assignment.findMany({
      where: {
        ...(status && { status }),
        ...(judgeId && { judgeId }),
        ...(categoryId && { categoryId }),
        ...(contestId && { contestId }),
        ...(eventId && { eventId }),
      },
      include: {
        judge: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true,
            role: true,
            judgeBio: true,
            judgeSpecialties: true,
          }
        },
        category: {
          select: {
            id: true,
            name: true,
            description: true,
            scoreCap: true,
          }
        },
        contest: {
          select: {
            id: true,
            name: true,
            description: true,
          }
        },
        event: {
          select: {
            id: true,
            name: true,
            startDate: true,
            endDate: true,
          }
        }
      },
      orderBy: [
        { priority: 'desc' },
        { assignedAt: 'desc' }
      ]
    })
    
    res.json(assignments)
  } catch (error) {
    console.error('Get assignments error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const createAssignment = async (req, res) => {
  try {
    const { judgeId, categoryId, contestId, eventId, notes, priority } = req.body
    
    // Validate assignment doesn't already exist
    const existingAssignment = await prisma.assignment.findUnique({
      where: {
        judgeId_categoryId: {
          judgeId,
          categoryId
        }
      }
    })
    
    if (existingAssignment) {
      return res.status(400).json({ error: 'Assignment already exists' })
    }
    
    const assignment = await prisma.assignment.create({
      data: {
        judgeId,
        categoryId,
        contestId,
        eventId,
        assignedBy: req.user.id,
        notes,
        priority: priority || 1,
        status: 'PENDING'
      },
      include: {
        judge: true,
        category: true,
        contest: true,
        event: true
      }
    })
    
    res.status(201).json(assignment)
  } catch (error) {
    console.error('Create assignment error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const updateAssignment = async (req, res) => {
  try {
    const { id } = req.params
    const { status, notes, priority } = req.body
    
    const assignment = await prisma.assignment.update({
      where: { id },
      data: {
        ...(status && { status }),
        ...(notes !== undefined && { notes }),
        ...(priority !== undefined && { priority }),
      },
      include: {
        judge: true,
        category: true,
        contest: true,
        event: true
      }
    })
    
    res.json(assignment)
  } catch (error) {
    console.error('Update assignment error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const deleteAssignment = async (req, res) => {
  try {
    const { id } = req.params
    
    await prisma.assignment.delete({
      where: { id }
    })
    
    res.json({ message: 'Assignment deleted successfully' })
  } catch (error) {
    console.error('Delete assignment error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getJudgeAssignments = async (req, res) => {
  try {
    const { judgeId } = req.params
    
    const assignments = await prisma.assignment.findMany({
      where: { judgeId },
      include: {
        category: {
          include: {
            criteria: true,
            contestants: true
          }
        },
        contest: true,
        event: true
      },
      orderBy: [
        { priority: 'desc' },
        { assignedAt: 'desc' }
      ]
    })
    
    res.json(assignments)
  } catch (error) {
    console.error('Get judge assignments error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getJudges = async (req, res) => {
  try {
    const judges = await prisma.user.findMany({
      where: { role: 'JUDGE' },
      select: {
        id: true,
        name: true,
        preferredName: true,
        email: true,
        judgeBio: true,
        judgeSpecialties: true,
        judgeCertifications: true,
        isActive: true,
        createdAt: true
      }
    })

    res.json(judges)
  } catch (error) {
    console.error('Get judges error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getCategories = async (req, res) => {
  try {
    const { contestId, eventId } = req.query
    
    const categories = await prisma.category.findMany({
      where: {
        ...(contestId && { contestId }),
        ...(eventId && { 
          contest: {
            eventId
          }
        })
      },
      include: {
        contest: {
          include: {
            event: true
          }
        },
        criteria: true,
        contestants: true,
        judges: true
      }
    })

    res.json(categories)
  } catch (error) {
    console.error('Get categories error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const assignJudge = async (req, res) => {
  try {
    const { judgeId, categoryId, contestId, eventId, notes, priority } = req.body

    const assignment = await prisma.assignment.create({
      data: {
        judgeId,
        categoryId,
        contestId,
        eventId,
        assignedBy: req.user.id,
        notes,
        priority: priority || 1,
        status: 'PENDING'
      },
      include: {
        judge: true,
        category: true,
        contest: true,
        event: true
      }
    })

    res.status(201).json(assignment)
  } catch (error) {
    console.error('Assign judge error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const removeAssignment = async (req, res) => {
  try {
    const { assignmentId } = req.params

    await prisma.assignment.delete({
      where: { id: assignmentId }
    })

    res.status(204).send()
  } catch (error) {
    console.error('Remove assignment error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  getAllAssignments,
  createAssignment,
  updateAssignment,
  deleteAssignment,
  getJudgeAssignments,
  getJudges,
  getCategories,
  assignJudge,
  removeAssignment
}
EOF

    # Auditor Controller
    cat > "$APP_DIR/src/controllers/auditorController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

const getStats = async (req, res) => {
  try {
    const stats = {
      totalCategories: await prisma.category.count(),
      pendingAudits: await prisma.category.count({
        where: { totalsCertified: true, finalCertified: false }
      }),
      completedAudits: await prisma.category.count({
        where: { finalCertified: true }
      })
    }

    res.json(stats)
  } catch (error) {
    console.error('Get auditor stats error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getPendingAudits = async (req, res) => {
  try {
    const categories = await prisma.category.findMany({
      where: { totalsCertified: true, finalCertified: false },
      include: {
        contest: {
          include: {
            event: true
          }
        },
        scores: {
          include: {
            judge: true,
            contestant: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    })

    res.json(categories)
  } catch (error) {
    console.error('Get pending audits error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getCompletedAudits = async (req, res) => {
  try {
    const categories = await prisma.category.findMany({
      where: { finalCertified: true },
      include: {
        contest: {
          include: {
            event: true
          }
        },
        scores: {
          include: {
            judge: true,
            contestant: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    })

    res.json(categories)
  } catch (error) {
    console.error('Get completed audits error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const finalCertification = async (req, res) => {
  try {
    const { categoryId } = req.params

    await prisma.category.update({
      where: { id: categoryId },
      data: { finalCertified: true }
    })

    res.json({ message: 'Final certification completed' })
  } catch (error) {
    console.error('Final certification error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const rejectAudit = async (req, res) => {
  try {
    const { categoryId } = req.params
    const { reason } = req.body

    await prisma.category.update({
      where: { id: categoryId },
      data: { 
        finalCertified: false,
        rejectionReason: reason
      }
    })

    res.json({ message: 'Audit rejected' })
  } catch (error) {
    console.error('Reject audit error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getScoreVerification = async (req, res) => {
  try {
    const { categoryId, contestantId } = req.params

    const scores = await prisma.score.findMany({
      where: {
        categoryId,
        ...(contestantId && { contestantId })
      },
      include: {
        judge: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true,
            role: true
          }
        },
        contestant: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true,
            contestantNumber: true
          }
        },
        criterion: {
          select: {
            id: true,
            name: true,
            description: true,
            maxScore: true
          }
        },
        category: {
          select: {
            id: true,
            name: true,
            description: true,
            maxScore: true
          }
        }
      },
      orderBy: [
        { contestant: { name: 'asc' } },
        { criterion: { order: 'asc' } }
      ]
    })

    // Group scores by contestant for easier verification
    const groupedScores = scores.reduce((acc, score) => {
      const key = score.contestantId
      if (!acc[key]) {
        acc[key] = {
          contestant: score.contestant,
          scores: [],
          totalScore: 0,
          averageScore: 0
        }
      }
      acc[key].scores.push(score)
      acc[key].totalScore += score.score
      return acc
    }, {})

    // Calculate averages
    Object.values(groupedScores).forEach(group => {
      group.averageScore = group.scores.length > 0 ? group.totalScore / group.scores.length : 0
    })

    res.json({
      categoryId,
      scores: Object.values(groupedScores),
      totalScores: scores.length,
      uniqueContestants: Object.keys(groupedScores).length
    })
  } catch (error) {
    console.error('Get score verification error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const verifyScore = async (req, res) => {
  try {
    const { scoreId } = req.params
    const { verified, comments, issues } = req.body

    const score = await prisma.score.findUnique({
      where: { id: scoreId },
      include: {
        judge: true,
        contestant: true,
        criterion: true,
        category: true
      }
    })

    if (!score) {
      return res.status(404).json({ error: 'Score not found' })
    }

    // Update score with verification data
    const updatedScore = await prisma.score.update({
      where: { id: scoreId },
      data: {
        verified,
        verificationComments: comments,
        verificationIssues: issues,
        verifiedBy: req.user.id,
        verifiedAt: new Date()
      }
    })

    res.json(updatedScore)
  } catch (error) {
    console.error('Verify score error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getTallyMasterStatus = async (req, res) => {
  try {
    const { categoryId } = req.params

    const category = await prisma.category.findUnique({
      where: { id: categoryId },
      include: {
        contest: {
          include: {
            event: true
          }
        },
        scores: {
          include: {
            judge: true,
            contestant: true,
            criterion: true
          }
        }
      }
    })

    if (!category) {
      return res.status(404).json({ error: 'Category not found' })
    }

    // Calculate tally master status
    const totalScores = category.scores.length
    const verifiedScores = category.scores.filter(s => s.verified).length
    const pendingVerification = totalScores - verifiedScores

    const tallyStatus = {
      categoryId: category.id,
      categoryName: category.name,
      totalScores,
      verifiedScores,
      pendingVerification,
      verificationProgress: totalScores > 0 ? (verifiedScores / totalScores * 100).toFixed(2) : 0,
      totalsCertified: category.totalsCertified,
      finalCertified: category.finalCertified,
      tallyMasterCertified: category.tallyMasterCertified,
      auditorCertified: category.auditorCertified
    }

    res.json(tallyStatus)
  } catch (error) {
    console.error('Get tally master status error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getCertificationWorkflow = async (req, res) => {
  try {
    const { categoryId } = req.params

    const category = await prisma.category.findUnique({
      where: { id: categoryId },
      include: {
        contest: {
          include: {
            event: true
          }
        },
        scores: {
          include: {
            judge: true,
            contestant: true,
            criterion: true
          }
        }
      }
    })

    if (!category) {
      return res.status(404).json({ error: 'Category not found' })
    }

    const workflow = {
      categoryId: category.id,
      categoryName: category.name,
      contestName: category.contest.name,
      eventName: category.contest.event.name,
      steps: [
        {
          name: 'Judge Scoring',
          status: category.scores.length > 0 ? 'COMPLETED' : 'PENDING',
          completedAt: category.scores.length > 0 ? category.scores[0].createdAt : null,
          details: `${category.scores.length} scores submitted`
        },
        {
          name: 'Tally Master Review',
          status: category.tallyMasterCertified ? 'COMPLETED' : 'PENDING',
          completedAt: category.tallyMasterCertifiedAt,
          details: category.tallyMasterCertified ? 'Totals certified' : 'Pending tally review'
        },
        {
          name: 'Auditor Verification',
          status: category.auditorCertified ? 'COMPLETED' : 'PENDING',
          completedAt: category.auditorCertifiedAt,
          details: category.auditorCertified ? 'Final certification completed' : 'Pending auditor review'
        },
        {
          name: 'Board Approval',
          status: category.boardApproved ? 'COMPLETED' : 'PENDING',
          completedAt: category.boardApprovedAt,
          details: category.boardApproved ? 'Board approved' : 'Pending board approval'
        }
      ],
      currentStep: category.auditorCertified ? 3 : category.tallyMasterCertified ? 2 : 1,
      overallStatus: category.boardApproved ? 'APPROVED' : category.auditorCertified ? 'AUDITOR_CERTIFIED' : category.tallyMasterCertified ? 'TALLY_CERTIFIED' : 'PENDING'
    }

    res.json(workflow)
  } catch (error) {
    console.error('Get certification workflow error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const generateSummaryReport = async (req, res) => {
  try {
    const { categoryId, includeDetails = false } = req.body

    const category = await prisma.category.findUnique({
      where: { id: categoryId },
      include: {
        contest: {
          include: {
            event: true
          }
        },
        scores: {
          include: {
            judge: {
              select: {
                id: true,
                name: true,
                preferredName: true,
                email: true
              }
            },
            contestant: {
              select: {
                id: true,
                name: true,
                preferredName: true,
                email: true,
                contestantNumber: true
              }
            },
            criterion: {
              select: {
                id: true,
                name: true,
                description: true,
                maxScore: true
              }
            }
          }
        }
      }
    })

    if (!category) {
      return res.status(404).json({ error: 'Category not found' })
    }

    // Calculate summary statistics
    const totalScores = category.scores.length
    const uniqueContestants = new Set(category.scores.map(s => s.contestantId)).size
    const uniqueJudges = new Set(category.scores.map(s => s.judgeId)).size
    const averageScore = totalScores > 0 ? category.scores.reduce((sum, s) => sum + s.score, 0) / totalScores : 0
    const maxScore = Math.max(...category.scores.map(s => s.score), 0)
    const minScore = Math.min(...category.scores.map(s => s.score), 0)

    // Group by contestant for rankings
    const contestantScores = category.scores.reduce((acc, score) => {
      const key = score.contestantId
      if (!acc[key]) {
        acc[key] = {
          contestant: score.contestant,
          scores: [],
          totalScore: 0,
          averageScore: 0
        }
      }
      acc[key].scores.push(score)
      acc[key].totalScore += score.score
      return acc
    }, {})

    // Calculate averages and rankings
    const rankings = Object.values(contestantScores).map(group => {
      group.averageScore = group.scores.length > 0 ? group.totalScore / group.scores.length : 0
      return group
    }).sort((a, b) => b.averageScore - a.averageScore)

    // Add rank to each contestant
    rankings.forEach((contestant, index) => {
      contestant.rank = index + 1
    })

    const summaryReport = {
      category: {
        id: category.id,
        name: category.name,
        description: category.description,
        maxScore: category.maxScore
      },
      contest: {
        id: category.contest.id,
        name: category.contest.name,
        eventName: category.contest.event.name
      },
      statistics: {
        totalScores,
        uniqueContestants,
        uniqueJudges,
        averageScore: parseFloat(averageScore.toFixed(2)),
        maxScore,
        minScore,
        scoreRange: maxScore - minScore
      },
      rankings: includeDetails ? rankings : rankings.map(r => ({
        rank: r.rank,
        contestant: r.contestant,
        totalScore: r.totalScore,
        averageScore: parseFloat(r.averageScore.toFixed(2)),
        scoreCount: r.scores.length
      })),
      certification: {
        totalsCertified: category.totalsCertified,
        finalCertified: category.finalCertified,
        tallyMasterCertified: category.tallyMasterCertified,
        auditorCertified: category.auditorCertified,
        boardApproved: category.boardApproved
      },
      generatedAt: new Date().toISOString(),
      generatedBy: req.user.id
    }

    res.json(summaryReport)
  } catch (error) {
    console.error('Generate summary report error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getAuditHistory = async (req, res) => {
  try {
    const { categoryId, page = 1, limit = 20 } = req.query

    const whereClause = {
      ...(categoryId && { categoryId }),
      resourceType: 'CATEGORY'
    }

    const auditLogs = await prisma.activityLog.findMany({
      where: whereClause,
      include: {
        user: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true,
            role: true
          }
        }
      },
      orderBy: { createdAt: 'desc' },
      skip: (parseInt(page) - 1) * parseInt(limit),
      take: parseInt(limit)
    })

    const total = await prisma.activityLog.count({
      where: whereClause
    })

    res.json({
      auditLogs,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / parseInt(limit))
      }
    })
  } catch (error) {
    console.error('Get audit history error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  getStats,
  getPendingAudits,
  getCompletedAudits,
  finalCertification,
  rejectAudit,
  getScoreVerification,
  verifyScore,
  getTallyMasterStatus,
  getCertificationWorkflow,
  generateSummaryReport,
  getAuditHistory
}
EOF

    # Board Controller
    cat > "$APP_DIR/src/controllers/boardController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

const getStats = async (req, res) => {
  try {
    const stats = {
      totalCertifications: await prisma.category.count({
        where: { finalCertified: true }
      }),
      pendingApprovals: await prisma.category.count({
        where: { finalCertified: true, boardApproved: false }
      }),
      approvedCertifications: await prisma.category.count({
        where: { boardApproved: true }
      })
    }

    res.json(stats)
  } catch (error) {
    console.error('Get board stats error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getCertifications = async (req, res) => {
  try {
    const categories = await prisma.category.findMany({
      where: { finalCertified: true },
      include: {
        contest: {
          include: {
            event: true
          }
        },
        scores: {
          include: {
            judge: true,
            contestant: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    })

    res.json(categories)
  } catch (error) {
    console.error('Get certifications error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const approveCertification = async (req, res) => {
  try {
    const { id } = req.params

    await prisma.category.update({
      where: { id },
      data: { boardApproved: true }
    })

    res.json({ message: 'Certification approved' })
  } catch (error) {
    console.error('Approve certification error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const rejectCertification = async (req, res) => {
  try {
    const { id } = req.params
    const { reason } = req.body

    await prisma.category.update({
      where: { id },
      data: { 
        boardApproved: false,
        rejectionReason: reason
      }
    })

    res.json({ message: 'Certification rejected' })
  } catch (error) {
    console.error('Reject certification error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getCertificationStatus = async (req, res) => {
  try {
    const status = {
      total: await prisma.category.count(),
      pending: await prisma.category.count({
        where: { finalCertified: false }
      }),
      certified: await prisma.category.count({
        where: { finalCertified: true, boardApproved: false }
      }),
      approved: await prisma.category.count({
        where: { boardApproved: true }
      })
    }

    res.json(status)
  } catch (error) {
    console.error('Get certification status error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getEmceeScripts = async (req, res) => {
  try {
    const scripts = await prisma.emceeScript.findMany({
      where: { isActive: true },
      include: {
        event: true,
        contest: true,
        category: true
      },
      orderBy: { createdAt: 'desc' }
    })

    res.json(scripts)
  } catch (error) {
    console.error('Get emcee scripts error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const createEmceeScript = async (req, res) => {
  try {
    const { title, content, type, eventId, contestId, categoryId, order, notes } = req.body

    const script = await prisma.emceeScript.create({
      data: {
        title,
        content,
        type,
        eventId,
        contestId,
        categoryId,
        order: order || 0,
        notes,
        isActive: true,
        createdBy: req.user.id
      }
    })

    res.status(201).json(script)
  } catch (error) {
    console.error('Create emcee script error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const updateEmceeScript = async (req, res) => {
  try {
    const { id } = req.params
    const { title, content, type, eventId, contestId, categoryId, order, notes, isActive } = req.body

    const script = await prisma.emceeScript.update({
      where: { id },
      data: {
        title,
        content,
        type,
        eventId,
        contestId,
        categoryId,
        order,
        notes,
        isActive
      }
    })

    res.json(script)
  } catch (error) {
    console.error('Update emcee script error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const deleteEmceeScript = async (req, res) => {
  try {
    const { id } = req.params

    await prisma.emceeScript.delete({
      where: { id }
    })

    res.json({ message: 'Emcee script deleted successfully' })
  } catch (error) {
    console.error('Delete emcee script error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const generateReport = async (req, res) => {
  try {
    const { type, parameters } = req.body

    let reportData = null

    switch (type) {
      case 'CERTIFICATION_SUMMARY':
        reportData = await generateCertificationSummary(parameters)
        break
      case 'CONTEST_SUMMARY':
        reportData = await generateContestSummary(parameters)
        break
      case 'SCORE_REMOVAL_REQUESTS':
        reportData = await generateScoreRemovalRequests(parameters)
        break
      case 'EMCEE_SCRIPT_USAGE':
        reportData = await generateEmceeScriptUsage(parameters)
        break
      default:
        return res.status(400).json({ error: 'Invalid report type' })
    }

    res.json(reportData)
  } catch (error) {
    console.error('Generate report error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const generateCertificationSummary = async (parameters) => {
  const { eventId, contestId, categoryId, dateFrom, dateTo } = parameters

  const whereClause = {
    ...(eventId && { event: { id: eventId } }),
    ...(contestId && { contest: { id: contestId } }),
    ...(categoryId && { id: categoryId }),
    ...(dateFrom && dateTo && {
      createdAt: {
        gte: new Date(dateFrom),
        lte: new Date(dateTo)
      }
    })
  }

  const certifications = await prisma.certification.findMany({
    where: whereClause,
    include: {
      category: {
        include: {
          contest: {
            include: {
              event: true
            }
          }
        }
      }
    },
    orderBy: { createdAt: 'desc' }
  })

  const stats = {
    total: certifications.length,
    certified: certifications.filter(c => c.status === 'CERTIFIED').length,
    pending: certifications.filter(c => c.status === 'PENDING').length,
    rejected: certifications.filter(c => c.status === 'REJECTED').length
  }

  return {
    type: 'CERTIFICATION_SUMMARY',
    stats,
    certifications,
    generatedAt: new Date().toISOString(),
    generatedBy: 'BOARD'
  }
}

const generateContestSummary = async (parameters) => {
  const { eventId, contestId } = parameters

  const whereClause = {
    ...(eventId && { eventId }),
    ...(contestId && { id: contestId })
  }

  const contests = await prisma.contest.findMany({
    where: whereClause,
    include: {
      event: true,
      categories: {
        include: {
          scores: {
            include: {
              judge: true,
              contestant: true
            }
          }
        }
      },
      contestants: true,
      judges: true
    }
  })

  const summary = contests.map(contest => ({
    id: contest.id,
    name: contest.name,
    eventName: contest.event.name,
    categoriesCount: contest.categories.length,
    contestantsCount: contest.contestants.length,
    judgesCount: contest.judges.length,
    totalScores: contest.categories.reduce((sum, cat) => sum + cat.scores.length, 0),
    averageScore: contest.categories.reduce((sum, cat) => {
      const avg = cat.scores.length > 0 ? cat.scores.reduce((s, score) => s + score.score, 0) / cat.scores.length : 0
      return sum + avg
    }, 0) / contest.categories.length
  }))

  return {
    type: 'CONTEST_SUMMARY',
    summary,
    generatedAt: new Date().toISOString(),
    generatedBy: 'BOARD'
  }
}

const generateScoreRemovalRequests = async (parameters) => {
  const { status, dateFrom, dateTo } = parameters

  const whereClause = {
    ...(status && { status }),
    ...(dateFrom && dateTo && {
      createdAt: {
        gte: new Date(dateFrom),
        lte: new Date(dateTo)
      }
    })
  }

  const requests = await prisma.judgeScoreRemovalRequest.findMany({
    where: whereClause,
    include: {
      judge: true,
      category: {
        include: {
          contest: {
            include: {
              event: true
            }
          }
        }
      },
      score: {
        include: {
          contestant: true
        }
      }
    },
    orderBy: { createdAt: 'desc' }
  })

  const stats = {
    total: requests.length,
    pending: requests.filter(r => r.status === 'PENDING').length,
    approved: requests.filter(r => r.status === 'APPROVED').length,
    rejected: requests.filter(r => r.status === 'REJECTED').length
  }

  return {
    type: 'SCORE_REMOVAL_REQUESTS',
    stats,
    requests,
    generatedAt: new Date().toISOString(),
    generatedBy: 'BOARD'
  }
}

const generateEmceeScriptUsage = async (parameters) => {
  const { eventId, contestId, dateFrom, dateTo } = parameters

  const whereClause = {
    ...(eventId && { eventId }),
    ...(contestId && { contestId }),
    ...(dateFrom && dateTo && {
      createdAt: {
        gte: new Date(dateFrom),
        lte: new Date(dateTo)
      }
    })
  }

  const scripts = await prisma.emceeScript.findMany({
    where: whereClause,
    include: {
      event: true,
      contest: true,
      category: true
    },
    orderBy: { usageCount: 'desc' }
  })

  const stats = {
    totalScripts: scripts.length,
    activeScripts: scripts.filter(s => s.isActive).length,
    totalUsage: scripts.reduce((sum, s) => sum + s.usageCount, 0),
    averageUsage: scripts.length > 0 ? scripts.reduce((sum, s) => sum + s.usageCount, 0) / scripts.length : 0
  }

  return {
    type: 'EMCEE_SCRIPT_USAGE',
    stats,
    scripts,
    generatedAt: new Date().toISOString(),
    generatedBy: 'BOARD'
  }
}

const getScoreRemovalRequests = async (req, res) => {
  try {
    const { status, page = 1, limit = 20 } = req.query

    const whereClause = {
      ...(status && { status })
    }

    const requests = await prisma.judgeScoreRemovalRequest.findMany({
      where: whereClause,
      include: {
        judge: true,
        category: {
          include: {
            contest: {
              include: {
                event: true
              }
            }
          }
        },
        score: {
          include: {
            contestant: true
          }
        }
      },
      orderBy: { createdAt: 'desc' },
      skip: (parseInt(page) - 1) * parseInt(limit),
      take: parseInt(limit)
    })

    const total = await prisma.judgeScoreRemovalRequest.count({
      where: whereClause
    })

    res.json({
      requests,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / parseInt(limit))
      }
    })
  } catch (error) {
    console.error('Get score removal requests error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const approveScoreRemoval = async (req, res) => {
  try {
    const { id } = req.params
    const { reason } = req.body

    const request = await prisma.judgeScoreRemovalRequest.findUnique({
      where: { id },
      include: { score: true }
    })

    if (!request) {
      return res.status(404).json({ error: 'Request not found' })
    }

    // Delete the score
    await prisma.score.delete({
      where: { id: request.scoreId }
    })

    // Update the request status
    const updatedRequest = await prisma.judgeScoreRemovalRequest.update({
      where: { id },
      data: {
        status: 'APPROVED',
        approvedBy: req.user.id,
        approvedAt: new Date(),
        reason
      }
    })

    res.json(updatedRequest)
  } catch (error) {
    console.error('Approve score removal error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const rejectScoreRemoval = async (req, res) => {
  try {
    const { id } = req.params
    const { reason } = req.body

    const updatedRequest = await prisma.judgeScoreRemovalRequest.update({
      where: { id },
      data: {
        status: 'REJECTED',
        rejectedBy: req.user.id,
        rejectedAt: new Date(),
        reason
      }
    })

    res.json(updatedRequest)
  } catch (error) {
    console.error('Reject score removal error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  getStats,
  getCertifications,
  approveCertification,
  rejectCertification,
  getCertificationStatus,
  getEmceeScripts,
  createEmceeScript,
  updateEmceeScript,
  deleteEmceeScript,
  generateReport,
  getScoreRemovalRequests,
  approveScoreRemoval,
  rejectScoreRemoval
}
EOF

    # Tally Master Controller
    cat > "$APP_DIR/src/controllers/tallyMasterController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

const getStats = async (req, res) => {
  try {
    const stats = {
      totalCategories: await prisma.category.count(),
      pendingTotals: await prisma.category.count({
        where: { totalsCertified: false }
      }),
      certifiedTotals: await prisma.category.count({
        where: { totalsCertified: true }
      })
    }

    res.json(stats)
  } catch (error) {
    console.error('Get tally master stats error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getCertifications = async (req, res) => {
  try {
    const categories = await prisma.category.findMany({
      where: { totalsCertified: true },
      include: {
        contest: {
          include: {
            event: true
          }
        },
        scores: {
          include: {
            judge: true,
            contestant: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    })

    res.json(categories)
  } catch (error) {
    console.error('Get certifications error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getCertificationQueue = async (req, res) => {
  try {
    const categories = await prisma.category.findMany({
      where: { totalsCertified: false },
      include: {
        contest: {
          include: {
            event: true
          }
        },
        scores: {
          include: {
            judge: true,
            contestant: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    })

    res.json(categories)
  } catch (error) {
    console.error('Get certification queue error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getPendingCertifications = async (req, res) => {
  try {
    const categories = await prisma.category.findMany({
      where: { totalsCertified: false },
      include: {
        contest: {
          include: {
            event: true
          }
        },
        scores: {
          include: {
            judge: true,
            contestant: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    })

    res.json(categories)
  } catch (error) {
    console.error('Get pending certifications error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const certifyTotals = async (req, res) => {
  try {
    const { categoryId } = req.body

    const category = await prisma.category.update({
      where: { id: categoryId },
      data: { 
        totalsCertified: true,
        tallyMasterCertified: true
      }
    })

    res.json(category)
  } catch (error) {
    console.error('Certify totals error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get score review interface
const getScoreReview = async (req, res) => {
  try {
    const { categoryId } = req.params

    const category = await prisma.category.findUnique({
      where: { id: categoryId },
      include: {
        contest: {
          include: {
            event: true
          }
        },
        scores: {
          include: {
            judge: {
              select: {
                id: true,
                name: true,
                preferredName: true,
                email: true,
                role: true
              }
            },
            contestant: {
              select: {
                id: true,
                name: true,
                preferredName: true,
                email: true,
                contestantNumber: true
              }
            },
            criterion: {
              select: {
                id: true,
                name: true,
                description: true,
                maxScore: true,
                order: true
              }
            }
          },
          orderBy: [
            { contestant: { name: 'asc' } },
            { criterion: { order: 'asc' } }
          ]
        }
      }
    })

    if (!category) {
      return res.status(404).json({ error: 'Category not found' })
    }

    // Group scores by contestant for review
    const contestantScores = category.scores.reduce((acc, score) => {
      const key = score.contestantId
      if (!acc[key]) {
        acc[key] = {
          contestant: score.contestant,
          scores: [],
          totalScore: 0,
          averageScore: 0,
          scoreCount: 0
        }
      }
      acc[key].scores.push(score)
      acc[key].totalScore += score.score
      acc[key].scoreCount += 1
      return acc
    }, {})

    // Calculate averages
    Object.values(contestantScores).forEach(group => {
      group.averageScore = group.scoreCount > 0 ? group.totalScore / group.scoreCount : 0
    })

    // Sort by average score (descending)
    const sortedContestants = Object.values(contestantScores).sort((a, b) => b.averageScore - a.averageScore)

    res.json({
      category: {
        id: category.id,
        name: category.name,
        description: category.description,
        maxScore: category.maxScore
      },
      contest: {
        id: category.contest.id,
        name: category.contest.name,
        eventName: category.contest.event.name
      },
      contestants: sortedContestants,
      totalScores: category.scores.length,
      uniqueContestants: Object.keys(contestantScores).length
    })
  } catch (error) {
    console.error('Get score review error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get certification workflow
const getCertificationWorkflow = async (req, res) => {
  try {
    const { categoryId } = req.params

    const category = await prisma.category.findUnique({
      where: { id: categoryId },
      include: {
        contest: {
          include: {
            event: true
          }
        },
        scores: {
          include: {
            judge: {
              select: {
                id: true,
                name: true,
                preferredName: true,
                email: true
              }
            },
            contestant: {
              select: {
                id: true,
                name: true,
                preferredName: true,
                email: true,
                contestantNumber: true
              }
            },
            criterion: {
              select: {
                id: true,
                name: true,
                description: true,
                maxScore: true
              }
            }
          }
        }
      }
    })

    if (!category) {
      return res.status(404).json({ error: 'Category not found' })
    }

    // Calculate certification status
    const certificationStatus = {
      totalsCertified: category.totalsCertified,
      finalCertified: category.finalCertified,
      tallyMasterCertified: category.tallyMasterCertified,
      auditorCertified: category.auditorCertified,
      boardApproved: category.boardApproved,
      currentStep: 1,
      totalSteps: 4,
      canProceed: false,
      nextStep: null
    }

    // Determine current step and next action
    if (!category.totalsCertified) {
      certificationStatus.currentStep = 1
      certificationStatus.nextStep = 'CERTIFY_TOTALS'
      certificationStatus.canProceed = true
    } else if (!category.finalCertified) {
      certificationStatus.currentStep = 2
      certificationStatus.nextStep = 'AUDITOR_REVIEW'
      certificationStatus.canProceed = false
    } else if (!category.boardApproved) {
      certificationStatus.currentStep = 3
      certificationStatus.nextStep = 'BOARD_APPROVAL'
      certificationStatus.canProceed = false
    } else {
      certificationStatus.currentStep = 4
      certificationStatus.nextStep = 'COMPLETED'
      certificationStatus.canProceed = false
    }

    res.json({
      category: {
        id: category.id,
        name: category.name,
        description: category.description,
        maxScore: category.maxScore
      },
      contest: {
        id: category.contest.id,
        name: category.contest.name,
        eventName: category.contest.event.name
      },
      certificationStatus,
      totalScores: category.scores.length,
      uniqueContestants: new Set(category.scores.map(s => s.contestantId)).size
    })
  } catch (error) {
    console.error('Get certification workflow error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get bias checking tools
const getBiasCheckingTools = async (req, res) => {
  try {
    const { categoryId } = req.params

    const category = await prisma.category.findUnique({
      where: { id: categoryId },
      include: {
        scores: {
          include: {
            judge: {
              select: {
                id: true,
                name: true,
                preferredName: true,
                email: true,
                role: true
              }
            },
            contestant: {
              select: {
                id: true,
                name: true,
                preferredName: true,
                email: true,
                contestantNumber: true
              }
            },
            criterion: {
              select: {
                id: true,
                name: true,
                description: true,
                maxScore: true
              }
            }
          }
        }
      }
    })

    if (!category) {
      return res.status(404).json({ error: 'Category not found' })
    }

    // Analyze scores for potential bias
    const judgeScores = category.scores.reduce((acc, score) => {
      const key = score.judgeId
      if (!acc[key]) {
        acc[key] = {
          judge: score.judge,
          scores: [],
          totalScore: 0,
          averageScore: 0,
          scoreCount: 0
        }
      }
      acc[key].scores.push(score)
      acc[key].totalScore += score.score
      acc[key].scoreCount += 1
      return acc
    }, {})

    // Calculate judge averages
    Object.values(judgeScores).forEach(group => {
      group.averageScore = group.scoreCount > 0 ? group.totalScore / group.scoreCount : 0
    })

    // Calculate overall average
    const overallAverage = category.scores.length > 0 
      ? category.scores.reduce((sum, s) => sum + s.score, 0) / category.scores.length 
      : 0

    // Identify potential bias (judges with significantly different averages)
    const biasAnalysis = Object.values(judgeScores).map(judge => {
      const deviation = Math.abs(judge.averageScore - overallAverage)
      const deviationPercentage = overallAverage > 0 ? (deviation / overallAverage) * 100 : 0
      
      return {
        judge: judge.judge,
        averageScore: parseFloat(judge.averageScore.toFixed(2)),
        scoreCount: judge.scoreCount,
        deviation: parseFloat(deviation.toFixed(2)),
        deviationPercentage: parseFloat(deviationPercentage.toFixed(2)),
        potentialBias: deviationPercentage > 20 // Flag if deviation is more than 20%
      }
    }).sort((a, b) => b.deviationPercentage - a.deviationPercentage)

    res.json({
      category: {
        id: category.id,
        name: category.name,
        description: category.description,
        maxScore: category.maxScore
      },
      overallAverage: parseFloat(overallAverage.toFixed(2)),
      totalScores: category.scores.length,
      uniqueJudges: Object.keys(judgeScores).length,
      biasAnalysis,
      recommendations: biasAnalysis.filter(j => j.potentialBias).map(j => 
        `Judge ${j.judge.preferredName || j.judge.name} shows potential bias with ${j.deviationPercentage}% deviation from average`
      )
    })
  } catch (error) {
    console.error('Get bias checking tools error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get tally master history
const getTallyMasterHistory = async (req, res) => {
  try {
    const { page = 1, limit = 10 } = req.query
    const offset = (page - 1) * limit

    const categories = await prisma.category.findMany({
      where: { 
        tallyMasterCertified: true
      },
      include: {
        contest: {
          include: {
            event: true
          }
        }
      },
      orderBy: { updatedAt: 'desc' },
      skip: offset,
      take: parseInt(limit)
    })

    const total = await prisma.category.count({
      where: { 
        tallyMasterCertified: true
      }
    })

    res.json({
      categories,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / limit)
      }
    })
  } catch (error) {
    console.error('Get tally master history error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Score removal functionality
const requestScoreRemoval = async (req, res) => {
  try {
    const { categoryId, judgeId, reason } = req.body
    const requestedBy = req.user.id

    if (!categoryId || !judgeId || !reason) {
      return res.status(400).json({ error: 'Category ID, Judge ID, and reason are required' })
    }

    // Check if user has permission to request score removal
    if (req.user.role !== 'TALLY_MASTER' && req.user.role !== 'AUDITOR' && req.user.role !== 'BOARD') {
      return res.status(403).json({ error: 'Insufficient permissions to request score removal' })
    }

    // Create score removal request
    const scoreRemovalRequest = await prisma.scoreRemovalRequest.create({
      data: {
        categoryId,
        judgeId,
        reason,
        requestedBy,
        status: 'PENDING'
      },
      include: {
        category: {
          include: {
            contest: {
              include: {
                event: true
              }
            }
          }
        },
        judge: {
          include: {
            user: true
          }
        }
      }
    })

    res.json({
      message: 'Score removal request created successfully',
      request: scoreRemovalRequest
    })
  } catch (error) {
    console.error('Request score removal error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getScoreRemovalRequests = async (req, res) => {
  try {
    const requests = await prisma.scoreRemovalRequest.findMany({
      include: {
        category: {
          include: {
            contest: {
              include: {
                event: true
              }
            }
          }
        },
        judge: {
          include: {
            user: true
          }
        }
      },
      orderBy: {
        requestedAt: 'desc'
      }
    })

    res.json(requests)
  } catch (error) {
    console.error('Get score removal requests error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const approveScoreRemoval = async (req, res) => {
  try {
    const { requestId } = req.params
    const userId = req.user.id
    const userRole = req.user.role
    const { signature } = req.body

    if (!signature) {
      return res.status(400).json({ error: 'Signature is required' })
    }

    // Check if user has permission to approve
    if (!['TALLY_MASTER', 'AUDITOR', 'BOARD'].includes(userRole)) {
      return res.status(403).json({ error: 'Insufficient permissions to approve score removal' })
    }

    const request = await prisma.scoreRemovalRequest.findUnique({
      where: { id: requestId },
      include: {
        category: true,
        judge: {
          include: {
            user: true
          }
        }
      }
    })

    if (!request) {
      return res.status(404).json({ error: 'Score removal request not found' })
    }

    if (request.status !== 'PENDING') {
      return res.status(400).json({ error: 'Request is not pending' })
    }

    // Update the request with the signature
    let updateData = {}
    if (userRole === 'TALLY_MASTER') {
      updateData = {
        tallySignature: signature,
        tallySignedAt: new Date(),
        tallySignedBy: userId
      }
    } else if (userRole === 'AUDITOR') {
      updateData = {
        auditorSignature: signature,
        auditorSignedAt: new Date(),
        auditorSignedBy: userId
      }
    } else if (userRole === 'BOARD') {
      updateData = {
        boardSignature: signature,
        boardSignedAt: new Date(),
        boardSignedBy: userId
      }
    }

    const updatedRequest = await prisma.scoreRemovalRequest.update({
      where: { id: requestId },
      data: updateData,
      include: {
        category: {
          include: {
            contest: {
              include: {
                event: true
              }
            }
          }
        },
        judge: {
          include: {
            user: true
          }
        }
      }
    })

    // Check if all required signatures are present
    const hasTallySignature = !!updatedRequest.tallySignature
    const hasAuditorSignature = !!updatedRequest.auditorSignature
    const hasBoardSignature = !!updatedRequest.boardSignature

    if (hasTallySignature && hasAuditorSignature && hasBoardSignature) {
      // All signatures present, remove the scores
      await prisma.score.deleteMany({
        where: {
          categoryId: request.categoryId,
          judgeId: request.judgeId
        }
      })

      // Update request status to approved
      await prisma.scoreRemovalRequest.update({
        where: { id: requestId },
        data: { status: 'APPROVED' }
      })

      res.json({
        message: 'Score removal request approved and scores removed',
        request: updatedRequest
      })
    } else {
      res.json({
        message: 'Signature added, waiting for additional signatures',
        request: updatedRequest
      })
    }
  } catch (error) {
    console.error('Approve score removal error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const rejectScoreRemoval = async (req, res) => {
  try {
    const { requestId } = req.params
    const { reason } = req.body

    if (!reason) {
      return res.status(400).json({ error: 'Rejection reason is required' })
    }

    // Check if user has permission to reject
    if (!['BOARD', 'AUDITOR'].includes(req.user.role)) {
      return res.status(403).json({ error: 'Insufficient permissions to reject score removal' })
    }

    const request = await prisma.scoreRemovalRequest.update({
      where: { id: requestId },
      data: {
        status: 'REJECTED',
        rejectionReason: reason,
        rejectedAt: new Date(),
        rejectedBy: req.user.id
      },
      include: {
        category: {
          include: {
            contest: {
              include: {
                event: true
              }
            }
          }
        },
        judge: {
          include: {
            user: true
          }
        }
      }
    })

    res.json({
      message: 'Score removal request rejected',
      request
    })
  } catch (error) {
    console.error('Reject score removal error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  getStats,
  getCertifications,
  getCertificationQueue,
  getPendingCertifications,
  certifyTotals,
  getScoreReview,
  getCertificationWorkflow,
  getBiasCheckingTools,
  getTallyMasterHistory,
  requestScoreRemoval,
  getScoreRemovalRequests,
  approveScoreRemoval,
  rejectScoreRemoval
}
EOF

    # Judge Controller
    cat > "$APP_DIR/src/controllers/judgeController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

// Get judge dashboard stats
const getStats = async (req, res) => {
  try {
    const judgeId = req.user.id

    const totalAssignments = await prisma.assignment.count({
      where: { judgeId }
    })

    const pendingAssignments = await prisma.assignment.count({
      where: { 
        judgeId,
        status: 'PENDING'
      }
    })

    const activeAssignments = await prisma.assignment.count({
      where: { 
        judgeId,
        status: 'ACTIVE'
      }
    })

    const completedAssignments = await prisma.assignment.count({
      where: { 
        judgeId,
        status: 'COMPLETED'
      }
    })

    const totalScores = await prisma.score.count({
      where: { judgeId }
    })

    res.json({
      totalAssignments,
      pendingAssignments,
      activeAssignments,
      completedAssignments,
      totalScores
    })
  } catch (error) {
    console.error('Get judge stats error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get assignment management
const getAssignments = async (req, res) => {
  try {
    const judgeId = req.user.id

    const assignments = await prisma.assignment.findMany({
      where: { judgeId },
      include: {
        category: {
          include: {
            contest: {
              include: {
                event: true
              }
            }
          }
        }
      },
      orderBy: { assignedAt: 'desc' }
    })

    res.json(assignments)
  } catch (error) {
    console.error('Get assignments error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Update assignment status
const updateAssignmentStatus = async (req, res) => {
  try {
    const { assignmentId } = req.params
    const { status } = req.body
    const judgeId = req.user.id

    const assignment = await prisma.assignment.findFirst({
      where: { 
        id: assignmentId,
        judgeId
      }
    })

    if (!assignment) {
      return res.status(404).json({ error: 'Assignment not found' })
    }

    const updatedAssignment = await prisma.assignment.update({
      where: { id: assignmentId },
      data: { status },
      include: {
        category: {
          include: {
            contest: {
              include: {
                event: true
              }
            }
          }
        }
      }
    })

    res.json(updatedAssignment)
  } catch (error) {
    console.error('Update assignment status error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get scoring interface
const getScoringInterface = async (req, res) => {
  try {
    const { categoryId } = req.params
    const judgeId = req.user.id

    // Check if judge is assigned to this category
    const assignment = await prisma.assignment.findFirst({
      where: {
        judgeId,
        categoryId,
        status: { in: ['ACTIVE', 'COMPLETED'] }
      }
    })

    if (!assignment) {
      return res.status(403).json({ error: 'Not assigned to this category' })
    }

    const category = await prisma.category.findUnique({
      where: { id: categoryId },
      include: {
        contest: {
          include: {
            event: true
          }
        },
        criteria: {
          orderBy: { order: 'asc' }
        },
        contestants: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                preferredName: true,
                email: true
              }
            }
          }
        },
        scores: {
          where: { judgeId },
          include: {
            criterion: true,
            contestant: {
              include: {
                user: {
                  select: {
                    id: true,
                    name: true,
                    preferredName: true,
                    email: true
                  }
                }
              }
            }
          }
        }
      }
    })

    if (!category) {
      return res.status(404).json({ error: 'Category not found' })
    }

    res.json({
      category: {
        id: category.id,
        name: category.name,
        description: category.description,
        maxScore: category.maxScore
      },
      contest: {
        id: category.contest.id,
        name: category.contest.name,
        eventName: category.contest.event.name
      },
      criteria: category.criteria,
      contestants: category.contestants,
      scores: category.scores,
      assignment: {
        id: assignment.id,
        status: assignment.status,
        assignedAt: assignment.assignedAt
      }
    })
  } catch (error) {
    console.error('Get scoring interface error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Submit score
const submitScore = async (req, res) => {
  try {
    const { categoryId, contestantId, criterionId, score } = req.body
    const judgeId = req.user.id

    // Check if judge is assigned to this category
    const assignment = await prisma.assignment.findFirst({
      where: {
        judgeId,
        categoryId,
        status: { in: ['ACTIVE', 'COMPLETED'] }
      }
    })

    if (!assignment) {
      return res.status(403).json({ error: 'Not assigned to this category' })
    }

    // Validate score
    const criterion = await prisma.criterion.findUnique({
      where: { id: criterionId }
    })

    if (!criterion) {
      return res.status(404).json({ error: 'Criterion not found' })
    }

    if (score < 0 || score > criterion.maxScore) {
      return res.status(400).json({ error: `Score must be between 0 and ${criterion.maxScore}` })
    }

    // Upsert score
    const scoreRecord = await prisma.score.upsert({
      where: {
        judgeId_categoryId_contestantId_criterionId: {
          judgeId,
          categoryId,
          contestantId,
          criterionId
        }
      },
      update: { score },
      create: {
        judgeId,
        categoryId,
        contestantId,
        criterionId,
        score
      },
      include: {
        criterion: true,
        contestant: {
          include: {
            user: {
              select: {
                id: true,
                name: true,
                preferredName: true,
                email: true
              }
            }
          }
        }
      }
    })

    res.json(scoreRecord)
  } catch (error) {
    console.error('Submit score error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get certification workflow
const getCertificationWorkflow = async (req, res) => {
  try {
    const { categoryId } = req.params
    const judgeId = req.user.id

    // Check if judge is assigned to this category
    const assignment = await prisma.assignment.findFirst({
      where: {
        judgeId,
        categoryId,
        status: { in: ['ACTIVE', 'COMPLETED'] }
      }
    })

    if (!assignment) {
      return res.status(403).json({ error: 'Not assigned to this category' })
    }

    const category = await prisma.category.findUnique({
      where: { id: categoryId },
      include: {
        contest: {
          include: {
            event: true
          }
        },
        scores: {
          where: { judgeId },
          include: {
            criterion: true,
            contestant: {
              include: {
                user: {
                  select: {
                    id: true,
                    name: true,
                    preferredName: true,
                    email: true
                  }
                }
              }
            }
          }
        }
      }
    })

    if (!category) {
      return res.status(404).json({ error: 'Category not found' })
    }

    // Calculate certification status
    const certificationStatus = {
      totalsCertified: category.totalsCertified,
      finalCertified: category.finalCertified,
      tallyMasterCertified: category.tallyMasterCertified,
      auditorCertified: category.auditorCertified,
      boardApproved: category.boardApproved,
      currentStep: 1,
      totalSteps: 4,
      canProceed: false,
      nextStep: null
    }

    // Determine current step and next action
    if (!category.totalsCertified) {
      certificationStatus.currentStep = 1
      certificationStatus.nextStep = 'TALLY_MASTER_REVIEW'
      certificationStatus.canProceed = false
    } else if (!category.finalCertified) {
      certificationStatus.currentStep = 2
      certificationStatus.nextStep = 'AUDITOR_REVIEW'
      certificationStatus.canProceed = false
    } else if (!category.boardApproved) {
      certificationStatus.currentStep = 3
      certificationStatus.nextStep = 'BOARD_APPROVAL'
      certificationStatus.canProceed = false
    } else {
      certificationStatus.currentStep = 4
      certificationStatus.nextStep = 'COMPLETED'
      certificationStatus.canProceed = false
    }

    res.json({
      category: {
        id: category.id,
        name: category.name,
        description: category.description,
        maxScore: category.maxScore
      },
      contest: {
        id: category.contest.id,
        name: category.contest.name,
        eventName: category.contest.event.name
      },
      certificationStatus,
      scores: category.scores,
      totalScores: category.scores.length,
      assignment: {
        id: assignment.id,
        status: assignment.status,
        assignedAt: assignment.assignedAt
      }
    })
  } catch (error) {
    console.error('Get certification workflow error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get contestant bios
const getContestantBios = async (req, res) => {
  try {
    const { categoryId } = req.params
    const judgeId = req.user.id

    // Check if judge is assigned to this category
    const assignment = await prisma.assignment.findFirst({
      where: {
        judgeId,
        categoryId,
        status: { in: ['ACTIVE', 'COMPLETED'] }
      }
    })

    if (!assignment) {
      return res.status(403).json({ error: 'Not assigned to this category' })
    }

    const contestants = await prisma.contestant.findMany({
      where: {
        categories: {
          some: {
            id: categoryId
          }
        }
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true,
            pronouns: true
          }
        }
      },
      orderBy: { name: 'asc' }
    })

    res.json(contestants)
  } catch (error) {
    console.error('Get contestant bios error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get judge history
const getJudgeHistory = async (req, res) => {
  try {
    const judgeId = req.user.id
    const { page = 1, limit = 10 } = req.query
    const offset = (page - 1) * limit

    const assignments = await prisma.assignment.findMany({
      where: { judgeId },
      include: {
        category: {
          include: {
            contest: {
              include: {
                event: true
              }
            }
          }
        }
      },
      orderBy: { assignedAt: 'desc' },
      skip: offset,
      take: parseInt(limit)
    })

    const total = await prisma.assignment.count({
      where: { judgeId }
    })

    res.json({
      assignments,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / limit)
      }
    })
  } catch (error) {
    console.error('Get judge history error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  getStats,
  getAssignments,
  updateAssignmentStatus,
  getScoringInterface,
  submitScore,
  getCertificationWorkflow,
  getContestantBios,
  getJudgeHistory
}
EOF

    # Judge Routes
    cat > "$APP_DIR/src/routes/judgeRoutes.js" << 'EOF'
const express = require('express')
const { 
  getStats,
  getAssignments,
  updateAssignmentStatus,
  getScoringInterface,
  submitScore,
  getCertificationWorkflow,
  getContestantBios,
  getJudgeHistory
} = require('../controllers/judgeController')
const { authenticateToken, requireRole } = require('../middleware/auth')
const { logActivity } = require('../middleware/errorHandler')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)
router.use(requireRole(['JUDGE', 'ORGANIZER', 'BOARD']))

// Judge dashboard endpoints
router.get('/stats', getStats)
router.get('/assignments', getAssignments)
router.get('/history', getJudgeHistory)

// Assignment management
router.put('/assignments/:assignmentId/status', logActivity('UPDATE_ASSIGNMENT_STATUS', 'ASSIGNMENT'), updateAssignmentStatus)

// Scoring interface
router.get('/scoring/:categoryId', getScoringInterface)
router.post('/scoring/submit', logActivity('SUBMIT_SCORE', 'SCORE'), submitScore)

// Certification workflow
router.get('/certification-workflow/:categoryId', getCertificationWorkflow)

// Contestant bios
router.get('/contestant-bios/:categoryId', getContestantBios)

module.exports = router
EOF

    # Role-Based Navigation Middleware
    cat > "$APP_DIR/src/middleware/navigation.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

// Define navigation structure based on roles
const getNavigationItems = (userRole) => {
  const baseItems = [
    {
      id: 'dashboard',
      label: 'Dashboard',
      path: '/dashboard',
      icon: 'HomeIcon',
      roles: ['ORGANIZER', 'BOARD', 'JUDGE', 'TALLY_MASTER', 'AUDITOR', 'EMCEE', 'CONTESTANT']
    },
    {
      id: 'profile',
      label: 'Profile',
      path: '/profile',
      icon: 'UserIcon',
      roles: ['ORGANIZER', 'BOARD', 'JUDGE', 'TALLY_MASTER', 'AUDITOR', 'EMCEE', 'CONTESTANT']
    }
  ]

  const roleSpecificItems = {
    ORGANIZER: [
      {
        id: 'events',
        label: 'Events',
        path: '/events',
        icon: 'CalendarIcon',
        roles: ['ORGANIZER', 'BOARD']
      },
      {
        id: 'contests',
        label: 'Contests',
        path: '/contests',
        icon: 'TrophyIcon',
        roles: ['ORGANIZER', 'BOARD']
      },
      {
        id: 'categories',
        label: 'Categories',
        path: '/categories',
        icon: 'TagIcon',
        roles: ['ORGANIZER', 'BOARD']
      },
      {
        id: 'users',
        label: 'Users',
        path: '/users',
        icon: 'UsersIcon',
        roles: ['ORGANIZER', 'BOARD']
      },
      {
        id: 'assignments',
        label: 'Assignments',
        path: '/assignments',
        icon: 'ClipboardDocumentListIcon',
        roles: ['ORGANIZER', 'BOARD']
      },
      {
        id: 'certifications',
        label: 'Certifications',
        path: '/certifications',
        icon: 'ShieldCheckIcon',
        roles: ['ORGANIZER', 'BOARD']
      },
      {
        id: 'admin',
        label: 'Admin',
        path: '/admin',
        icon: 'CogIcon',
        roles: ['ORGANIZER', 'BOARD']
      },
      {
        id: 'settings',
        label: 'Settings',
        path: '/settings',
        icon: 'Cog6ToothIcon',
        roles: ['ORGANIZER', 'BOARD']
      }
    ],
    BOARD: [
      {
        id: 'board',
        label: 'Board Dashboard',
        path: '/board',
        icon: 'BuildingOfficeIcon',
        roles: ['BOARD', 'ORGANIZER']
      },
      {
        id: 'emcee-scripts',
        label: 'Emcee Scripts',
        path: '/emcee-scripts',
        icon: 'DocumentTextIcon',
        roles: ['BOARD', 'ORGANIZER']
      },
      {
        id: 'reports',
        label: 'Reports',
        path: '/reports',
        icon: 'ChartBarIcon',
        roles: ['BOARD', 'ORGANIZER']
      },
      {
        id: 'score-removal',
        label: 'Score Removal',
        path: '/score-removal',
        icon: 'ExclamationTriangleIcon',
        roles: ['BOARD', 'ORGANIZER']
      }
    ],
    AUDITOR: [
      {
        id: 'auditor',
        label: 'Auditor Dashboard',
        path: '/auditor',
        icon: 'MagnifyingGlassIcon',
        roles: ['AUDITOR', 'ORGANIZER', 'BOARD']
      },
      {
        id: 'score-verification',
        label: 'Score Verification',
        path: '/score-verification',
        icon: 'CheckCircleIcon',
        roles: ['AUDITOR', 'ORGANIZER', 'BOARD']
      },
      {
        id: 'tally-status',
        label: 'Tally Status',
        path: '/tally-status',
        icon: 'CalculatorIcon',
        roles: ['AUDITOR', 'ORGANIZER', 'BOARD']
      },
      {
        id: 'final-certification',
        label: 'Final Certification',
        path: '/final-certification',
        icon: 'ShieldCheckIcon',
        roles: ['AUDITOR', 'ORGANIZER', 'BOARD']
      }
    ],
    TALLY_MASTER: [
      {
        id: 'tally-master',
        label: 'Tally Master Dashboard',
        path: '/tally-master',
        icon: 'CalculatorIcon',
        roles: ['TALLY_MASTER', 'ORGANIZER', 'BOARD']
      },
      {
        id: 'score-review',
        label: 'Score Review',
        path: '/score-review',
        icon: 'EyeIcon',
        roles: ['TALLY_MASTER', 'ORGANIZER', 'BOARD']
      },
      {
        id: 'bias-checking',
        label: 'Bias Checking',
        path: '/bias-checking',
        icon: 'ExclamationTriangleIcon',
        roles: ['TALLY_MASTER', 'ORGANIZER', 'BOARD']
      },
      {
        id: 'certification-workflow',
        label: 'Certification Workflow',
        path: '/certification-workflow',
        icon: 'ClipboardDocumentCheckIcon',
        roles: ['TALLY_MASTER', 'ORGANIZER', 'BOARD']
      }
    ],
    JUDGE: [
      {
        id: 'judge',
        label: 'Judge Dashboard',
        path: '/judge',
        icon: 'ScaleIcon',
        roles: ['JUDGE', 'ORGANIZER', 'BOARD']
      },
      {
        id: 'my-assignments',
        label: 'My Assignments',
        path: '/my-assignments',
        icon: 'ClipboardDocumentListIcon',
        roles: ['JUDGE', 'ORGANIZER', 'BOARD']
      },
      {
        id: 'scoring',
        label: 'Scoring',
        path: '/scoring',
        icon: 'PencilIcon',
        roles: ['JUDGE', 'ORGANIZER', 'BOARD']
      },
      {
        id: 'contestant-bios',
        label: 'Contestant Bios',
        path: '/contestant-bios',
        icon: 'UserGroupIcon',
        roles: ['JUDGE', 'ORGANIZER', 'BOARD']
      }
    ],
    EMCEE: [
      {
        id: 'emcee',
        label: 'Emcee Dashboard',
        path: '/emcee',
        icon: 'MicrophoneIcon',
        roles: ['EMCEE', 'ORGANIZER', 'BOARD']
      },
      {
        id: 'scripts',
        label: 'Scripts',
        path: '/scripts',
        icon: 'DocumentTextIcon',
        roles: ['EMCEE', 'ORGANIZER', 'BOARD']
      },
      {
        id: 'contestant-bios',
        label: 'Contestant Bios',
        path: '/contestant-bios',
        icon: 'UserGroupIcon',
        roles: ['EMCEE', 'ORGANIZER', 'BOARD']
      },
      {
        id: 'judge-bios',
        label: 'Judge Bios',
        path: '/judge-bios',
        icon: 'UsersIcon',
        roles: ['EMCEE', 'ORGANIZER', 'BOARD']
      },
      {
        id: 'event-management',
        label: 'Event Management',
        path: '/event-management',
        icon: 'CalendarIcon',
        roles: ['EMCEE', 'ORGANIZER', 'BOARD']
      }
    ],
    CONTESTANT: [
      {
        id: 'results',
        label: 'Results',
        path: '/results',
        icon: 'TrophyIcon',
        roles: ['CONTESTANT', 'ORGANIZER', 'BOARD']
      },
      {
        id: 'my-scores',
        label: 'My Scores',
        path: '/my-scores',
        icon: 'ChartBarIcon',
        roles: ['CONTESTANT', 'ORGANIZER', 'BOARD']
      }
    ]
  }

  // Combine base items with role-specific items
  const allItems = [...baseItems]
  
  if (roleSpecificItems[userRole]) {
    allItems.push(...roleSpecificItems[userRole])
  }

  // Filter items based on user role
  return allItems.filter(item => 
    item.roles.includes(userRole) || 
    item.roles.includes('ORGANIZER') || 
    item.roles.includes('BOARD')
  )
}

// Get navigation permissions for a specific route
const getRoutePermissions = (route, userRole) => {
  const navigationItems = getNavigationItems(userRole)
  const item = navigationItems.find(nav => nav.path === route)
  
  if (!item) {
    return {
      allowed: false,
      reason: 'Route not found in navigation'
    }
  }

  return {
    allowed: item.roles.includes(userRole),
    reason: item.roles.includes(userRole) ? 'Access granted' : 'Insufficient permissions'
  }
}

// Check if user can access a specific feature
const canAccessFeature = (feature, userRole) => {
  const featurePermissions = {
    'CREATE_EVENT': ['ORGANIZER', 'BOARD'],
    'EDIT_EVENT': ['ORGANIZER', 'BOARD'],
    'DELETE_EVENT': ['ORGANIZER', 'BOARD'],
    'CREATE_CONTEST': ['ORGANIZER', 'BOARD'],
    'EDIT_CONTEST': ['ORGANIZER', 'BOARD'],
    'DELETE_CONTEST': ['ORGANIZER', 'BOARD'],
    'CREATE_CATEGORY': ['ORGANIZER', 'BOARD'],
    'EDIT_CATEGORY': ['ORGANIZER', 'BOARD'],
    'DELETE_CATEGORY': ['ORGANIZER', 'BOARD'],
    'MANAGE_USERS': ['ORGANIZER', 'BOARD'],
    'ASSIGN_JUDGES': ['ORGANIZER', 'BOARD'],
    'VIEW_ALL_SCORES': ['ORGANIZER', 'BOARD', 'AUDITOR', 'TALLY_MASTER'],
    'EDIT_SCORES': ['JUDGE', 'ORGANIZER', 'BOARD'],
    'CERTIFY_SCORES': ['TALLY_MASTER', 'ORGANIZER', 'BOARD'],
    'AUDIT_SCORES': ['AUDITOR', 'ORGANIZER', 'BOARD'],
    'BOARD_APPROVAL': ['BOARD', 'ORGANIZER'],
    'MANAGE_SCRIPTS': ['EMCEE', 'ORGANIZER', 'BOARD'],
    'VIEW_CONTESTANT_BIOS': ['JUDGE', 'EMCEE', 'ORGANIZER', 'BOARD'],
    'VIEW_JUDGE_BIOS': ['EMCEE', 'ORGANIZER', 'BOARD'],
    'GENERATE_REPORTS': ['ORGANIZER', 'BOARD', 'AUDITOR'],
    'MANAGE_SETTINGS': ['ORGANIZER', 'BOARD'],
    'VIEW_ADMIN': ['ORGANIZER', 'BOARD'],
    'MANAGE_FILES': ['ORGANIZER', 'BOARD'],
    'VIEW_PERFORMANCE': ['ORGANIZER', 'BOARD']
  }

  const allowedRoles = featurePermissions[feature] || []
  return allowedRoles.includes(userRole)
}

// Get user's accessible features
const getUserFeatures = (userRole) => {
  const allFeatures = [
    'CREATE_EVENT', 'EDIT_EVENT', 'DELETE_EVENT',
    'CREATE_CONTEST', 'EDIT_CONTEST', 'DELETE_CONTEST',
    'CREATE_CATEGORY', 'EDIT_CATEGORY', 'DELETE_CATEGORY',
    'MANAGE_USERS', 'ASSIGN_JUDGES', 'VIEW_ALL_SCORES',
    'EDIT_SCORES', 'CERTIFY_SCORES', 'AUDIT_SCORES',
    'BOARD_APPROVAL', 'MANAGE_SCRIPTS', 'VIEW_CONTESTANT_BIOS',
    'VIEW_JUDGE_BIOS', 'GENERATE_REPORTS', 'MANAGE_SETTINGS',
    'VIEW_ADMIN', 'MANAGE_FILES', 'VIEW_PERFORMANCE'
  ]

  return allFeatures.filter(feature => canAccessFeature(feature, userRole))
}

// Middleware to check navigation permissions
const checkNavigationPermission = (req, res, next) => {
  try {
    const userRole = req.user?.role
    const requestedPath = req.path

    if (!userRole) {
      return res.status(401).json({ error: 'User not authenticated' })
    }

    const permissions = getRoutePermissions(requestedPath, userRole)
    
    if (!permissions.allowed) {
      return res.status(403).json({ 
        error: 'Access denied', 
        reason: permissions.reason 
      })
    }

    next()
  } catch (error) {
    console.error('Navigation permission check error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get navigation data for frontend
const getNavigationData = async (req, res) => {
  try {
    const userRole = req.user?.role

    if (!userRole) {
      return res.status(401).json({ error: 'User not authenticated' })
    }

    const navigationItems = getNavigationItems(userRole)
    const userFeatures = getUserFeatures(userRole)

    res.json({
      navigation: navigationItems,
      features: userFeatures,
      role: userRole
    })
  } catch (error) {
    console.error('Get navigation data error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  getNavigationItems,
  getRoutePermissions,
  canAccessFeature,
  getUserFeatures,
  checkNavigationPermission,
  getNavigationData
}
EOF

    # Navigation Routes
    cat > "$APP_DIR/src/routes/navigationRoutes.js" << 'EOF'
const express = require('express')
const { getNavigationData } = require('../middleware/navigation')
const { authenticateToken } = require('../middleware/auth')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)

// Get navigation data for the authenticated user
router.get('/', getNavigationData)

module.exports = router
EOF

    # File Access Control Middleware
    cat > "$APP_DIR/src/middleware/fileAccessControl.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

// File access control middleware
const checkFileAccess = (requiredPermission = 'READ') => {
  return async (req, res, next) => {
    try {
      const { fileId } = req.params
      const userId = req.user.id
      const userRole = req.user.role

      if (!fileId) {
        return res.status(400).json({ error: 'File ID is required' })
      }

      // Get file information
      const file = await prisma.file.findUnique({
        where: { id: fileId },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              preferredName: true,
              email: true,
              role: true
            }
          }
        }
      })

      if (!file) {
        return res.status(404).json({ error: 'File not found' })
      }

      // Check access permissions based on role and file ownership
      const hasAccess = await checkFilePermission(file, userId, userRole, requiredPermission)

      if (!hasAccess.allowed) {
        return res.status(403).json({ 
          error: 'Access denied', 
          reason: hasAccess.reason 
        })
      }

      // Add file information to request for use in controllers
      req.fileInfo = file
      next()
    } catch (error) {
      console.error('File access control error:', error)
      res.status(500).json({ error: 'Internal server error' })
    }
  }
}

// Check file permission based on role and ownership
const checkFilePermission = async (file, userId, userRole, permission) => {
  // Admin roles have full access
  if (['ORGANIZER', 'BOARD'].includes(userRole)) {
    return { allowed: true, reason: 'Admin access granted' }
  }

  // File owner has full access
  if (file.uploadedBy === userId) {
    return { allowed: true, reason: 'File owner access granted' }
  }

  // Public files can be read by anyone
  if (file.isPublic && permission === 'READ') {
    return { allowed: true, reason: 'Public file access granted' }
  }

  // Check role-based permissions
  const rolePermissions = await getRoleFilePermissions(userRole, file.category)
  
  if (rolePermissions.includes(permission)) {
    return { allowed: true, reason: 'Role-based access granted' }
  }

  return { allowed: false, reason: 'Insufficient permissions' }
}

// Get file permissions for a specific role and file category
const getRoleFilePermissions = async (userRole, fileCategory) => {
  const permissions = {
    ORGANIZER: ['READ', 'WRITE', 'DELETE', 'ADMIN'],
    BOARD: ['READ', 'WRITE', 'DELETE', 'ADMIN'],
    AUDITOR: ['READ'],
    TALLY_MASTER: ['READ'],
    JUDGE: ['READ'],
    EMCEE: ['READ'],
    CONTESTANT: ['READ']
  }

  // Additional category-specific permissions
  const categoryPermissions = {
    CONTESTANT_IMAGE: {
      JUDGE: ['READ'],
      EMCEE: ['READ'],
      AUDITOR: ['READ'],
      TALLY_MASTER: ['READ']
    },
    JUDGE_IMAGE: {
      EMCEE: ['READ'],
      AUDITOR: ['READ'],
      TALLY_MASTER: ['READ']
    },
    DOCUMENT: {
      AUDITOR: ['READ'],
      TALLY_MASTER: ['READ'],
      JUDGE: ['READ']
    },
    TEMPLATE: {
      EMCEE: ['READ'],
      AUDITOR: ['READ'],
      TALLY_MASTER: ['READ']
    },
    REPORT: {
      AUDITOR: ['READ'],
      TALLY_MASTER: ['READ'],
      BOARD: ['READ', 'WRITE', 'DELETE']
    }
  }

  const basePermissions = permissions[userRole] || []
  const categorySpecificPermissions = categoryPermissions[fileCategory]?.[userRole] || []

  return [...new Set([...basePermissions, ...categorySpecificPermissions])]
}

// Check if user can upload files of a specific category
const checkUploadPermission = async (req, res, next) => {
  try {
    const { category } = req.body
    const userRole = req.user.role

    const uploadPermissions = {
      ORGANIZER: ['CONTESTANT_IMAGE', 'JUDGE_IMAGE', 'DOCUMENT', 'TEMPLATE', 'REPORT', 'BACKUP', 'OTHER'],
      BOARD: ['CONTESTANT_IMAGE', 'JUDGE_IMAGE', 'DOCUMENT', 'TEMPLATE', 'REPORT', 'BACKUP', 'OTHER'],
      AUDITOR: ['DOCUMENT', 'REPORT', 'OTHER'],
      TALLY_MASTER: ['DOCUMENT', 'REPORT', 'OTHER'],
      JUDGE: ['DOCUMENT', 'OTHER'],
      EMCEE: ['TEMPLATE', 'OTHER'],
      CONTESTANT: ['OTHER']
    }

    const allowedCategories = uploadPermissions[userRole] || []
    
    if (!allowedCategories.includes(category)) {
      return res.status(403).json({ 
        error: 'Upload denied', 
        reason: `You are not allowed to upload files of category: ${category}` 
      })
    }

    next()
  } catch (error) {
    console.error('Upload permission check error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Check file sharing permissions
const checkSharingPermission = async (req, res, next) => {
  try {
    const { fileId } = req.params
    const { isPublic } = req.body
    const userId = req.user.id
    const userRole = req.user.role

    const file = await prisma.file.findUnique({
      where: { id: fileId }
    })

    if (!file) {
      return res.status(404).json({ error: 'File not found' })
    }

    // Only file owner or admin can change sharing settings
    if (file.uploadedBy !== userId && !['ORGANIZER', 'BOARD'].includes(userRole)) {
      return res.status(403).json({ error: 'Access denied' })
    }

    // Check if user has permission to make files public
    if (isPublic && !['ORGANIZER', 'BOARD'].includes(userRole)) {
      return res.status(403).json({ 
        error: 'Permission denied', 
        reason: 'Only administrators can make files public' 
      })
    }

    next()
  } catch (error) {
    console.error('Sharing permission check error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get user's file access summary
const getUserFileAccess = async (req, res) => {
  try {
    const userId = req.user.id
    const userRole = req.user.role

    const accessSummary = {
      canUpload: await getUploadableCategories(userRole),
      canView: await getViewableCategories(userRole),
      canManage: await getManageableCategories(userRole),
      totalFiles: await prisma.file.count({
        where: {
          OR: [
            { uploadedBy: userId },
            { isPublic: true }
          ]
        }
      }),
      ownedFiles: await prisma.file.count({
        where: { uploadedBy: userId }
      })
    }

    res.json(accessSummary)
  } catch (error) {
    console.error('Get user file access error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Helper functions
const getUploadableCategories = async (userRole) => {
  const uploadPermissions = {
    ORGANIZER: ['CONTESTANT_IMAGE', 'JUDGE_IMAGE', 'DOCUMENT', 'TEMPLATE', 'REPORT', 'BACKUP', 'OTHER'],
    BOARD: ['CONTESTANT_IMAGE', 'JUDGE_IMAGE', 'DOCUMENT', 'TEMPLATE', 'REPORT', 'BACKUP', 'OTHER'],
    AUDITOR: ['DOCUMENT', 'REPORT', 'OTHER'],
    TALLY_MASTER: ['DOCUMENT', 'REPORT', 'OTHER'],
    JUDGE: ['DOCUMENT', 'OTHER'],
    EMCEE: ['TEMPLATE', 'OTHER'],
    CONTESTANT: ['OTHER']
  }

  return uploadPermissions[userRole] || []
}

const getViewableCategories = async (userRole) => {
  const viewPermissions = {
    ORGANIZER: ['CONTESTANT_IMAGE', 'JUDGE_IMAGE', 'DOCUMENT', 'TEMPLATE', 'REPORT', 'BACKUP', 'OTHER'],
    BOARD: ['CONTESTANT_IMAGE', 'JUDGE_IMAGE', 'DOCUMENT', 'TEMPLATE', 'REPORT', 'BACKUP', 'OTHER'],
    AUDITOR: ['CONTESTANT_IMAGE', 'JUDGE_IMAGE', 'DOCUMENT', 'TEMPLATE', 'REPORT', 'OTHER'],
    TALLY_MASTER: ['CONTESTANT_IMAGE', 'JUDGE_IMAGE', 'DOCUMENT', 'TEMPLATE', 'REPORT', 'OTHER'],
    JUDGE: ['CONTESTANT_IMAGE', 'DOCUMENT', 'OTHER'],
    EMCEE: ['CONTESTANT_IMAGE', 'JUDGE_IMAGE', 'TEMPLATE', 'OTHER'],
    CONTESTANT: ['OTHER']
  }

  return viewPermissions[userRole] || []
}

const getManageableCategories = async (userRole) => {
  const managePermissions = {
    ORGANIZER: ['CONTESTANT_IMAGE', 'JUDGE_IMAGE', 'DOCUMENT', 'TEMPLATE', 'REPORT', 'BACKUP', 'OTHER'],
    BOARD: ['CONTESTANT_IMAGE', 'JUDGE_IMAGE', 'DOCUMENT', 'TEMPLATE', 'REPORT', 'BACKUP', 'OTHER'],
    AUDITOR: ['DOCUMENT', 'REPORT'],
    TALLY_MASTER: ['DOCUMENT', 'REPORT'],
    JUDGE: ['DOCUMENT'],
    EMCEE: ['TEMPLATE'],
    CONTESTANT: []
  }

  return managePermissions[userRole] || []
}

module.exports = {
  checkFileAccess,
  checkFilePermission,
  getRoleFilePermissions,
  checkUploadPermission,
  checkSharingPermission,
  getUserFileAccess
}
EOF

    # File Encryption Middleware
    cat > "$APP_DIR/src/middleware/fileEncryption.js" << 'EOF'
const crypto = require('crypto')
const fs = require('fs').promises
const path = require('path')

// Encryption configuration
const ENCRYPTION_ALGORITHM = 'aes-256-gcm'
const KEY_LENGTH = 32 // 256 bits
const IV_LENGTH = 16 // 128 bits
const TAG_LENGTH = 16 // 128 bits

// Generate encryption key from password
const generateKey = (password, salt) => {
  return crypto.pbkdf2Sync(password, salt, 100000, KEY_LENGTH, 'sha512')
}

// Generate random salt
const generateSalt = () => {
  return crypto.randomBytes(16)
}

// Encrypt file content
const encryptFile = async (filePath, password) => {
  try {
    // Read file content
    const fileContent = await fs.readFile(filePath)
    
    // Generate salt and key
    const salt = generateSalt()
    const key = generateKey(password, salt)
    
    // Generate random IV
    const iv = crypto.randomBytes(IV_LENGTH)
    
    // Create cipher
    const cipher = crypto.createCipher(ENCRYPTION_ALGORITHM, key)
    cipher.setAAD(salt)
    
    // Encrypt content
    let encrypted = cipher.update(fileContent)
    encrypted = Buffer.concat([encrypted, cipher.final()])
    
    // Get authentication tag
    const tag = cipher.getAuthTag()
    
    // Combine salt + iv + tag + encrypted content
    const encryptedData = Buffer.concat([salt, iv, tag, encrypted])
    
    return encryptedData
  } catch (error) {
    console.error('File encryption error:', error)
    throw new Error('Failed to encrypt file')
  }
}

// Decrypt file content
const decryptFile = async (encryptedData, password) => {
  try {
    // Extract components
    const salt = encryptedData.slice(0, 16)
    const iv = encryptedData.slice(16, 32)
    const tag = encryptedData.slice(32, 48)
    const encrypted = encryptedData.slice(48)
    
    // Generate key
    const key = generateKey(password, salt)
    
    // Create decipher
    const decipher = crypto.createDecipher(ENCRYPTION_ALGORITHM, key)
    decipher.setAAD(salt)
    decipher.setAuthTag(tag)
    
    // Decrypt content
    let decrypted = decipher.update(encrypted)
    decrypted = Buffer.concat([decrypted, decipher.final()])
    
    return decrypted
  } catch (error) {
    console.error('File decryption error:', error)
    throw new Error('Failed to decrypt file')
  }
}

// Encrypt file and save to secure location
const encryptAndStoreFile = async (originalPath, encryptedPath, password) => {
  try {
    // Encrypt file
    const encryptedData = await encryptFile(originalPath, password)
    
    // Create secure directory if it doesn't exist
    const secureDir = path.dirname(encryptedPath)
    await fs.mkdir(secureDir, { recursive: true, mode: 0o700 })
    
    // Write encrypted file
    await fs.writeFile(encryptedPath, encryptedData, { mode: 0o600 })
    
    // Remove original file
    await fs.unlink(originalPath)
    
    return {
      success: true,
      encryptedPath,
      originalSize: (await fs.stat(originalPath)).size,
      encryptedSize: encryptedData.length
    }
  } catch (error) {
    console.error('Encrypt and store error:', error)
    throw new Error('Failed to encrypt and store file')
  }
}

// Decrypt file from secure location
const decryptAndRetrieveFile = async (encryptedPath, outputPath, password) => {
  try {
    // Read encrypted file
    const encryptedData = await fs.readFile(encryptedPath)
    
    // Decrypt content
    const decryptedData = await decryptFile(encryptedData, password)
    
    // Create output directory if it doesn't exist
    const outputDir = path.dirname(outputPath)
    await fs.mkdir(outputDir, { recursive: true, mode: 0o755 })
    
    // Write decrypted file
    await fs.writeFile(outputPath, decryptedData, { mode: 0o644 })
    
    return {
      success: true,
      outputPath,
      size: decryptedData.length
    }
  } catch (error) {
    console.error('Decrypt and retrieve error:', error)
    throw new Error('Failed to decrypt and retrieve file')
  }
}

// Generate secure password for file encryption
const generateSecurePassword = () => {
  return crypto.randomBytes(32).toString('hex')
}

// Hash password for storage
const hashPassword = (password, salt) => {
  return crypto.pbkdf2Sync(password, salt, 100000, 64, 'sha512').toString('hex')
}

// Verify password hash
const verifyPassword = (password, hash, salt) => {
  const hashedPassword = crypto.pbkdf2Sync(password, salt, 100000, 64, 'sha512').toString('hex')
  return hashedPassword === hash
}

// Secure file metadata encryption
const encryptMetadata = (metadata, password) => {
  try {
    const salt = generateSalt()
    const key = generateKey(password, salt)
    const iv = crypto.randomBytes(IV_LENGTH)
    
    const cipher = crypto.createCipher(ENCRYPTION_ALGORITHM, key)
    cipher.setAAD(salt)
    
    const metadataString = JSON.stringify(metadata)
    let encrypted = cipher.update(metadataString, 'utf8')
    encrypted = Buffer.concat([encrypted, cipher.final()])
    
    const tag = cipher.getAuthTag()
    
    return Buffer.concat([salt, iv, tag, encrypted]).toString('base64')
  } catch (error) {
    console.error('Metadata encryption error:', error)
    throw new Error('Failed to encrypt metadata')
  }
}

// Decrypt file metadata
const decryptMetadata = (encryptedMetadata, password) => {
  try {
    const encryptedData = Buffer.from(encryptedMetadata, 'base64')
    
    const salt = encryptedData.slice(0, 16)
    const iv = encryptedData.slice(16, 32)
    const tag = encryptedData.slice(32, 48)
    const encrypted = encryptedData.slice(48)
    
    const key = generateKey(password, salt)
    
    const decipher = crypto.createDecipher(ENCRYPTION_ALGORITHM, key)
    decipher.setAAD(salt)
    decipher.setAuthTag(tag)
    
    let decrypted = decipher.update(encrypted)
    decrypted = Buffer.concat([decrypted, decipher.final()])
    
    return JSON.parse(decrypted.toString('utf8'))
  } catch (error) {
    console.error('Metadata decryption error:', error)
    throw new Error('Failed to decrypt metadata')
  }
}

// File integrity verification
const verifyFileIntegrity = async (filePath, expectedChecksum) => {
  try {
    const fileContent = await fs.readFile(filePath)
    const actualChecksum = crypto.createHash('sha256').update(fileContent).digest('hex')
    return actualChecksum === expectedChecksum
  } catch (error) {
    console.error('File integrity verification error:', error)
    return false
  }
}

// Secure file deletion
const secureDeleteFile = async (filePath) => {
  try {
    // Overwrite file with random data multiple times
    const stats = await fs.stat(filePath)
    const fileSize = stats.size
    
    // Write random data 3 times
    for (let i = 0; i < 3; i++) {
      const randomData = crypto.randomBytes(fileSize)
      await fs.writeFile(filePath, randomData)
    }
    
    // Delete file
    await fs.unlink(filePath)
    
    return { success: true }
  } catch (error) {
    console.error('Secure delete error:', error)
    throw new Error('Failed to securely delete file')
  }
}

module.exports = {
  encryptFile,
  decryptFile,
  encryptAndStoreFile,
  decryptAndRetrieveFile,
  generateSecurePassword,
  hashPassword,
  verifyPassword,
  encryptMetadata,
  decryptMetadata,
  verifyFileIntegrity,
  secureDeleteFile
}
EOF

    # Email Controller
    cat > "$APP_DIR/src/controllers/emailController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

const getTemplates = async (req, res) => {
  try {
    const templates = await prisma.emailTemplate.findMany({
      orderBy: { createdAt: 'desc' }
    })

    res.json(templates)
  } catch (error) {
    console.error('Get email templates error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const createTemplate = async (req, res) => {
  try {
    const { name, subject, body, type } = req.body

    const template = await prisma.emailTemplate.create({
      data: {
        name,
        subject,
        body,
        type,
        createdBy: req.user.id
      }
    })

    res.status(201).json(template)
  } catch (error) {
    console.error('Create email template error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const updateTemplate = async (req, res) => {
  try {
    const { id } = req.params
    const { name, subject, body, type } = req.body

    const template = await prisma.emailTemplate.update({
      where: { id },
      data: {
        name,
        subject,
        body,
        type
      }
    })

    res.json(template)
  } catch (error) {
    console.error('Update email template error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const deleteTemplate = async (req, res) => {
  try {
    const { id } = req.params

    await prisma.emailTemplate.delete({
      where: { id }
    })

    res.status(204).send()
  } catch (error) {
    console.error('Delete email template error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getCampaigns = async (req, res) => {
  try {
    const campaigns = await prisma.emailCampaign.findMany({
      orderBy: { createdAt: 'desc' }
    })

    res.json(campaigns)
  } catch (error) {
    console.error('Get email campaigns error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const createCampaign = async (req, res) => {
  try {
    const { name, templateId, recipients, scheduledAt } = req.body

    const campaign = await prisma.emailCampaign.create({
      data: {
        name,
        templateId,
        recipients,
        scheduledAt: scheduledAt ? new Date(scheduledAt) : null,
        createdBy: req.user.id
      }
    })

    res.status(201).json(campaign)
  } catch (error) {
    console.error('Create email campaign error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const sendCampaign = async (req, res) => {
  try {
    const { id } = req.params

    await prisma.emailCampaign.update({
      where: { id },
      data: { 
        status: 'SENT',
        sentAt: new Date()
      }
    })

    res.json({ message: 'Campaign sent successfully' })
  } catch (error) {
    console.error('Send campaign error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getLogs = async (req, res) => {
  try {
    const logs = await prisma.emailLog.findMany({
      orderBy: { createdAt: 'desc' },
      take: 100
    })

    res.json(logs)
  } catch (error) {
    console.error('Get email logs error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Send email to multiple recipients
const sendMultipleEmails = async (req, res) => {
  try {
    const { recipients, subject, content, type = 'CUSTOM' } = req.body

    if (!recipients || !Array.isArray(recipients) || recipients.length === 0) {
      return res.status(400).json({ error: 'Recipients array is required' })
    }

    if (!subject || !content) {
      return res.status(400).json({ error: 'Subject and content are required' })
    }

    const results = []
    const transporter = createTransporter()

    for (const recipient of recipients) {
      try {
        const mailOptions = {
          from: process.env.SMTP_FROM || 'noreply@eventmanager.com',
          to: recipient.email || recipient,
          subject: subject,
          html: content,
          text: content.replace(/<[^>]*>/g, '') // Strip HTML for text version
        }

        const info = await transporter.sendMail(mailOptions)
        
        // Log successful email
        await prisma.emailLog.create({
          data: {
            to: recipient.email || recipient,
            subject: subject,
            status: 'SENT',
            sentAt: new Date(),
            messageId: info.messageId
          }
        })

        results.push({
          recipient: recipient.email || recipient,
          status: 'SENT',
          messageId: info.messageId
        })
      } catch (error) {
        console.error(`Failed to send email to ${recipient.email || recipient}:`, error)
        
        // Log failed email
        await prisma.emailLog.create({
          data: {
            to: recipient.email || recipient,
            subject: subject,
            status: 'FAILED',
            sentAt: new Date(),
            errorMessage: error.message
          }
        })

        results.push({
          recipient: recipient.email || recipient,
          status: 'FAILED',
          error: error.message
        })
      }
    }

    res.json({
      message: 'Bulk email processing completed',
      results: results,
      totalSent: results.filter(r => r.status === 'SENT').length,
      totalFailed: results.filter(r => r.status === 'FAILED').length
    })
  } catch (error) {
    console.error('Send multiple emails error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Send email to users by role
const sendEmailByRole = async (req, res) => {
  try {
    const { roles, subject, content, type = 'CUSTOM' } = req.body

    if (!roles || !Array.isArray(roles) || roles.length === 0) {
      return res.status(400).json({ error: 'Roles array is required' })
    }

    if (!subject || !content) {
      return res.status(400).json({ error: 'Subject and content are required' })
    }

    // Get users with specified roles
    const users = await prisma.user.findMany({
      where: {
        role: { in: roles },
        isActive: true
      },
      select: {
        id: true,
        name: true,
        email: true,
        role: true
      }
    })

    if (users.length === 0) {
      return res.status(404).json({ error: 'No users found with specified roles' })
    }

    const results = []
    const transporter = createTransporter()

    for (const user of users) {
      try {
        const mailOptions = {
          from: process.env.SMTP_FROM || 'noreply@eventmanager.com',
          to: user.email,
          subject: subject,
          html: content,
          text: content.replace(/<[^>]*>/g, '') // Strip HTML for text version
        }

        const info = await transporter.sendMail(mailOptions)
        
        // Log successful email
        await prisma.emailLog.create({
          data: {
            to: user.email,
            subject: subject,
            status: 'SENT',
            sentAt: new Date(),
            messageId: info.messageId
          }
        })

        results.push({
          user: user.name,
          email: user.email,
          role: user.role,
          status: 'SENT',
          messageId: info.messageId
        })
      } catch (error) {
        console.error(`Failed to send email to ${user.email}:`, error)
        
        // Log failed email
        await prisma.emailLog.create({
          data: {
            to: user.email,
            subject: subject,
            status: 'FAILED',
            sentAt: new Date(),
            errorMessage: error.message
          }
        })

        results.push({
          user: user.name,
          email: user.email,
          role: user.role,
          status: 'FAILED',
          error: error.message
        })
      }
    }

    res.json({
      message: 'Role-based email processing completed',
      results: results,
      totalSent: results.filter(r => r.status === 'SENT').length,
      totalFailed: results.filter(r => r.status === 'FAILED').length,
      roles: roles
    })
  } catch (error) {
    console.error('Send email by role error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Helper function to create nodemailer transporter from database settings
const createTransporter = async () => {
  try {
    const nodemailer = require('nodemailer')
    
    // Get SMTP settings from database
    const smtpHost = await prisma.systemSetting.findUnique({ where: { key: 'smtp_host' } })
    const smtpPort = await prisma.systemSetting.findUnique({ where: { key: 'smtp_port' } })
    const smtpUser = await prisma.systemSetting.findUnique({ where: { key: 'smtp_user' } })
    const smtpPassword = await prisma.systemSetting.findUnique({ where: { key: 'smtp_password' } })
    const smtpSecure = await prisma.systemSetting.findUnique({ where: { key: 'smtp_secure' } })
    const smtpFrom = await prisma.systemSetting.findUnique({ where: { key: 'smtp_from' } })
    
    if (!smtpHost || !smtpPort || !smtpUser || !smtpPassword) {
      throw new Error('SMTP settings not configured')
    }
    
    const transporter = nodemailer.createTransporter({
      host: smtpHost.value,
      port: parseInt(smtpPort.value),
      secure: smtpSecure ? smtpSecure.value === 'true' : false,
      auth: {
        user: smtpUser.value,
        pass: smtpPassword.value
      }
    })
    
    return { transporter, from: smtpFrom ? smtpFrom.value : smtpUser.value }
  } catch (error) {
    console.error('Failed to create email transporter:', error)
    throw error
  }
}

// Send report via email
const sendReportEmail = async ({ to, subject, reportData, filename, contentType }) => {
  try {
    const { transporter, from } = await createTransporter()
    
    // Convert reportData to attachment
    const attachment = {
      filename,
      content: reportData,
      contentType
    }
    
    // Send email
    const info = await transporter.sendMail({
      from,
      to: Array.isArray(to) ? to.join(', ') : to,
      subject,
      text: `Please find the attached ${subject}`,
      html: `<p>Please find the attached <strong>${subject}</strong></p>`,
      attachments: [attachment]
    })
    
    console.log('Report email sent:', info.messageId)
    return { success: true, messageId: info.messageId }
  } catch (error) {
    console.error('Failed to send report email:', error)
    throw error
  }
}

// Send custom email
const sendEmail = async ({ to, subject, text, html, attachments = [] }) => {
  try {
    const { transporter, from } = await createTransporter()
    
    const info = await transporter.sendMail({
      from,
      to: Array.isArray(to) ? to.join(', ') : to,
      subject,
      text,
      html,
      attachments
    })
    
    console.log('Email sent:', info.messageId)
    return { success: true, messageId: info.messageId }
  } catch (error) {
    console.error('Failed to send email:', error)
    throw error
  }
}

module.exports = {
  getTemplates,
  createTemplate,
  updateTemplate,
  deleteTemplate,
  getCampaigns,
  createCampaign,
  sendCampaign,
  getLogs,
  sendMultipleEmails,
  sendEmailByRole,
  sendReportEmail,
  sendEmail,
  createTransporter
}
EOF

    # Emcee Controller
    cat > "$APP_DIR/src/controllers/emceeController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

// Get emcee dashboard stats
const getStats = async (req, res) => {
  try {
    const totalScripts = await prisma.emceeScript.count({
      where: { isActive: true }
    })

    const totalEvents = await prisma.event.count({
      where: { isActive: true }
    })

    const totalContests = await prisma.contest.count({
      where: { isActive: true }
    })

    const totalCategories = await prisma.category.count({
      where: { isActive: true }
    })

    res.json({
      totalScripts,
      totalEvents,
      totalContests,
      totalCategories
    })
  } catch (error) {
    console.error('Get emcee stats error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get script access
const getScripts = async (req, res) => {
  try {
    const { eventId, contestId, categoryId, type } = req.query

    const whereClause = { isActive: true }
    
    if (eventId) whereClause.eventId = eventId
    if (contestId) whereClause.contestId = contestId
    if (categoryId) whereClause.categoryId = categoryId
    if (type) whereClause.type = type

    const scripts = await prisma.emceeScript.findMany({
      where: whereClause,
      include: {
        event: {
          select: {
            id: true,
            name: true,
            description: true,
            startDate: true,
            endDate: true
          }
        },
        contest: {
          select: {
            id: true,
            name: true,
            description: true,
            startTime: true,
            endTime: true
          }
        },
        category: {
          select: {
            id: true,
            name: true,
            description: true,
            maxScore: true
          }
        },
        author: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true
          }
        }
      },
      orderBy: [
        { event: { startDate: 'asc' } },
        { contest: { startTime: 'asc' } },
        { category: { name: 'asc' } },
        { order: 'asc' }
      ]
    })

    res.json(scripts)
  } catch (error) {
    console.error('Get scripts error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get specific script
const getScript = async (req, res) => {
  try {
    const { scriptId } = req.params

    const script = await prisma.emceeScript.findUnique({
      where: { id: scriptId },
      include: {
        event: {
          select: {
            id: true,
            name: true,
            description: true,
            startDate: true,
            endDate: true
          }
        },
        contest: {
          select: {
            id: true,
            name: true,
            description: true,
            startTime: true,
            endTime: true
          }
        },
        category: {
          select: {
            id: true,
            name: true,
            description: true,
            maxScore: true
          }
        },
        author: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true
          }
        }
      }
    })

    if (!script) {
      return res.status(404).json({ error: 'Script not found' })
    }

    // Increment usage count
    await prisma.emceeScript.update({
      where: { id: scriptId },
      data: { usageCount: { increment: 1 } }
    })

    res.json(script)
  } catch (error) {
    console.error('Get script error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get contestant bios
const getContestantBios = async (req, res) => {
  try {
    const { eventId, contestId, categoryId } = req.query

    const whereClause = {}
    
    if (eventId) {
      whereClause.contests = {
        some: {
          eventId
        }
      }
    }
    
    if (contestId) {
      whereClause.contests = {
        some: {
          id: contestId
        }
      }
    }
    
    if (categoryId) {
      whereClause.categories = {
        some: {
          id: categoryId
        }
      }
    }

    const contestants = await prisma.contestant.findMany({
      where: whereClause,
      include: {
        user: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true,
            pronouns: true
          }
        },
        contests: {
          include: {
            event: {
              select: {
                id: true,
                name: true,
                description: true,
                startDate: true,
                endDate: true
              }
            }
          }
        },
        categories: {
          select: {
            id: true,
            name: true,
            description: true,
            maxScore: true
          }
        }
      },
      orderBy: { name: 'asc' }
    })

    res.json(contestants)
  } catch (error) {
    console.error('Get contestant bios error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get judge bios
const getJudgeBios = async (req, res) => {
  try {
    const { eventId, contestId, categoryId } = req.query

    const whereClause = {
      role: { in: ['JUDGE', 'TALLY_MASTER', 'AUDITOR', 'BOARD', 'ORGANIZER'] }
    }
    
    if (eventId) {
      whereClause.contests = {
        some: {
          eventId
        }
      }
    }
    
    if (contestId) {
      whereClause.contests = {
        some: {
          id: contestId
        }
      }
    }
    
    if (categoryId) {
      whereClause.categories = {
        some: {
          id: categoryId
        }
      }
    }

    const judges = await prisma.user.findMany({
      where: whereClause,
      select: {
        id: true,
        name: true,
        preferredName: true,
        email: true,
        role: true,
        pronouns: true,
        judgeBio: true,
        judgeSpecialties: true,
        judgeCertifications: true,
        createdAt: true
      },
      orderBy: { name: 'asc' }
    })

    res.json(judges)
  } catch (error) {
    console.error('Get judge bios error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get event management
const getEvents = async (req, res) => {
  try {
    const events = await prisma.event.findMany({
      where: { isActive: true },
      include: {
        contests: {
          include: {
            categories: {
              select: {
                id: true,
                name: true,
                description: true,
                maxScore: true,
                isActive: true
              }
            }
          },
          orderBy: { startTime: 'asc' }
        }
      },
      orderBy: { startDate: 'asc' }
    })

    res.json(events)
  } catch (error) {
    console.error('Get events error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get specific event
const getEvent = async (req, res) => {
  try {
    const { eventId } = req.params

    const event = await prisma.event.findUnique({
      where: { id: eventId },
      include: {
        contests: {
          include: {
            categories: {
              select: {
                id: true,
                name: true,
                description: true,
                maxScore: true,
                isActive: true
              }
            }
          },
          orderBy: { startTime: 'asc' }
        }
      }
    })

    if (!event) {
      return res.status(404).json({ error: 'Event not found' })
    }

    res.json(event)
  } catch (error) {
    console.error('Get event error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get contest management
const getContests = async (req, res) => {
  try {
    const { eventId } = req.query

    const whereClause = { isActive: true }
    if (eventId) whereClause.eventId = eventId

    const contests = await prisma.contest.findMany({
      where: whereClause,
      include: {
        event: {
          select: {
            id: true,
            name: true,
            description: true,
            startDate: true,
            endDate: true
          }
        },
        categories: {
          select: {
            id: true,
            name: true,
            description: true,
            maxScore: true,
            isActive: true
          },
          orderBy: { name: 'asc' }
        }
      },
      orderBy: { startTime: 'asc' }
    })

    res.json(contests)
  } catch (error) {
    console.error('Get contests error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get specific contest
const getContest = async (req, res) => {
  try {
    const { contestId } = req.params

    const contest = await prisma.contest.findUnique({
      where: { id: contestId },
      include: {
        event: {
          select: {
            id: true,
            name: true,
            description: true,
            startDate: true,
            endDate: true
          }
        },
        categories: {
          select: {
            id: true,
            name: true,
            description: true,
            maxScore: true,
            isActive: true
          },
          orderBy: { name: 'asc' }
        }
      }
    })

    if (!contest) {
      return res.status(404).json({ error: 'Contest not found' })
    }

    res.json(contest)
  } catch (error) {
    console.error('Get contest error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get emcee history
const getEmceeHistory = async (req, res) => {
  try {
    const { page = 1, limit = 10 } = req.query
    const offset = (page - 1) * limit

    const scripts = await prisma.emceeScript.findMany({
      where: { isActive: true },
      include: {
        event: {
          select: {
            id: true,
            name: true,
            description: true,
            startDate: true,
            endDate: true
          }
        },
        contest: {
          select: {
            id: true,
            name: true,
            description: true,
            startTime: true,
            endTime: true
          }
        },
        category: {
          select: {
            id: true,
            name: true,
            description: true,
            maxScore: true
          }
        },
        author: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true
          }
        }
      },
      orderBy: { createdAt: 'desc' },
      skip: offset,
      take: parseInt(limit)
    })

    const total = await prisma.emceeScript.count({
      where: { isActive: true }
    })

    res.json({
      scripts,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / limit)
      }
    })
  } catch (error) {
    console.error('Get emcee history error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  getStats,
  getScripts,
  getScript,
  getContestantBios,
  getJudgeBios,
  getEvents,
  getEvent,
  getContests,
  getContest,
  getEmceeHistory
}
EOF
    cat > "$APP_DIR/src/controllers/reportsController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')
const fs = require('fs').promises
const path = require('path')

const prisma = new PrismaClient()

const getTemplates = async (req, res) => {
  try {
    const templates = await prisma.reportTemplate.findMany({
      orderBy: { createdAt: 'desc' }
    })

    res.json(templates)
  } catch (error) {
    console.error('Get report templates error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const createTemplate = async (req, res) => {
  try {
    const { name, description, template, parameters } = req.body

    const reportTemplate = await prisma.reportTemplate.create({
      data: {
        name,
        description,
        template,
        parameters,
        createdBy: req.user.id
      }
    })

    res.status(201).json(reportTemplate)
  } catch (error) {
    console.error('Create report template error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const updateTemplate = async (req, res) => {
  try {
    const { id } = req.params
    const { name, description, template, parameters } = req.body

    const reportTemplate = await prisma.reportTemplate.update({
      where: { id },
      data: {
        name,
        description,
        template,
        parameters
      }
    })

    res.json(reportTemplate)
  } catch (error) {
    console.error('Update report template error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const deleteTemplate = async (req, res) => {
  try {
    const { id } = req.params

    await prisma.reportTemplate.delete({
      where: { id }
    })

    res.status(204).send()
  } catch (error) {
    console.error('Delete report template error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const generateReport = async (req, res) => {
  try {
    const { templateId } = req.params
    const { parameters } = req.body

    const template = await prisma.reportTemplate.findUnique({
      where: { id: templateId }
    })

    if (!template) {
      return res.status(404).json({ error: 'Template not found' })
    }

    // Generate report based on template
    const report = {
      templateId,
      parameters,
      generatedAt: new Date(),
      generatedBy: req.user.id
    }

    res.json(report)
  } catch (error) {
    console.error('Generate report error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getHistory = async (req, res) => {
  try {
    const history = await prisma.reportHistory.findMany({
      include: {
        template: true,
        user: {
          select: {
            name: true,
            email: true
          }
        }
      },
      orderBy: { createdAt: 'desc' },
      take: 100
    })

    res.json(history)
  } catch (error) {
    console.error('Get report history error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Generate comprehensive event report
const generateEventReport = async (req, res) => {
  try {
    const { eventId, includeDetails = false, format = 'JSON' } = req.body

    const event = await prisma.event.findUnique({
      where: { id: eventId },
      include: {
        contests: {
          include: {
            categories: {
              include: {
                scores: {
                  include: {
                    judge: {
                      select: {
                        id: true,
                        name: true,
                        preferredName: true,
                        email: true
                      }
                    },
                    contestant: {
                      select: {
                        id: true,
                        name: true,
                        preferredName: true,
                        email: true,
                        contestantNumber: true
                      }
                    },
                    criterion: {
                      select: {
                        id: true,
                        name: true,
                        description: true,
                        maxScore: true
                      }
                    }
                  }
                },
                contestants: {
                  include: {
                    user: {
                      select: {
                        id: true,
                        name: true,
                        preferredName: true,
                        email: true,
                        contestantNumber: true,
                        contestantAge: true,
                        contestantSchool: true
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    })

    if (!event) {
      return res.status(404).json({ error: 'Event not found' })
    }

    // Calculate comprehensive statistics
    const eventStats = {
      totalContests: event.contests.length,
      totalCategories: event.contests.reduce((sum, contest) => sum + contest.categories.length, 0),
      totalContestants: event.contests.reduce((sum, contest) => 
        sum + contest.categories.reduce((catSum, category) => catSum + category.contestants.length, 0), 0),
      totalScores: event.contests.reduce((sum, contest) => 
        sum + contest.categories.reduce((catSum, category) => catSum + category.scores.length, 0), 0)
    }

    // Generate contest summaries
    const contestSummaries = event.contests.map(contest => {
      const contestStats = {
        id: contest.id,
        name: contest.name,
        description: contest.description,
        totalCategories: contest.categories.length,
        totalContestants: contest.categories.reduce((sum, category) => sum + category.contestants.length, 0),
        totalScores: contest.categories.reduce((sum, category) => sum + category.scores.length, 0)
      }

      if (includeDetails) {
        contestStats.categories = contest.categories.map(category => {
          const categoryStats = {
            id: category.id,
            name: category.name,
            description: category.description,
            maxScore: category.maxScore,
            totalContestants: category.contestants.length,
            totalScores: category.scores.length,
            averageScore: category.scores.length > 0 ? 
              category.scores.reduce((sum, score) => sum + score.score, 0) / category.scores.length : 0
          }

          // Calculate contestant rankings
          const contestantScores = category.scores.reduce((acc, score) => {
            const key = score.contestantId
            if (!acc[key]) {
              acc[key] = {
                contestant: score.contestant,
                scores: [],
                totalScore: 0
              }
            }
            acc[key].scores.push(score)
            acc[key].totalScore += score.score
            return acc
          }, {})

          categoryStats.contestantRankings = Object.values(contestantScores)
            .map(group => ({
              contestant: group.contestant,
              totalScore: group.totalScore,
              averageScore: group.totalScore / group.scores.length,
              scoreCount: group.scores.length
            }))
            .sort((a, b) => b.totalScore - a.totalScore)
            .map((ranking, index) => ({ ...ranking, rank: index + 1 }))

          return categoryStats
        })
      }

      return contestStats
    })

    const report = {
      event: {
        id: event.id,
        name: event.name,
        description: event.description,
        startDate: event.startDate,
        endDate: event.endDate,
        location: event.location,
        maxContestants: event.maxContestants,
        status: event.status
      },
      statistics: eventStats,
      contests: contestSummaries,
      generatedAt: new Date().toISOString(),
      generatedBy: req.user.id,
      format: format
    }

    // Save report to database
    const savedReport = await prisma.report.create({
      data: {
        name: `Event Report - ${event.name}`,
        type: 'EVENT_REPORT',
        parameters: JSON.stringify({ eventId, includeDetails, format }),
        format: format,
        generatedBy: req.user.id,
        status: 'GENERATED'
      }
    })

    res.json({
      report,
      reportId: savedReport.id,
      message: 'Event report generated successfully'
    })
  } catch (error) {
    console.error('Generate event report error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Generate contest results report
const generateContestResultsReport = async (req, res) => {
  try {
    const { contestId, includeDetails = false, format = 'JSON' } = req.body

    const contest = await prisma.contest.findUnique({
      where: { id: contestId },
      include: {
        event: true,
        categories: {
          include: {
            scores: {
              include: {
                judge: {
                  select: {
                    id: true,
                    name: true,
                    preferredName: true,
                    email: true
                  }
                },
                contestant: {
                  select: {
                    id: true,
                    name: true,
                    preferredName: true,
                    email: true,
                    contestantNumber: true
                  }
                },
                criterion: {
                  select: {
                    id: true,
                    name: true,
                    description: true,
                    maxScore: true
                  }
                }
              }
            },
            contestants: {
              include: {
                user: {
                  select: {
                    id: true,
                    name: true,
                    preferredName: true,
                    email: true,
                    contestantNumber: true,
                    contestantAge: true,
                    contestantSchool: true
                  }
                }
              }
            }
          }
        }
      }
    })

    if (!contest) {
      return res.status(404).json({ error: 'Contest not found' })
    }

    // Calculate contest statistics
    const contestStats = {
      totalCategories: contest.categories.length,
      totalContestants: contest.categories.reduce((sum, category) => sum + category.contestants.length, 0),
      totalScores: contest.categories.reduce((sum, category) => sum + category.scores.length, 0)
    }

    // Generate category results
    const categoryResults = contest.categories.map(category => {
      const categoryStats = {
        id: category.id,
        name: category.name,
        description: category.description,
        maxScore: category.maxScore,
        totalContestants: category.contestants.length,
        totalScores: category.scores.length
      }

      // Calculate contestant rankings
      const contestantScores = category.scores.reduce((acc, score) => {
        const key = score.contestantId
        if (!acc[key]) {
          acc[key] = {
            contestant: score.contestant,
            scores: [],
            totalScore: 0
          }
        }
        acc[key].scores.push(score)
        acc[key].totalScore += score.score
        return acc
      }, {})

      categoryStats.contestantRankings = Object.values(contestantScores)
        .map(group => ({
          contestant: group.contestant,
          totalScore: group.totalScore,
          averageScore: group.totalScore / group.scores.length,
          scoreCount: group.scores.length
        }))
        .sort((a, b) => b.totalScore - a.totalScore)
        .map((ranking, index) => ({ ...ranking, rank: index + 1 }))

      if (includeDetails) {
        categoryStats.scoreDetails = category.scores.map(score => ({
          id: score.id,
          judge: score.judge,
          contestant: score.contestant,
          criterion: score.criterion,
          score: score.score,
          comments: score.comments,
          createdAt: score.createdAt
        }))
      }

      return categoryStats
    })

    const report = {
      contest: {
        id: contest.id,
        name: contest.name,
        description: contest.description,
        eventName: contest.event.name,
        startDate: contest.startDate,
        endDate: contest.endDate
      },
      statistics: contestStats,
      categories: categoryResults,
      generatedAt: new Date().toISOString(),
      generatedBy: req.user.id,
      format: format
    }

    // Save report to database
    const savedReport = await prisma.report.create({
      data: {
        name: `Contest Results Report - ${contest.name}`,
        type: 'CONTEST_RESULTS',
        parameters: JSON.stringify({ contestId, includeDetails, format }),
        format: format,
        generatedBy: req.user.id,
        status: 'GENERATED'
      }
    })

    res.json({
      report,
      reportId: savedReport.id,
      message: 'Contest results report generated successfully'
    })
  } catch (error) {
    console.error('Generate contest results report error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Generate judge performance report
const generateJudgePerformanceReport = async (req, res) => {
  try {
    const { judgeId, eventId, includeDetails = false, format = 'JSON' } = req.body

    const judge = await prisma.user.findUnique({
      where: { id: judgeId },
      select: {
        id: true,
        name: true,
        preferredName: true,
        email: true,
        role: true,
        judgeBio: true,
        judgeSpecialties: true,
        judgeCertifications: true
      }
    })

    if (!judge) {
      return res.status(404).json({ error: 'Judge not found' })
    }

    // Get judge's scores
    const scores = await prisma.score.findMany({
      where: {
        judgeId: judgeId,
        ...(eventId && {
          event: { id: eventId }
        })
      },
      include: {
        category: {
          include: {
            contest: {
              include: {
                event: true
              }
            }
          }
        },
        contestant: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true,
            contestantNumber: true
          }
        },
        criterion: {
          select: {
            id: true,
            name: true,
            description: true,
            maxScore: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    })

    // Calculate judge statistics
    const judgeStats = {
      totalScores: scores.length,
      averageScore: scores.length > 0 ? scores.reduce((sum, score) => sum + score.score, 0) / scores.length : 0,
      maxScore: Math.max(...scores.map(s => s.score), 0),
      minScore: Math.min(...scores.map(s => s.score), 0),
      uniqueCategories: new Set(scores.map(s => s.categoryId)).size,
      uniqueContestants: new Set(scores.map(s => s.contestantId)).size
    }

    // Group scores by category
    const categoryPerformance = scores.reduce((acc, score) => {
      const categoryId = score.categoryId
      if (!acc[categoryId]) {
        acc[categoryId] = {
          category: score.category,
          scores: [],
          totalScore: 0,
          averageScore: 0
        }
      }
      acc[categoryId].scores.push(score)
      acc[categoryId].totalScore += score.score
      return acc
    }, {})

    // Calculate averages for each category
    Object.values(categoryPerformance).forEach(category => {
      category.averageScore = category.scores.length > 0 ? category.totalScore / category.scores.length : 0
    })

    const report = {
      judge: {
        id: judge.id,
        name: judge.name,
        preferredName: judge.preferredName,
        email: judge.email,
        role: judge.role,
        bio: judge.judgeBio,
        specialties: judge.judgeSpecialties ? JSON.parse(judge.judgeSpecialties) : [],
        certifications: judge.judgeCertifications ? JSON.parse(judge.judgeCertifications) : []
      },
      statistics: judgeStats,
      categoryPerformance: Object.values(categoryPerformance),
      generatedAt: new Date().toISOString(),
      generatedBy: req.user.id,
      format: format
    }

    if (includeDetails) {
      report.scoreDetails = scores.map(score => ({
        id: score.id,
        category: score.category,
        contestant: score.contestant,
        criterion: score.criterion,
        score: score.score,
        comments: score.comments,
        createdAt: score.createdAt
      }))
    }

    // Save report to database
    const savedReport = await prisma.report.create({
      data: {
        name: `Judge Performance Report - ${judge.preferredName || judge.name}`,
        type: 'JUDGE_PERFORMANCE',
        parameters: JSON.stringify({ judgeId, eventId, includeDetails, format }),
        format: format,
        generatedBy: req.user.id,
        status: 'GENERATED'
      }
    })

    res.json({
      report,
      reportId: savedReport.id,
      message: 'Judge performance report generated successfully'
    })
  } catch (error) {
    console.error('Generate judge performance report error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Generate system analytics report
const generateSystemAnalyticsReport = async (req, res) => {
  try {
    const { startDate, endDate, includeDetails = false, format = 'JSON' } = req.body

    const dateFilter = {
      ...(startDate && { gte: new Date(startDate) }),
      ...(endDate && { lte: new Date(endDate) })
    }

    // Get system statistics
    const [
      totalUsers,
      totalEvents,
      totalContests,
      totalCategories,
      totalScores,
      totalFiles,
      userActivity,
      eventActivity,
      scoreActivity
    ] = await Promise.all([
      prisma.user.count(),
      prisma.event.count({ where: { createdAt: dateFilter } }),
      prisma.contest.count({ where: { createdAt: dateFilter } }),
      prisma.category.count({ where: { createdAt: dateFilter } }),
      prisma.score.count({ where: { createdAt: dateFilter } }),
      prisma.file.count({ where: { uploadedAt: dateFilter } }),
      prisma.activityLog.count({ where: { createdAt: dateFilter } }),
      prisma.event.count({ where: { createdAt: dateFilter } }),
      prisma.score.count({ where: { createdAt: dateFilter } })
    ])

    // Get user role distribution
    const userRoles = await prisma.user.groupBy({
      by: ['role'],
      _count: { role: true },
      where: { createdAt: dateFilter }
    })

    // Get event status distribution
    const eventStatuses = await prisma.event.groupBy({
      by: ['status'],
      _count: { status: true },
      where: { createdAt: dateFilter }
    })

    // Get file category distribution
    const fileCategories = await prisma.file.groupBy({
      by: ['category'],
      _count: { category: true },
      where: { uploadedAt: dateFilter }
    })

    const analytics = {
      overview: {
        totalUsers,
        totalEvents,
        totalContests,
        totalCategories,
        totalScores,
        totalFiles,
        userActivity,
        eventActivity,
        scoreActivity
      },
      distributions: {
        userRoles: userRoles.map(role => ({
          role: role.role,
          count: role._count.role
        })),
        eventStatuses: eventStatuses.map(status => ({
          status: status.status,
          count: status._count.status
        })),
        fileCategories: fileCategories.map(category => ({
          category: category.category,
          count: category._count.category
        }))
      },
      period: {
        startDate: startDate || null,
        endDate: endDate || null
      }
    }

    if (includeDetails) {
      // Get detailed activity logs
      const activityLogs = await prisma.activityLog.findMany({
        where: { createdAt: dateFilter },
        include: {
          user: {
            select: {
              id: true,
              name: true,
              preferredName: true,
              email: true,
              role: true
            }
          }
        },
        orderBy: { createdAt: 'desc' },
        take: 1000
      })

      analytics.activityLogs = activityLogs.map(log => ({
        id: log.id,
        action: log.action,
        entityType: log.entityType,
        entityId: log.entityId,
        details: log.details,
        user: log.user,
        createdAt: log.createdAt
      }))
    }

    const report = {
      analytics,
      generatedAt: new Date().toISOString(),
      generatedBy: req.user.id,
      format: format
    }

    // Save report to database
    const savedReport = await prisma.report.create({
      data: {
        name: `System Analytics Report - ${startDate || 'All Time'}`,
        type: 'SYSTEM_ANALYTICS',
        parameters: JSON.stringify({ startDate, endDate, includeDetails, format }),
        format: format,
        generatedBy: req.user.id,
        status: 'GENERATED'
      }
    })

    res.json({
      report,
      reportId: savedReport.id,
      message: 'System analytics report generated successfully'
    })
  } catch (error) {
    console.error('Generate system analytics report error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get all reports
const getAllReports = async (req, res) => {
  try {
    const { page = 1, limit = 10, type, status } = req.query

    const whereClause = {
      ...(type && { type }),
      ...(status && { status })
    }

    const reports = await prisma.report.findMany({
      where: whereClause,
      include: {
        user: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true
          }
        }
      },
      orderBy: { createdAt: 'desc' },
      skip: (page - 1) * limit,
      take: parseInt(limit)
    })

    const totalReports = await prisma.report.count({ where: whereClause })

    res.json({
      reports,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: totalReports,
        pages: Math.ceil(totalReports / limit)
      }
    })
  } catch (error) {
    console.error('Get all reports error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get report by ID
const getReportById = async (req, res) => {
  try {
    const { id } = req.params

    const report = await prisma.report.findUnique({
      where: { id },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true
          }
        }
      }
    })

    if (!report) {
      return res.status(404).json({ error: 'Report not found' })
    }

    res.json(report)
  } catch (error) {
    console.error('Get report by ID error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Delete report
const deleteReport = async (req, res) => {
  try {
    const { id } = req.params

    const report = await prisma.report.findUnique({
      where: { id }
    })

    if (!report) {
      return res.status(404).json({ error: 'Report not found' })
    }

    // Delete associated file if exists
    if (report.filePath) {
      try {
        await fs.unlink(report.filePath)
      } catch (error) {
        console.error('Error deleting report file:', error)
      }
    }

    await prisma.report.delete({
      where: { id }
    })

    res.json({ message: 'Report deleted successfully' })
  } catch (error) {
    console.error('Delete report error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Export report to file
const exportReport = async (req, res) => {
  try {
    const { id } = req.params
    const { format = 'JSON' } = req.body

    const report = await prisma.report.findUnique({
      where: { id }
    })

    if (!report) {
      return res.status(404).json({ error: 'Report not found' })
    }

    // Generate file path
    const fileName = `${report.name.replace(/[^a-zA-Z0-9]/g, '_')}_${Date.now()}.${format.toLowerCase()}`
    const filePath = path.join(__dirname, '..', '..', 'reports', fileName)

    // Create reports directory if it doesn't exist
    await fs.mkdir(path.dirname(filePath), { recursive: true })

    // Export based on format
    let fileContent
    switch (format.toUpperCase()) {
      case 'JSON':
        fileContent = JSON.stringify(report, null, 2)
        break
      case 'CSV':
        // Convert report to CSV format
        fileContent = convertToCSV(report)
        break
      case 'XML':
        // Convert report to XML format
        fileContent = convertToXML(report)
        break
      default:
        return res.status(400).json({ error: 'Unsupported export format' })
    }

    // Write file
    await fs.writeFile(filePath, fileContent, 'utf8')

    // Update report with file path
    await prisma.report.update({
      where: { id },
      data: {
        filePath,
        fileSize: fileContent.length,
        status: 'EXPORTED'
      }
    })

    res.json({
      message: 'Report exported successfully',
      filePath,
      fileName,
      fileSize: fileContent.length
    })
  } catch (error) {
    console.error('Export report error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Helper function to convert report to CSV
const convertToCSV = (report) => {
  // Implementation for CSV conversion
  return 'CSV conversion not implemented yet'
}

// Helper function to convert report to XML
const convertToXML = (report) => {
  // Implementation for XML conversion
  return 'XML conversion not implemented yet'
}

// Email report to recipients
const emailReport = async (req, res) => {
  try {
    const { id } = req.params
    const { recipients, subject, message } = req.body

    if (!recipients || recipients.length === 0) {
      return res.status(400).json({ error: 'Recipients are required' })
    }

    // Get the report instance
    const reportInstance = await prisma.reportHistory.findUnique({
      where: { id },
      include: {
        template: true,
        user: {
          select: {
            name: true,
            email: true
          }
        }
      }
    })

    if (!reportInstance) {
      return res.status(404).json({ error: 'Report not found' })
    }

    // Import email controller
    const emailController = require('./emailController')
    
    // Create email content
    const emailContent = \`
      <h2>Report: \${reportInstance.name}</h2>
      <p>\${message || 'Please find the attached report.'}</p>
      <hr>
      <p><strong>Report Details:</strong></p>
      <ul>
        <li><strong>Template:</strong> \${reportInstance.template.name}</li>
        <li><strong>Generated By:</strong> \${reportInstance.user.name}</li>
        <li><strong>Generated At:</strong> \${new Date(reportInstance.createdAt).toLocaleString()}</li>
      </ul>
      <p>This report was generated from the Event Manager system.</p>
    \`

    // Send email with report attachment
    await emailController.sendReportEmail({
      to: recipients,
      subject: subject || \`Report: \${reportInstance.name}\`,
      html: emailContent,
      attachments: reportInstance.fileUrl ? [{
        filename: \`\${reportInstance.name}.pdf\`,
        path: reportInstance.fileUrl
      }] : []
    })

    res.json({
      message: 'Report emailed successfully',
      recipients: recipients.length,
      reportName: reportInstance.name
    })

  } catch (error) {
    console.error('Email report error:', error)
    res.status(500).json({ error: 'Failed to email report' })
  }
}

module.exports = {
  getTemplates,
  createTemplate,
  updateTemplate,
  deleteTemplate,
  generateReport,
  getHistory,
  generateEventReport,
  generateContestResultsReport,
  generateJudgePerformanceReport,
  generateSystemAnalyticsReport,
  getAllReports,
  getReportById,
  deleteReport,
  exportReport,
  emailReport
}
EOF

    # Print Controller
    cat > "$APP_DIR/src/controllers/printController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')
const puppeteer = require('puppeteer')
const handlebars = require('handlebars')
const fs = require('fs').promises
const path = require('path')
const { generateSecurePassword, encryptMetadata, decryptMetadata } = require('../middleware/fileEncryption')

const prisma = new PrismaClient()

// Print templates directory
const TEMPLATES_DIR = path.join(__dirname, '../templates/print')

// Ensure templates directory exists
const ensureTemplatesDir = async () => {
  try {
    await fs.mkdir(TEMPLATES_DIR, { recursive: true })
  } catch (error) {
    console.error('Error creating templates directory:', error)
  }
}

// Get available print templates
const getPrintTemplates = async (req, res) => {
  try {
    await ensureTemplatesDir()
    
    const templates = await fs.readdir(TEMPLATES_DIR)
    const templateList = templates
      .filter(file => file.endsWith('.hbs'))
      .map(file => ({
        name: file.replace('.hbs', ''),
        filename: file,
        path: path.join(TEMPLATES_DIR, file)
      }))

    res.json({
      templates: templateList,
      message: 'Print templates retrieved successfully'
    })
  } catch (error) {
    console.error('Get print templates error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Create custom print template
const createPrintTemplate = async (req, res) => {
  try {
    const { name, content, description, type } = req.body

    if (!name || !content) {
      return res.status(400).json({ error: 'Template name and content are required' })
    }

    await ensureTemplatesDir()

    const templatePath = path.join(TEMPLATES_DIR, `${name}.hbs`)
    
    // Validate handlebars template
    try {
      handlebars.compile(content)
    } catch (error) {
      return res.status(400).json({ error: 'Invalid template syntax: ' + error.message })
    }

    await fs.writeFile(templatePath, content, 'utf8')

    // Save template metadata to database
    const template = await prisma.template.create({
      data: {
        name,
        description: description || '',
        type: type || 'PRINT',
        content,
        createdBy: req.user.id,
        isActive: true
      }
    })

    res.json({
      template,
      message: 'Print template created successfully'
    })
  } catch (error) {
    console.error('Create print template error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Update print template
const updatePrintTemplate = async (req, res) => {
  try {
    const { id } = req.params
    const { name, content, description, type } = req.body

    const template = await prisma.template.findUnique({
      where: { id }
    })

    if (!template) {
      return res.status(404).json({ error: 'Template not found' })
    }

    // Validate handlebars template if content is provided
    if (content) {
      try {
        handlebars.compile(content)
      } catch (error) {
        return res.status(400).json({ error: 'Invalid template syntax: ' + error.message })
      }
    }

    const updatedTemplate = await prisma.template.update({
      where: { id },
      data: {
        name: name || template.name,
        content: content || template.content,
        description: description || template.description,
        type: type || template.type,
        updatedAt: new Date()
      }
    })

    // Update file if content changed
    if (content) {
      const templatePath = path.join(TEMPLATES_DIR, `${updatedTemplate.name}.hbs`)
      await fs.writeFile(templatePath, content, 'utf8')
    }

    res.json({
      template: updatedTemplate,
      message: 'Print template updated successfully'
    })
  } catch (error) {
    console.error('Update print template error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Delete print template
const deletePrintTemplate = async (req, res) => {
  try {
    const { id } = req.params

    const template = await prisma.template.findUnique({
      where: { id }
    })

    if (!template) {
      return res.status(404).json({ error: 'Template not found' })
    }

    // Delete file
    const templatePath = path.join(TEMPLATES_DIR, `${template.name}.hbs`)
    try {
      await fs.unlink(templatePath)
    } catch (error) {
      console.warn('Template file not found:', templatePath)
    }

    // Delete from database
    await prisma.template.delete({
      where: { id }
    })

    res.json({ message: 'Print template deleted successfully' })
  } catch (error) {
    console.error('Delete print template error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Print event report
const printEventReport = async (req, res) => {
  try {
    const { eventId, templateName, format = 'pdf', options = {} } = req.body

    const event = await prisma.event.findUnique({
      where: { id: eventId },
      include: {
        contests: {
          include: {
            categories: {
              include: {
                scores: {
                  include: {
                    judge: {
                      select: {
                        id: true,
                        name: true,
                        preferredName: true,
                        email: true
                      }
                    },
                    contestant: {
                      select: {
                        id: true,
                        name: true,
                        preferredName: true,
                        email: true,
                        contestantNumber: true
                      }
                    },
                    criterion: {
                      select: {
                        id: true,
                        name: true,
                        description: true,
                        maxScore: true
                      }
                    }
                  }
                },
                contestants: {
                  include: {
                    user: {
                      select: {
                        id: true,
                        name: true,
                        preferredName: true,
                        email: true,
                        contestantNumber: true,
                        contestantAge: true,
                        contestantSchool: true
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    })

    if (!event) {
      return res.status(404).json({ error: 'Event not found' })
    }

    // Get template
    const templatePath = path.join(TEMPLATES_DIR, `${templateName || 'event-report'}.hbs`)
    let templateContent

    try {
      templateContent = await fs.readFile(templatePath, 'utf8')
    } catch (error) {
      // Use default template if custom template not found
      templateContent = await getDefaultEventTemplate()
    }

    // Compile template
    const template = handlebars.compile(templateContent)
    
    // Prepare data for template
    const templateData = {
      event,
      generatedAt: new Date().toISOString(),
      generatedBy: req.user.name,
      options
    }

    // Generate HTML
    const html = template(templateData)

    // Generate PDF using Puppeteer
    const browser = await puppeteer.launch({
      headless: true,
      args: ['--no-sandbox', '--disable-setuid-sandbox']
    })

    const page = await browser.newPage()
    await page.setContent(html, { waitUntil: 'networkidle0' })

    let output
    if (format === 'pdf') {
      output = await page.pdf({
        format: 'A4',
        printBackground: true,
        margin: {
          top: '1cm',
          right: '1cm',
          bottom: '1cm',
          left: '1cm'
        },
        ...options
      })
    } else {
      // For other formats, we'll return the HTML
      output = html
    }

    await browser.close()

    // Set appropriate headers
    if (format === 'pdf') {
      res.setHeader('Content-Type', 'application/pdf')
      res.setHeader('Content-Disposition', 'attachment; filename="event-report-' + event.name + '-' + Date.now() + '.pdf"')
    } else {
      res.setHeader('Content-Type', 'text/html')
    }

    res.send(output)
  } catch (error) {
    console.error('Print event report error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Print contest results
const printContestResults = async (req, res) => {
  try {
    const { contestId, templateName, format = 'pdf', options = {} } = req.body

    const contest = await prisma.contest.findUnique({
      where: { id: contestId },
      include: {
        event: {
          select: {
            id: true,
            name: true,
            startDate: true,
            endDate: true,
            location: true
          }
        },
        categories: {
          include: {
            scores: {
              include: {
                judge: {
                  select: {
                    id: true,
                    name: true,
                    preferredName: true,
                    email: true
                  }
                },
                contestant: {
                  select: {
                    id: true,
                    name: true,
                    preferredName: true,
                    email: true,
                    contestantNumber: true
                  }
                },
                criterion: {
                  select: {
                    id: true,
                    name: true,
                    description: true,
                    maxScore: true
                  }
                }
              }
            },
            contestants: {
              include: {
                user: {
                  select: {
                    id: true,
                    name: true,
                    preferredName: true,
                    email: true,
                    contestantNumber: true,
                    contestantAge: true,
                    contestantSchool: true
                  }
                }
              }
            }
          }
        }
      }
    })

    if (!contest) {
      return res.status(404).json({ error: 'Contest not found' })
    }

    // Get template
    const templatePath = path.join(TEMPLATES_DIR, `${templateName || 'contest-results'}.hbs`)
    let templateContent

    try {
      templateContent = await fs.readFile(templatePath, 'utf8')
    } catch (error) {
      // Use default template if custom template not found
      templateContent = await getDefaultContestTemplate()
    }

    // Compile template
    const template = handlebars.compile(templateContent)
    
    // Prepare data for template
    const templateData = {
      contest,
      generatedAt: new Date().toISOString(),
      generatedBy: req.user.name,
      options
    }

    // Generate HTML
    const html = template(templateData)

    // Generate PDF using Puppeteer
    const browser = await puppeteer.launch({
      headless: true,
      args: ['--no-sandbox', '--disable-setuid-sandbox']
    })

    const page = await browser.newPage()
    await page.setContent(html, { waitUntil: 'networkidle0' })

    let output
    if (format === 'pdf') {
      output = await page.pdf({
        format: 'A4',
        printBackground: true,
        margin: {
          top: '1cm',
          right: '1cm',
          bottom: '1cm',
          left: '1cm'
        },
        ...options
      })
    } else {
      // For other formats, we'll return the HTML
      output = html
    }

    await browser.close()

    // Set appropriate headers
    if (format === 'pdf') {
      res.setHeader('Content-Type', 'application/pdf')
      res.setHeader('Content-Disposition', 'attachment; filename="contest-results-' + contest.name + '-' + Date.now() + '.pdf"')
    } else {
      res.setHeader('Content-Type', 'text/html')
    }

    res.send(output)
  } catch (error) {
    console.error('Print contest results error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Print judge performance report
const printJudgePerformance = async (req, res) => {
  try {
    const { judgeId, eventId, templateName, format = 'pdf', options = {} } = req.body

    const judge = await prisma.user.findUnique({
      where: { id: judgeId },
      include: {
        scores: {
          where: eventId ? {
            category: {
              contest: {
                eventId: eventId
              }
            }
          } : {},
          include: {
            category: {
              include: {
                contest: {
                  include: {
                    event: {
                      select: {
                        id: true,
                        name: true,
                        startDate: true,
                        endDate: true,
                        location: true
                      }
                    }
                  }
                }
              }
            },
            contestant: {
              select: {
                id: true,
                name: true,
                preferredName: true,
                email: true,
                contestantNumber: true
              }
            },
            criterion: {
              select: {
                id: true,
                name: true,
                description: true,
                maxScore: true
              }
            }
          }
        }
      }
    })

    if (!judge) {
      return res.status(404).json({ error: 'Judge not found' })
    }

    // Get template
    const templatePath = path.join(TEMPLATES_DIR, `${templateName || 'judge-performance'}.hbs`)
    let templateContent

    try {
      templateContent = await fs.readFile(templatePath, 'utf8')
    } catch (error) {
      // Use default template if custom template not found
      templateContent = await getDefaultJudgeTemplate()
    }

    // Compile template
    const template = handlebars.compile(templateContent)
    
    // Calculate performance statistics
    const performanceStats = {
      totalScores: judge.scores.length,
      averageScore: judge.scores.length > 0 ? 
        judge.scores.reduce((sum, score) => sum + score.score, 0) / judge.scores.length : 0,
      scoreDistribution: calculateScoreDistribution(judge.scores),
      categoriesJudged: [...new Set(judge.scores.map(score => score.category.name))].length
    }

    // Prepare data for template
    const templateData = {
      judge,
      performanceStats,
      generatedAt: new Date().toISOString(),
      generatedBy: req.user.name,
      options
    }

    // Generate HTML
    const html = template(templateData)

    // Generate PDF using Puppeteer
    const browser = await puppeteer.launch({
      headless: true,
      args: ['--no-sandbox', '--disable-setuid-sandbox']
    })

    const page = await browser.newPage()
    await page.setContent(html, { waitUntil: 'networkidle0' })

    let output
    if (format === 'pdf') {
      output = await page.pdf({
        format: 'A4',
        printBackground: true,
        margin: {
          top: '1cm',
          right: '1cm',
          bottom: '1cm',
          left: '1cm'
        },
        ...options
      })
    } else {
      // For other formats, we'll return the HTML
      output = html
    }

    await browser.close()

    // Set appropriate headers
    if (format === 'pdf') {
      res.setHeader('Content-Type', 'application/pdf')
      res.setHeader('Content-Disposition', 'attachment; filename="judge-performance-' + judge.name + '-' + Date.now() + '.pdf"')
    } else {
      res.setHeader('Content-Type', 'text/html')
    }

    res.send(output)
  } catch (error) {
    console.error('Print judge performance error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Helper function to calculate score distribution
const calculateScoreDistribution = (scores) => {
  const distribution = {}
  scores.forEach(score => {
    const range = Math.floor(score.score / 10) * 10
    const key = `${range}-${range + 9}`
    distribution[key] = (distribution[key] || 0) + 1
  })
  return distribution
}

// Default templates
const getDefaultEventTemplate = async () => {
  return `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Event Report - {{event.name}}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { text-align: center; margin-bottom: 30px; }
        .event-info { margin-bottom: 20px; }
        .contest-section { margin-bottom: 30px; page-break-inside: avoid; }
        .contest-title { font-size: 18px; font-weight: bold; margin-bottom: 10px; }
        .category-section { margin-left: 20px; margin-bottom: 15px; }
        .category-title { font-size: 16px; font-weight: bold; margin-bottom: 5px; }
        .stats { background-color: #f5f5f5; padding: 10px; margin-bottom: 20px; }
        .footer { margin-top: 50px; text-align: center; font-size: 12px; color: #666; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Event Report</h1>
        <h2>{{event.name}}</h2>
    </div>
    
    <div class="event-info">
        <p><strong>Description:</strong> {{event.description}}</p>
        <p><strong>Date:</strong> {{event.startDate}} - {{event.endDate}}</p>
        <p><strong>Location:</strong> {{event.location}}</p>
        <p><strong>Status:</strong> {{event.status}}</p>
    </div>
    
    <div class="stats">
        <h3>Event Statistics</h3>
        <p>Total Contests: {{event.contests.length}}</p>
        <p>Total Categories: {{event.contests.length}}</p>
        <p>Total Contestants: {{event.contests.length}}</p>
    </div>
    
    {{#each event.contests}}
    <div class="contest-section">
        <div class="contest-title">{{name}}</div>
        <p>{{description}}</p>
        
        {{#each categories}}
        <div class="category-section">
            <div class="category-title">{{name}}</div>
            <p>{{description}}</p>
            <p>Max Score: {{maxScore}}</p>
            <p>Contestants: {{contestants.length}}</p>
        </div>
        {{/each}}
    </div>
    {{/each}}
    
    <div class="footer">
        <p>Generated on {{generatedAt}} by {{generatedBy}}</p>
    </div>
</body>
</html>
  `
}

const getDefaultContestTemplate = async () => {
  return `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Contest Results - {{contest.name}}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { text-align: center; margin-bottom: 30px; }
        .contest-info { margin-bottom: 20px; }
        .category-section { margin-bottom: 30px; page-break-inside: avoid; }
        .category-title { font-size: 18px; font-weight: bold; margin-bottom: 10px; }
        .results-table { width: 100%; border-collapse: collapse; margin-bottom: 20px; }
        .results-table th, .results-table td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        .results-table th { background-color: #f2f2f2; }
        .footer { margin-top: 50px; text-align: center; font-size: 12px; color: #666; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Contest Results</h1>
        <h2>{{contest.name}}</h2>
    </div>
    
    <div class="contest-info">
        <p><strong>Event:</strong> {{contest.event.name}}</p>
        <p><strong>Description:</strong> {{contest.description}}</p>
        <p><strong>Date:</strong> {{contest.event.startDate}} - {{contest.event.endDate}}</p>
        <p><strong>Location:</strong> {{contest.event.location}}</p>
    </div>
    
    {{#each contest.categories}}
    <div class="category-section">
        <div class="category-title">{{name}}</div>
        <p>{{description}}</p>
        <p>Max Score: {{maxScore}}</p>
        
        <table class="results-table">
            <thead>
                <tr>
                    <th>Rank</th>
                    <th>Contestant</th>
                    <th>Number</th>
                    <th>Total Score</th>
                    <th>Average Score</th>
                </tr>
            </thead>
            <tbody>
                {{#each contestants}}
                <tr>
                    <td>{{@index}}</td>
                    <td>{{user.preferredName}}</td>
                    <td>{{user.contestantNumber}}</td>
                    <td>{{totalScore}}</td>
                    <td>{{averageScore}}</td>
                </tr>
                {{/each}}
            </tbody>
        </table>
    </div>
    {{/each}}
    
    <div class="footer">
        <p>Generated on {{generatedAt}} by {{generatedBy}}</p>
    </div>
</body>
</html>
  `
}

const getDefaultJudgeTemplate = async () => {
  return `
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Judge Performance Report - {{judge.name}}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { text-align: center; margin-bottom: 30px; }
        .judge-info { margin-bottom: 20px; }
        .stats-section { margin-bottom: 30px; }
        .stats-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; }
        .stat-card { background-color: #f5f5f5; padding: 15px; border-radius: 5px; }
        .stat-value { font-size: 24px; font-weight: bold; color: #333; }
        .stat-label { font-size: 14px; color: #666; }
        .scores-table { width: 100%; border-collapse: collapse; margin-bottom: 20px; }
        .scores-table th, .scores-table td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        .scores-table th { background-color: #f2f2f2; }
        .footer { margin-top: 50px; text-align: center; font-size: 12px; color: #666; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Judge Performance Report</h1>
        <h2>{{judge.name}}</h2>
    </div>
    
    <div class="judge-info">
        <p><strong>Email:</strong> {{judge.email}}</p>
        <p><strong>Role:</strong> {{judge.role}}</p>
        <p><strong>Bio:</strong> {{judge.bio}}</p>
    </div>
    
    <div class="stats-section">
        <h3>Performance Statistics</h3>
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-value">{{performanceStats.totalScores}}</div>
                <div class="stat-label">Total Scores</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">{{performanceStats.averageScore}}</div>
                <div class="stat-label">Average Score</div>
            </div>
            <div class="stat-card">
                <div class="stat-value">{{performanceStats.categoriesJudged}}</div>
                <div class="stat-label">Categories Judged</div>
            </div>
        </div>
    </div>
    
    <div class="scores-section">
        <h3>Recent Scores</h3>
        <table class="scores-table">
            <thead>
                <tr>
                    <th>Contestant</th>
                    <th>Category</th>
                    <th>Criterion</th>
                    <th>Score</th>
                    <th>Max Score</th>
                    <th>Date</th>
                </tr>
            </thead>
            <tbody>
                {{#each judge.scores}}
                <tr>
                    <td>{{contestant.preferredName}}</td>
                    <td>{{category.name}}</td>
                    <td>{{criterion.name}}</td>
                    <td>{{score}}</td>
                    <td>{{criterion.maxScore}}</td>
                    <td>{{createdAt}}</td>
                </tr>
                {{/each}}
            </tbody>
        </table>
    </div>
    
    <div class="footer">
        <p>Generated on {{generatedAt}} by {{generatedBy}}</p>
    </div>
</body>
</html>
  `
}

module.exports = {
  getPrintTemplates,
  createPrintTemplate,
  updatePrintTemplate,
  deletePrintTemplate,
  printEventReport,
  printContestResults,
  printJudgePerformance
}
EOF

    # File Management Interface Controller
    cat > "$APP_DIR/src/controllers/fileManagementController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')
const fs = require('fs').promises
const path = require('path')
const { generateSecurePassword, encryptMetadata, decryptMetadata, verifyFileIntegrity, secureDeleteFile } = require('../middleware/fileEncryption')

const prisma = new PrismaClient()

// File Management Interface Functions

// Get files with advanced search and filtering
const getFilesWithFilters = async (req, res) => {
  try {
    const { 
      search = '', 
      category = '', 
      uploadedBy = '', 
      dateFrom = '', 
      dateTo = '', 
      sizeMin = '', 
      sizeMax = '', 
      mimeType = '', 
      isPublic = '', 
      sortBy = 'uploadedAt', 
      sortOrder = 'desc', 
      page = 1, 
      limit = 20 
    } = req.query

    // Build where clause
    const where = {}
    
    if (search) {
      where.OR = [
        { filename: { contains: search, mode: 'insensitive' } },
        { originalName: { contains: search, mode: 'insensitive' } },
        { metadata: { contains: search, mode: 'insensitive' } }
      ]
    }
    
    if (category) {
      where.category = category
    }
    
    if (uploadedBy) {
      where.uploadedBy = uploadedBy
    }
    
    if (dateFrom || dateTo) {
      where.uploadedAt = {}
      if (dateFrom) where.uploadedAt.gte = new Date(dateFrom)
      if (dateTo) where.uploadedAt.lte = new Date(dateTo)
    }
    
    if (sizeMin || sizeMax) {
      where.size = {}
      if (sizeMin) where.size.gte = parseInt(sizeMin)
      if (sizeMax) where.size.lte = parseInt(sizeMax)
    }
    
    if (mimeType) {
      where.mimeType = { contains: mimeType, mode: 'insensitive' }
    }
    
    if (isPublic !== '') {
      where.isPublic = isPublic === 'true'
    }

    // Build orderBy clause
    const orderBy = {}
    orderBy[sortBy] = sortOrder

    // Calculate pagination
    const skip = (parseInt(page) - 1) * parseInt(limit)

    // Get files with pagination
    const [files, totalCount] = await Promise.all([
      prisma.file.findMany({
        where,
        orderBy,
        skip,
        take: parseInt(limit),
        include: {
          user: {
            select: {
              id: true,
              name: true,
              preferredName: true,
              email: true,
              role: true
            }
          }
        }
      }),
      prisma.file.count({ where })
    ])

    // Get file statistics
    const stats = await prisma.file.aggregate({
      where,
      _count: { id: true },
      _sum: { size: true },
      _avg: { size: true }
    })

    // Get category distribution
    const categoryStats = await prisma.file.groupBy({
      by: ['category'],
      where,
      _count: { id: true },
      _sum: { size: true }
    })

    // Get uploader distribution
    const uploaderStats = await prisma.file.groupBy({
      by: ['uploadedBy'],
      where,
      _count: { id: true },
      _sum: { size: true }
    })

    res.json({
      files,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        totalCount,
        totalPages: Math.ceil(totalCount / parseInt(limit)),
        hasNext: skip + parseInt(limit) < totalCount,
        hasPrev: parseInt(page) > 1
      },
      stats: {
        totalFiles: stats._count.id,
        totalSize: stats._sum.size,
        averageSize: stats._avg.size,
        categoryDistribution: categoryStats,
        uploaderDistribution: uploaderStats
      }
    })
  } catch (error) {
    console.error('Get files with filters error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Bulk file operations
const bulkFileOperations = async (req, res) => {
  try {
    const { operation, fileIds, data } = req.body

    if (!operation || !fileIds || !Array.isArray(fileIds)) {
      return res.status(400).json({ error: 'Invalid operation parameters' })
    }

    let result = {}

    switch (operation) {
      case 'delete':
        result = await bulkDeleteFiles(fileIds)
        break
      case 'updateCategory':
        result = await bulkUpdateCategory(fileIds, data.category)
        break
      case 'updatePublicStatus':
        result = await bulkUpdatePublicStatus(fileIds, data.isPublic)
        break
      case 'download':
        result = await bulkDownloadFiles(fileIds)
        break
      case 'move':
        result = await bulkMoveFiles(fileIds, data.destination)
        break
      default:
        return res.status(400).json({ error: 'Invalid operation' })
    }

    res.json({
      operation,
      result,
      message: `Bulk ${operation} completed successfully`
    })
  } catch (error) {
    console.error('Bulk file operations error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// File search suggestions
const getFileSearchSuggestions = async (req, res) => {
  try {
    const { query = '', limit = 10 } = req.query

    if (!query || query.length < 2) {
      return res.json({ suggestions: [] })
    }

    const suggestions = await prisma.file.findMany({
      where: {
        OR: [
          { filename: { contains: query, mode: 'insensitive' } },
          { originalName: { contains: query, mode: 'insensitive' } }
        ]
      },
      select: {
        id: true,
        filename: true,
        originalName: true,
        category: true,
        mimeType: true
      },
      take: parseInt(limit),
      orderBy: { uploadedAt: 'desc' }
    })

    res.json({ suggestions })
  } catch (error) {
    console.error('Get file search suggestions error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// File analytics and insights
const getFileAnalytics = async (req, res) => {
  try {
    const { period = '30d' } = req.query

    // Calculate date range
    const now = new Date()
    const periodDays = period === '7d' ? 7 : period === '30d' ? 30 : period === '90d' ? 90 : 365
    const startDate = new Date(now.getTime() - (periodDays * 24 * 60 * 60 * 1000))

    // File upload trends
    const uploadTrends = await prisma.file.groupBy({
      by: ['uploadedAt'],
      where: {
        uploadedAt: { gte: startDate }
      },
      _count: { id: true },
      _sum: { size: true },
      orderBy: { uploadedAt: 'asc' }
    })

    // Category distribution
    const categoryDistribution = await prisma.file.groupBy({
      by: ['category'],
      where: {
        uploadedAt: { gte: startDate }
      },
      _count: { id: true },
      _sum: { size: true }
    })

    // Top uploaders
    const topUploaders = await prisma.file.groupBy({
      by: ['uploadedBy'],
      where: {
        uploadedAt: { gte: startDate }
      },
      _count: { id: true },
      _sum: { size: true },
      orderBy: { _count: { id: 'desc' } },
      take: 10
    })

    // File type distribution
    const fileTypeDistribution = await prisma.file.groupBy({
      by: ['mimeType'],
      where: {
        uploadedAt: { gte: startDate }
      },
      _count: { id: true },
      _sum: { size: true },
      orderBy: { _count: { id: 'desc' } },
      take: 10
    })

    // Storage usage over time
    const storageUsage = await prisma.file.aggregate({
      where: {
        uploadedAt: { gte: startDate }
      },
      _sum: { size: true },
      _count: { id: true }
    })

    res.json({
      period,
      uploadTrends,
      categoryDistribution,
      topUploaders,
      fileTypeDistribution,
      storageUsage,
      generatedAt: new Date().toISOString()
    })
  } catch (error) {
    console.error('Get file analytics error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// File integrity check
const checkFileIntegrity = async (req, res) => {
  try {
    const { fileId } = req.params

    const file = await prisma.file.findUnique({
      where: { id: fileId }
    })

    if (!file) {
      return res.status(404).json({ error: 'File not found' })
    }

    // Check if file exists on disk
    const fileExists = await fs.access(file.path).then(() => true).catch(() => false)
    
    if (!fileExists) {
      return res.json({
        fileId,
        integrity: 'MISSING',
        message: 'File not found on disk',
        checksum: file.checksum,
        fileSize: file.size
      })
    }

    // Verify file integrity if checksum exists
    let integrityCheck = null
    if (file.checksum) {
      const isValid = await verifyFileIntegrity(file.path, file.checksum)
      integrityCheck = {
        checksum: file.checksum,
        isValid,
        status: isValid ? 'VALID' : 'INVALID'
      }
    }

    // Get actual file size
    const stats = await fs.stat(file.path)
    const actualSize = stats.size

    res.json({
      fileId,
      integrity: integrityCheck ? integrityCheck.status : 'UNKNOWN',
      fileExists: true,
      expectedSize: file.size,
      actualSize,
      sizeMatch: file.size === actualSize,
      checksum: integrityCheck,
      lastModified: stats.mtime,
      message: 'File integrity check completed'
    })
  } catch (error) {
    console.error('Check file integrity error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Bulk file integrity check
const bulkCheckFileIntegrity = async (req, res) => {
  try {
    const { fileIds } = req.body

    if (!fileIds || !Array.isArray(fileIds)) {
      return res.status(400).json({ error: 'Invalid file IDs' })
    }

    const results = []
    
    for (const fileId of fileIds) {
      try {
        const file = await prisma.file.findUnique({
          where: { id: fileId }
        })

        if (!file) {
          results.push({ fileId, status: 'NOT_FOUND', error: 'File not found in database' })
          continue
        }

        const fileExists = await fs.access(file.path).then(() => true).catch(() => false)
        
        if (!fileExists) {
          results.push({ fileId, status: 'MISSING', error: 'File not found on disk' })
          continue
        }

        let integrityCheck = null
        if (file.checksum) {
          const isValid = await verifyFileIntegrity(file.path, file.checksum)
          integrityCheck = {
            checksum: file.checksum,
            isValid,
            status: isValid ? 'VALID' : 'INVALID'
          }
        }

        const stats = await fs.stat(file.path)
        const actualSize = stats.size

        results.push({
          fileId,
          status: 'OK',
          integrity: integrityCheck ? integrityCheck.status : 'UNKNOWN',
          expectedSize: file.size,
          actualSize,
          sizeMatch: file.size === actualSize,
          checksum: integrityCheck
        })
      } catch (error) {
        results.push({ fileId, status: 'ERROR', error: error.message })
      }
    }

    res.json({
      results,
      totalChecked: fileIds.length,
      completedAt: new Date().toISOString()
    })
  } catch (error) {
    console.error('Bulk check file integrity error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Helper functions for bulk operations
const bulkDeleteFiles = async (fileIds) => {
  const results = []
  
  for (const fileId of fileIds) {
    try {
      const file = await prisma.file.findUnique({
        where: { id: fileId }
      })

      if (!file) {
        results.push({ fileId, status: 'NOT_FOUND' })
        continue
      }

      // Securely delete file from disk
      await secureDeleteFile(file.path)

      // Remove from database
      await prisma.file.delete({
        where: { id: fileId }
      })

      results.push({ fileId, status: 'DELETED' })
    } catch (error) {
      results.push({ fileId, status: 'ERROR', error: error.message })
    }
  }

  return results
}

const bulkUpdateCategory = async (fileIds, category) => {
  const results = []
  
  for (const fileId of fileIds) {
    try {
      await prisma.file.update({
        where: { id: fileId },
        data: { category }
      })
      results.push({ fileId, status: 'UPDATED' })
    } catch (error) {
      results.push({ fileId, status: 'ERROR', error: error.message })
    }
  }

  return results
}

const bulkUpdatePublicStatus = async (fileIds, isPublic) => {
  const results = []
  
  for (const fileId of fileIds) {
    try {
      await prisma.file.update({
        where: { id: fileId },
        data: { isPublic }
      })
      results.push({ fileId, status: 'UPDATED' })
    } catch (error) {
      results.push({ fileId, status: 'ERROR', error: error.message })
    }
  }

  return results
}

const bulkDownloadFiles = async (fileIds) => {
  const results = []
  
  for (const fileId of fileIds) {
    try {
      const file = await prisma.file.findUnique({
        where: { id: fileId }
      })

      if (!file) {
        results.push({ fileId, status: 'NOT_FOUND' })
        continue
      }

      const fileExists = await fs.access(file.path).then(() => true).catch(() => false)
      
      if (!fileExists) {
        results.push({ fileId, status: 'MISSING' })
        continue
      }

      results.push({ 
        fileId, 
        status: 'READY', 
        filename: file.filename,
        size: file.size,
        mimeType: file.mimeType
      })
    } catch (error) {
      results.push({ fileId, status: 'ERROR', error: error.message })
    }
  }

  return results
}

const bulkMoveFiles = async (fileIds, destination) => {
  const results = []
  
  for (const fileId of fileIds) {
    try {
      const file = await prisma.file.findUnique({
        where: { id: fileId }
      })

      if (!file) {
        results.push({ fileId, status: 'NOT_FOUND' })
        continue
      }

      const fileExists = await fs.access(file.path).then(() => true).catch(() => false)
      
      if (!fileExists) {
        results.push({ fileId, status: 'MISSING' })
        continue
      }

      // Create destination directory if it doesn't exist
      await fs.mkdir(destination, { recursive: true })

      // Move file
      const newPath = path.join(destination, file.filename)
      await fs.rename(file.path, newPath)

      // Update database
      await prisma.file.update({
        where: { id: fileId },
        data: { path: newPath }
      })

      results.push({ fileId, status: 'MOVED', newPath })
    } catch (error) {
      results.push({ fileId, status: 'ERROR', error: error.message })
    }
  }

  return results
}

module.exports = {
  getFilesWithFilters,
  bulkFileOperations,
  getFileSearchSuggestions,
  getFileAnalytics,
  checkFileIntegrity,
  bulkCheckFileIntegrity
}
EOF

    # Export Controller
    cat > "$APP_DIR/src/controllers/exportController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')
const XLSX = require('xlsx')
const csvWriter = require('csv-writer')
const xml2js = require('xml2js')
const PDFDocument = require('pdfkit')
const fs = require('fs').promises
const path = require('path')
const { generateSecurePassword, encryptMetadata, decryptMetadata } = require('../middleware/fileEncryption')

const prisma = new PrismaClient()

// Export directory
const EXPORT_DIR = path.join(__dirname, '../exports')

// Ensure export directory exists
const ensureExportDir = async () => {
  try {
    await fs.mkdir(EXPORT_DIR, { recursive: true })
  } catch (error) {
    console.error('Error creating export directory:', error)
  }
}

// Export event data to Excel
const exportEventToExcel = async (req, res) => {
  try {
    const { eventId, includeDetails = false } = req.body

    const event = await prisma.event.findUnique({
      where: { id: eventId },
      include: {
        contests: {
          include: {
            categories: {
              include: {
                scores: {
                  include: {
                    judge: {
                      select: {
                        id: true,
                        name: true,
                        preferredName: true,
                        email: true
                      }
                    },
                    contestant: {
                      select: {
                        id: true,
                        name: true,
                        preferredName: true,
                        email: true,
                        contestantNumber: true
                      }
                    },
                    criterion: {
                      select: {
                        id: true,
                        name: true,
                        description: true,
                        maxScore: true
                      }
                    }
                  }
                },
                contestants: {
                  include: {
                    user: {
                      select: {
                        id: true,
                        name: true,
                        preferredName: true,
                        email: true,
                        contestantNumber: true,
                        contestantAge: true,
                        contestantSchool: true
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    })

    if (!event) {
      return res.status(404).json({ error: 'Event not found' })
    }

    await ensureExportDir()

    // Create workbook
    const workbook = XLSX.utils.book_new()

    // Event summary sheet
    const eventSummary = [
      ['Event Name', event.name],
      ['Description', event.description],
      ['Start Date', event.startDate],
      ['End Date', event.endDate],
      ['Location', event.location],
      ['Status', event.status],
      ['Max Contestants', event.maxContestants],
      ['Total Contests', event.contests.length],
      ['Total Categories', event.contests.reduce((sum, contest) => sum + contest.categories.length, 0)],
      ['Total Contestants', event.contests.reduce((sum, contest) => 
        sum + contest.categories.reduce((catSum, category) => catSum + category.contestants.length, 0), 0)],
      ['Total Scores', event.contests.reduce((sum, contest) => 
        sum + contest.categories.reduce((catSum, category) => catSum + category.scores.length, 0), 0)]
    ]

    const eventSummarySheet = XLSX.utils.aoa_to_sheet(eventSummary)
    XLSX.utils.book_append_sheet(workbook, eventSummarySheet, 'Event Summary')

    // Contests sheet
    const contestsData = event.contests.map(contest => ({
      'Contest Name': contest.name,
      'Description': contest.description,
      'Categories': contest.categories.length,
      'Total Contestants': contest.categories.reduce((sum, category) => sum + category.contestants.length, 0),
      'Total Scores': contest.categories.reduce((sum, category) => sum + category.scores.length, 0)
    }))

    const contestsSheet = XLSX.utils.json_to_sheet(contestsData)
    XLSX.utils.book_append_sheet(workbook, contestsSheet, 'Contests')

    if (includeDetails) {
      // Detailed scores sheet
      const scoresData = []
      event.contests.forEach(contest => {
        contest.categories.forEach(category => {
          category.scores.forEach(score => {
            scoresData.push({
              'Event': event.name,
              'Contest': contest.name,
              'Category': category.name,
              'Contestant': score.contestant.preferredName || score.contestant.name,
              'Contestant Number': score.contestant.contestantNumber,
              'Judge': score.judge.preferredName || score.judge.name,
              'Criterion': score.criterion.name,
              'Score': score.score,
              'Max Score': score.criterion.maxScore,
              'Score Date': score.createdAt
            })
          })
        })
      })

      const scoresSheet = XLSX.utils.json_to_sheet(scoresData)
      XLSX.utils.book_append_sheet(workbook, scoresSheet, 'Detailed Scores')
    }

    // Generate filename
    const filename = `event-export-${event.name.replace(/[^a-zA-Z0-9]/g, '-')}-${Date.now()}.xlsx`
    const filepath = path.join(EXPORT_DIR, filename)

    // Write file
    XLSX.writeFile(workbook, filepath)

    // Set headers for download
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    res.setHeader('Content-Disposition', 'attachment; filename="' + filename + '"')

    // Send file
    const fileBuffer = await fs.readFile(filepath)
    res.send(fileBuffer)

    // Clean up file
    await fs.unlink(filepath)
  } catch (error) {
    console.error('Export event to Excel error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Export contest results to CSV
const exportContestResultsToCSV = async (req, res) => {
  try {
    const { contestId, categoryId } = req.body

    const contest = await prisma.contest.findUnique({
      where: { id: contestId },
      include: {
        event: {
          select: {
            id: true,
            name: true,
            startDate: true,
            endDate: true,
            location: true
          }
        },
        categories: {
          where: categoryId ? { id: categoryId } : {},
          include: {
            scores: {
              include: {
                judge: {
                  select: {
                    id: true,
                    name: true,
                    preferredName: true,
                    email: true
                  }
                },
                contestant: {
                  select: {
                    id: true,
                    name: true,
                    preferredName: true,
                    email: true,
                    contestantNumber: true
                  }
                },
                criterion: {
                  select: {
                    id: true,
                    name: true,
                    description: true,
                    maxScore: true
                  }
                }
              }
            },
            contestants: {
              include: {
                user: {
                  select: {
                    id: true,
                    name: true,
                    preferredName: true,
                    email: true,
                    contestantNumber: true,
                    contestantAge: true,
                    contestantSchool: true
                  }
                }
              }
            }
          }
        }
      }
    })

    if (!contest) {
      return res.status(404).json({ error: 'Contest not found' })
    }

    await ensureExportDir()

    // Prepare CSV data
    const csvData = []
    
    contest.categories.forEach(category => {
      // Calculate contestant totals
      const contestantTotals = {}
      category.scores.forEach(score => {
        const key = score.contestantId
        if (!contestantTotals[key]) {
          contestantTotals[key] = {
            contestant: score.contestant,
            totalScore: 0,
            scoreCount: 0,
            scores: []
          }
        }
        contestantTotals[key].totalScore += score.score
        contestantTotals[key].scoreCount += 1
        contestantTotals[key].scores.push(score)
      })

      // Add contestant results
      Object.values(contestantTotals).forEach(group => {
        csvData.push({
          'Event': contest.event.name,
          'Contest': contest.name,
          'Category': category.name,
          'Contestant': group.contestant.preferredName || group.contestant.name,
          'Contestant Number': group.contestant.contestantNumber,
          'Total Score': group.totalScore,
          'Average Score': group.totalScore / group.scoreCount,
          'Score Count': group.scoreCount,
          'Rank': 0 // Will be calculated after sorting
        })
      })
    })

    // Sort by total score and assign ranks
    csvData.sort((a, b) => b['Total Score'] - a['Total Score'])
    csvData.forEach((row, index) => {
      row['Rank'] = index + 1
    })

    // Generate filename
    const filename = `contest-results-${contest.name.replace(/[^a-zA-Z0-9]/g, '-')}-${Date.now()}.csv`
    const filepath = path.join(EXPORT_DIR, filename)

    // Create CSV writer
    const writer = csvWriter.createObjectCsvWriter({
      path: filepath,
      header: [
        { id: 'Event', title: 'Event' },
        { id: 'Contest', title: 'Contest' },
        { id: 'Category', title: 'Category' },
        { id: 'Contestant', title: 'Contestant' },
        { id: 'Contestant Number', title: 'Contestant Number' },
        { id: 'Total Score', title: 'Total Score' },
        { id: 'Average Score', title: 'Average Score' },
        { id: 'Score Count', title: 'Score Count' },
        { id: 'Rank', title: 'Rank' }
      ]
    })

    // Write CSV file
    await writer.writeRecords(csvData)

    // Set headers for download
    res.setHeader('Content-Type', 'text/csv')
    res.setHeader('Content-Disposition', 'attachment; filename="' + filename + '"')

    // Send file
    const fileBuffer = await fs.readFile(filepath)
    res.send(fileBuffer)

    // Clean up file
    await fs.unlink(filepath)
  } catch (error) {
    console.error('Export contest results to CSV error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Export judge performance to XML
const exportJudgePerformanceToXML = async (req, res) => {
  try {
    const { judgeId, eventId } = req.body

    const judge = await prisma.user.findUnique({
      where: { id: judgeId },
      include: {
        scores: {
          where: eventId ? {
            category: {
              contest: {
                eventId: eventId
              }
            }
          } : {},
          include: {
            category: {
              include: {
                contest: {
                  include: {
                    event: {
                      select: {
                        id: true,
                        name: true,
                        startDate: true,
                        endDate: true,
                        location: true
                      }
                    }
                  }
                }
              }
            },
            contestant: {
              select: {
                id: true,
                name: true,
                preferredName: true,
                email: true,
                contestantNumber: true
              }
            },
            criterion: {
              select: {
                id: true,
                name: true,
                description: true,
                maxScore: true
              }
            }
          }
        }
      }
    })

    if (!judge) {
      return res.status(404).json({ error: 'Judge not found' })
    }

    await ensureExportDir()

    // Calculate performance statistics
    const performanceStats = {
      totalScores: judge.scores.length,
      averageScore: judge.scores.length > 0 ? 
        judge.scores.reduce((sum, score) => sum + score.score, 0) / judge.scores.length : 0,
      categoriesJudged: [...new Set(judge.scores.map(score => score.category.name))].length
    }

    // Prepare XML data
    const xmlData = {
      judgePerformance: {
        judge: {
          id: judge.id,
          name: judge.name,
          preferredName: judge.preferredName,
          email: judge.email,
          role: judge.role,
          bio: judge.bio
        },
        performance: {
          totalScores: performanceStats.totalScores,
          averageScore: performanceStats.averageScore,
          categoriesJudged: performanceStats.categoriesJudged
        },
        scores: judge.scores.map(score => ({
          score: {
            id: score.id,
            score: score.score,
            createdAt: score.createdAt,
            contestant: {
              id: score.contestant.id,
              name: score.contestant.name,
              preferredName: score.contestant.preferredName,
              contestantNumber: score.contestant.contestantNumber
            },
            category: {
              id: score.category.id,
              name: score.category.name,
              description: score.category.description
            },
            contest: {
              id: score.category.contest.id,
              name: score.category.contest.name,
              description: score.category.contest.description
            },
            event: {
              id: score.category.contest.event.id,
              name: score.category.contest.event.name,
              startDate: score.category.contest.event.startDate,
              endDate: score.category.contest.event.endDate,
              location: score.category.contest.event.location
            },
            criterion: {
              id: score.criterion.id,
              name: score.criterion.name,
              description: score.criterion.description,
              maxScore: score.criterion.maxScore
            }
          }
        }))
      }
    }

    // Generate XML
    const builder = new xml2js.Builder({ rootName: 'judgePerformance', xmldec: { version: '1.0', encoding: 'UTF-8' } })
    const xml = builder.buildObject(xmlData)

    // Generate filename
    const filename = `judge-performance-${judge.name.replace(/[^a-zA-Z0-9]/g, '-')}-${Date.now()}.xml`
    const filepath = path.join(EXPORT_DIR, filename)

    // Write file
    await fs.writeFile(filepath, xml, 'utf8')

    // Set headers for download
    res.setHeader('Content-Type', 'application/xml')
    res.setHeader('Content-Disposition', 'attachment; filename="' + filename + '"')

    // Send file
    const fileBuffer = await fs.readFile(filepath)
    res.send(fileBuffer)

    // Clean up file
    await fs.unlink(filepath)
  } catch (error) {
    console.error('Export judge performance to XML error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Export system analytics to PDF
const exportSystemAnalyticsToPDF = async (req, res) => {
  try {
    const { startDate, endDate } = req.body

    // Get system analytics data
    const analytics = await prisma.$queryRaw`
      SELECT 
        COUNT(DISTINCT e.id) as total_events,
        COUNT(DISTINCT c.id) as total_contests,
        COUNT(DISTINCT cat.id) as total_categories,
        COUNT(DISTINCT u.id) as total_users,
        COUNT(DISTINCT s.id) as total_scores,
        AVG(s.score) as average_score,
        COUNT(DISTINCT CASE WHEN u.role = 'JUDGE' THEN u.id END) as total_judges,
        COUNT(DISTINCT CASE WHEN u.role = 'CONTESTANT' THEN u.id END) as total_contestants
      FROM "Event" e
      LEFT JOIN "Contest" c ON c."eventId" = e.id
      LEFT JOIN "Category" cat ON cat."contestId" = c.id
      LEFT JOIN "User" u ON u.id IS NOT NULL
      LEFT JOIN "Score" s ON s."categoryId" = cat.id
      WHERE e."createdAt" >= ${startDate || '2020-01-01'}::timestamp
      AND e."createdAt" <= ${endDate || new Date().toISOString()}::timestamp
    `

    const stats = analytics[0] || {}

    await ensureExportDir()

    // Create PDF document
    const doc = new PDFDocument()
    
    // Generate filename
    const filename = `system-analytics-${Date.now()}.pdf`
    const filepath = path.join(EXPORT_DIR, filename)

    // Pipe PDF to file
    doc.pipe(require('fs').createWriteStream(filepath))

    // Add content
    doc.fontSize(20).text('System Analytics Report', 50, 50)
    doc.fontSize(12).text(`Generated on: ${new Date().toISOString()}`, 50, 80)
    
    doc.fontSize(16).text('Overview Statistics', 50, 120)
    doc.fontSize(12)
      .text(`Total Events: ${stats.total_events || 0}`, 50, 150)
      .text(`Total Contests: ${stats.total_contests || 0}`, 50, 170)
      .text(`Total Categories: ${stats.total_categories || 0}`, 50, 190)
      .text(`Total Users: ${stats.total_users || 0}`, 50, 210)
      .text(`Total Judges: ${stats.total_judges || 0}`, 50, 230)
      .text(`Total Contestants: ${stats.total_contestants || 0}`, 50, 250)
      .text(`Total Scores: ${stats.total_scores || 0}`, 50, 270)
      .text(`Average Score: ${(stats.average_score || 0).toFixed(2)}`, 50, 290)

    // Add charts section
    doc.fontSize(16).text('Performance Metrics', 50, 330)
    doc.fontSize(12).text('Score distribution and performance metrics would be visualized here.', 50, 360)

    // Finalize PDF
    doc.end()

    // Wait for PDF to be written
    await new Promise((resolve) => {
      doc.on('end', resolve)
    })

    // Set headers for download
    res.setHeader('Content-Type', 'application/pdf')
    res.setHeader('Content-Disposition', 'attachment; filename="' + filename + '"')

    // Send file
    const fileBuffer = await fs.readFile(filepath)
    res.send(fileBuffer)

    // Clean up file
    await fs.unlink(filepath)
  } catch (error) {
    console.error('Export system analytics to PDF error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get export history
const getExportHistory = async (req, res) => {
  try {
    const exports = await prisma.report.findMany({
      where: {
        generatedBy: req.user.id,
        type: {
          in: ['EXCEL_EXPORT', 'CSV_EXPORT', 'XML_EXPORT', 'PDF_EXPORT']
        }
      },
      orderBy: { createdAt: 'desc' },
      take: 50
    })

    res.json({
      exports,
      message: 'Export history retrieved successfully'
    })
  } catch (error) {
    console.error('Get export history error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  exportEventToExcel,
  exportContestResultsToCSV,
  exportJudgePerformanceToXML,
  exportSystemAnalyticsToPDF,
  getExportHistory
}
EOF

    # Templates Controller
    cat > "$APP_DIR/src/controllers/templatesController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

const getAllTemplates = async (req, res) => {
  try {
    const templates = await prisma.template.findMany({
      orderBy: { createdAt: 'desc' }
    })

    res.json(templates)
  } catch (error) {
    console.error('Get all templates error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getTemplateById = async (req, res) => {
  try {
    const { id } = req.params

    const template = await prisma.template.findUnique({
      where: { id }
    })

    if (!template) {
      return res.status(404).json({ error: 'Template not found' })
    }

    res.json(template)
  } catch (error) {
    console.error('Get template error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const createTemplate = async (req, res) => {
  try {
    const { name, description, content, type } = req.body

    const template = await prisma.template.create({
      data: {
        name,
        description,
        content,
        type,
        createdBy: req.user.id
      }
    })

    res.status(201).json(template)
  } catch (error) {
    console.error('Create template error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const updateTemplate = async (req, res) => {
  try {
    const { id } = req.params
    const { name, description, content, type } = req.body

    const template = await prisma.template.update({
      where: { id },
      data: {
        name,
        description,
        content,
        type
      }
    })

    res.json(template)
  } catch (error) {
    console.error('Update template error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const deleteTemplate = async (req, res) => {
  try {
    const { id } = req.params

    await prisma.template.delete({
      where: { id }
    })

    res.status(204).send()
  } catch (error) {
    console.error('Delete template error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const duplicateTemplate = async (req, res) => {
  try {
    const { id } = req.params

    const originalTemplate = await prisma.template.findUnique({
      where: { id }
    })

    if (!originalTemplate) {
      return res.status(404).json({ error: 'Template not found' })
    }

    const duplicatedTemplate = await prisma.template.create({
      data: {
        name: `${originalTemplate.name} (Copy)`,
        description: originalTemplate.description,
        content: originalTemplate.content,
        type: originalTemplate.type,
        createdBy: req.user.id
      }
    })

    res.status(201).json(duplicatedTemplate)
  } catch (error) {
    console.error('Duplicate template error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  getAllTemplates,
  getTemplateById,
  createTemplate,
  updateTemplate,
  deleteTemplate,
  duplicateTemplate
}
EOF

    # Event Template Controller
    cat > "$APP_DIR/src/controllers/eventTemplateController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

const createTemplate = async (req, res) => {
  try {
    const { name, description, contests, categories } = req.body

    if (!name || !contests || !categories) {
      return res.status(400).json({ error: 'Name, contests, and categories are required' })
    }

    const template = await prisma.eventTemplate.create({
      data: {
        name,
        description: description || null,
        contests: JSON.stringify(contests),
        categories: JSON.stringify(categories),
        createdBy: req.user.id
      }
    })

    res.status(201).json({
      id: template.id,
      name: template.name,
      description: template.description,
      contests: JSON.parse(template.contests),
      categories: JSON.parse(template.categories),
      createdAt: template.createdAt
    })
  } catch (error) {
    console.error('Create template error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getTemplates = async (req, res) => {
  try {
    const templates = await prisma.eventTemplate.findMany({
      include: {
        creator: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    })

    const formattedTemplates = templates.map(template => ({
      id: template.id,
      name: template.name,
      description: template.description,
      contests: JSON.parse(template.contests),
      categories: JSON.parse(template.categories),
      creator: template.creator,
      createdAt: template.createdAt,
      updatedAt: template.updatedAt
    }))

    res.json(formattedTemplates)
  } catch (error) {
    console.error('Get templates error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getTemplate = async (req, res) => {
  try {
    const { id } = req.params

    const template = await prisma.eventTemplate.findUnique({
      where: { id },
      include: {
        creator: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    })

    if (!template) {
      return res.status(404).json({ error: 'Template not found' })
    }

    res.json({
      id: template.id,
      name: template.name,
      description: template.description,
      contests: JSON.parse(template.contests),
      categories: JSON.parse(template.categories),
      creator: template.creator,
      createdAt: template.createdAt,
      updatedAt: template.updatedAt
    })
  } catch (error) {
    console.error('Get template error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const updateTemplate = async (req, res) => {
  try {
    const { id } = req.params
    const { name, description, contests, categories } = req.body

    if (!name || !contests || !categories) {
      return res.status(400).json({ error: 'Name, contests, and categories are required' })
    }

    const template = await prisma.eventTemplate.update({
      where: { id },
      data: {
        name,
        description: description || null,
        contests: JSON.stringify(contests),
        categories: JSON.stringify(categories)
      }
    })

    res.json({
      id: template.id,
      name: template.name,
      description: template.description,
      contests: JSON.parse(template.contests),
      categories: JSON.parse(template.categories),
      updatedAt: template.updatedAt
    })
  } catch (error) {
    console.error('Update template error:', error)
    if (error.code === 'P2025') {
      res.status(404).json({ error: 'Template not found' })
    } else {
      res.status(500).json({ error: 'Internal server error' })
    }
  }
}

const deleteTemplate = async (req, res) => {
  try {
    const { id } = req.params

    await prisma.eventTemplate.delete({
      where: { id }
    })

    res.json({ message: 'Template deleted successfully' })
  } catch (error) {
    console.error('Delete template error:', error)
    if (error.code === 'P2025') {
      res.status(404).json({ error: 'Template not found' })
    } else {
      res.status(500).json({ error: 'Internal server error' })
    }
  }
}

const createEventFromTemplate = async (req, res) => {
  try {
    const { templateId, eventName, eventDescription, startDate, endDate } = req.body

    if (!templateId || !eventName || !startDate || !endDate) {
      return res.status(400).json({ error: 'Template ID, event name, start date, and end date are required' })
    }

    const template = await prisma.eventTemplate.findUnique({
      where: { id: templateId }
    })

    if (!template) {
      return res.status(404).json({ error: 'Template not found' })
    }

    const contests = JSON.parse(template.contests)
    const categories = JSON.parse(template.categories)

    // Create the event
    const event = await prisma.event.create({
      data: {
        name: eventName,
        description: eventDescription || null,
        startDate: new Date(startDate),
        endDate: new Date(endDate)
      }
    })

    // Create contests from template
    for (const contestTemplate of contests) {
      const contest = await prisma.contest.create({
        data: {
          eventId: event.id,
          name: contestTemplate.name,
          description: contestTemplate.description || null
        }
      })

      // Create categories for this contest
      const contestCategories = categories.filter(cat => cat.contestId === contestTemplate.id)
      for (const categoryTemplate of contestCategories) {
        await prisma.category.create({
          data: {
            contestId: contest.id,
            name: categoryTemplate.name,
            description: categoryTemplate.description || null,
            scoreCap: categoryTemplate.scoreCap || null,
            timeLimit: categoryTemplate.timeLimit || null,
            contestantMin: categoryTemplate.contestantMin || null,
            contestantMax: categoryTemplate.contestantMax || null
          }
        })
      }
    }

    res.status(201).json({
      id: event.id,
      name: event.name,
      description: event.description,
      startDate: event.startDate,
      endDate: event.endDate,
      createdAt: event.createdAt
    })
  } catch (error) {
    console.error('Create event from template error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  createTemplate,
  getTemplates,
  getTemplate,
  updateTemplate,
  deleteTemplate,
  createEventFromTemplate
}
EOF

    # Notifications Controller
    cat > "$APP_DIR/src/controllers/notificationsController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

const getAllNotifications = async (req, res) => {
  try {
    const notifications = await prisma.notification.findMany({
      where: { userId: req.user.id },
      orderBy: { createdAt: 'desc' }
    })

    res.json(notifications)
  } catch (error) {
    console.error('Get notifications error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getNotificationById = async (req, res) => {
  try {
    const { id } = req.params

    const notification = await prisma.notification.findUnique({
      where: { id }
    })

    if (!notification) {
      return res.status(404).json({ error: 'Notification not found' })
    }

    res.json(notification)
  } catch (error) {
    console.error('Get notification error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const createNotification = async (req, res) => {
  try {
    const { title, message, type, userId } = req.body

    const notification = await prisma.notification.create({
      data: {
        title,
        message,
        type,
        userId: userId || req.user.id,
        createdBy: req.user.id
      }
    })

    res.status(201).json(notification)
  } catch (error) {
    console.error('Create notification error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const updateNotification = async (req, res) => {
  try {
    const { id } = req.params
    const { title, message, type } = req.body

    const notification = await prisma.notification.update({
      where: { id },
      data: {
        title,
        message,
        type
      }
    })

    res.json(notification)
  } catch (error) {
    console.error('Update notification error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const deleteNotification = async (req, res) => {
  try {
    const { id } = req.params

    await prisma.notification.delete({
      where: { id }
    })

    res.status(204).send()
  } catch (error) {
    console.error('Delete notification error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const markAsRead = async (req, res) => {
  try {
    const { id } = req.params

    await prisma.notification.update({
      where: { id },
      data: { read: true }
    })

    res.json({ message: 'Notification marked as read' })
  } catch (error) {
    console.error('Mark notification as read error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const markAllAsRead = async (req, res) => {
  try {
    await prisma.notification.updateMany({
      where: { userId: req.user.id },
      data: { read: true }
    })

    res.json({ message: 'All notifications marked as read' })
  } catch (error) {
    console.error('Mark all notifications as read error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  getAllNotifications,
  getNotificationById,
  createNotification,
  updateNotification,
  deleteNotification,
  markAsRead,
  markAllAsRead
}
EOF

    # File Controller
    cat > "$APP_DIR/src/controllers/fileController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')
const multer = require('multer')
const path = require('path')
const crypto = require('crypto')
const fs = require('fs').promises
const sharp = require('sharp')
const { exec } = require('child_process')
const { promisify } = require('util')

const execAsync = promisify(exec)
const prisma = new PrismaClient()

const uploadFiles = async (req, res) => {
  try {
    if (!req.files || req.files.length === 0) {
      return res.status(400).json({ error: 'No files uploaded' })
    }

    const uploadedFiles = []
    
    for (const file of req.files) {
      // Check if file already exists
      const existingFile = await prisma.file.findFirst({
        where: { filename: file.filename }
      })
      
      if (existingFile) {
        uploadedFiles.push({
          filename: file.filename,
          status: 'error',
          errors: ['File already exists']
        })
        continue
      }
      
      // Process images with sharp for optimization
      if (file.mimetype.startsWith('image/')) {
        const optimizedPath = file.path.replace(path.extname(file.path), '_optimized.jpg')
        await sharp(file.path)
          .resize(1920, 1080, { fit: 'inside', withoutEnlargement: true })
          .jpeg({ quality: 85 })
          .toFile(optimizedPath)
        
        // Replace original with optimized version
        await fs.unlink(file.path)
        await fs.rename(optimizedPath, file.path)
      }
      
      // Create file record in database
      const fileRecord = await prisma.file.create({
        data: {
          filename: file.filename,
          originalName: file.originalname,
          mimetype: file.mimetype,
          size: file.size,
          path: file.path,
          uploadedBy: req.user.id
        }
      })
      
      uploadedFiles.push({
        id: fileRecord.id,
        filename: file.filename,
        originalName: file.originalname,
        mimetype: file.mimetype,
        size: file.size,
        status: 'success'
      })
    }
    
    res.json({ files: uploadedFiles })
  } catch (error) {
    console.error('Upload files error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getCurrentEvent = async (req, res) => {
  try {
    const event = await prisma.event.findFirst({
      where: {
        startDate: { lte: new Date() },
        endDate: { gte: new Date() }
      },
      include: {
        contests: {
          include: {
            categories: true
          }
        }
      }
    })

    res.json(event)
  } catch (error) {
    console.error('Get current event error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getAnnouncements = async (req, res) => {
  try {
    const announcements = await prisma.announcement.findMany({
      orderBy: { createdAt: 'desc' }
    })

    res.json(announcements)
  } catch (error) {
    console.error('Get announcements error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const createAnnouncement = async (req, res) => {
  try {
    const { title, message, priority } = req.body

    const announcement = await prisma.announcement.create({
      data: {
        title,
        message,
        priority,
        createdBy: req.user.id
      }
    })

    res.status(201).json(announcement)
  } catch (error) {
    console.error('Create announcement error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const updateAnnouncement = async (req, res) => {
  try {
    const { id } = req.params
    const { title, message, priority } = req.body

    const announcement = await prisma.announcement.update({
      where: { id },
      data: {
        title,
        message,
        priority
      }
    })

    res.json(announcement)
  } catch (error) {
    console.error('Update announcement error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const deleteAnnouncement = async (req, res) => {
  try {
    const { id } = req.params

    await prisma.announcement.delete({
      where: { id }
    })

    res.status(204).send()
  } catch (error) {
    console.error('Delete announcement error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  getScripts,
  getCurrentEvent,
  getAnnouncements,
  createAnnouncement,
  updateAnnouncement,
  deleteAnnouncement
}
EOF

    # File Controller
    cat > "$APP_DIR/src/controllers/fileController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')
const multer = require('multer')
const path = require('path')
const crypto = require('crypto')
const fs = require('fs').promises
const sharp = require('sharp')
const { exec } = require('child_process')
const { promisify } = require('util')

const execAsync = promisify(exec)
const prisma = new PrismaClient()

// Virus scanning function
const scanFileForVirus = async (filePath) => {
  try {
    // Check if ClamAV is available
    try {
      await execAsync('clamscan --version')
    } catch (error) {
      console.warn('ClamAV not available, skipping virus scan')
      return { clean: true, message: 'Virus scanner not available' }
    }

    // Scan the file
    const { stdout, stderr } = await execAsync(`clamscan --no-summary "${filePath}"`)
    
    if (stderr && stderr.includes('FOUND')) {
      return { clean: false, message: 'Virus detected in file' }
    }
    
    return { clean: true, message: 'File is clean' }
  } catch (error) {
    console.error('Virus scan error:', error)
    return { clean: false, message: 'Virus scan failed' }
  }
}

// Enhanced file validation function
const validateFile = async (filePath, originalName, mimeType) => {
  const validations = []

  // Check file size
  const stats = await fs.stat(filePath)
  if (stats.size === 0) {
    validations.push('File is empty')
  }
  if (stats.size > 10 * 1024 * 1024) {
    validations.push('File exceeds maximum size limit')
  }

  // Check file extension matches MIME type
  const extension = path.extname(originalName).toLowerCase()
  const expectedExtensions = {
    'image/jpeg': ['.jpg', '.jpeg'],
    'image/png': ['.png'],
    'image/gif': ['.gif'],
    'image/webp': ['.webp'],
    'application/pdf': ['.pdf'],
    'text/plain': ['.txt'],
    'application/msword': ['.doc'],
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'],
    'application/vnd.ms-excel': ['.xls'],
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': ['.xlsx'],
    'text/csv': ['.csv']
  }

  if (expectedExtensions[mimeType] && !expectedExtensions[mimeType].includes(extension)) {
    validations.push('File extension does not match MIME type')
  }

  // Check for suspicious file names
  const suspiciousPatterns = [
    /\.exe$/i,
    /\.bat$/i,
    /\.cmd$/i,
    /\.scr$/i,
    /\.pif$/i,
    /\.com$/i,
    /\.vbs$/i,
    /\.js$/i,
    /\.jar$/i
  ]

  if (suspiciousPatterns.some(pattern => pattern.test(originalName))) {
    validations.push('Suspicious file type detected')
  }

  // Check for malicious content in text files
  if (mimeType.startsWith('text/')) {
    try {
      const content = await fs.readFile(filePath, 'utf8')
      const maliciousPatterns = [
        /<script/i,
        /javascript:/i,
        /vbscript:/i,
        /onload=/i,
        /onerror=/i
      ]

      if (maliciousPatterns.some(pattern => pattern.test(content))) {
        validations.push('Potentially malicious content detected')
      }
    } catch (error) {
      validations.push('Unable to read file content for validation')
    }
  }

  return validations
}

// Configure multer for secure file uploads
const storage = multer.diskStorage({
  destination: async (req, file, cb) => {
    const uploadDir = path.join(process.cwd(), 'uploads', file.fieldname)
    await fs.mkdir(uploadDir, { recursive: true })
    cb(null, uploadDir)
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = crypto.randomBytes(16).toString('hex')
    const ext = path.extname(file.originalname)
    cb(null, `${uniqueSuffix}${ext}`)
  }
})

const fileFilter = (req, file, cb) => {
  // Define allowed file types
  const allowedTypes = {
    'image/jpeg': ['.jpg', '.jpeg'],
    'image/png': ['.png'],
    'image/gif': ['.gif'],
    'image/webp': ['.webp'],
    'application/pdf': ['.pdf'],
    'application/msword': ['.doc'],
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'],
    'application/vnd.ms-excel': ['.xls'],
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': ['.xlsx'],
    'text/plain': ['.txt'],
    'text/csv': ['.csv']
  }
  
  const ext = path.extname(file.originalname).toLowerCase()
  const mimeType = file.mimetype
  
  if (allowedTypes[mimeType] && allowedTypes[mimeType].includes(ext)) {
    cb(null, true)
  } else {
    cb(new Error('Invalid file type'), false)
  }
}

const upload = multer({
  storage,
  fileFilter,
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB limit
    files: 5 // Maximum 5 files per request
  }
})

const getAllFiles = async (req, res) => {
  try {
    const { category, uploadedBy, search, page = 1, limit = 20 } = req.query
    
    const where = {}
    if (category) where.category = category
    if (uploadedBy) where.uploadedBy = uploadedBy
    if (search) {
      where.OR = [
        { filename: { contains: search, mode: 'insensitive' } },
        { originalName: { contains: search, mode: 'insensitive' } }
      ]
    }
    
    const files = await prisma.file.findMany({
      where,
      include: {
        user: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true,
            role: true
          }
        }
      },
      orderBy: { uploadedAt: 'desc' },
      skip: (page - 1) * limit,
      take: parseInt(limit)
    })
    
    const total = await prisma.file.count({ where })
    
    res.json({
      files,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / limit)
      }
    })
  } catch (error) {
    console.error('Get files error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const uploadFiles = async (req, res) => {
  try {
    const files = req.files
    const { category = 'OTHER' } = req.body
    
    if (!files || files.length === 0) {
      return res.status(400).json({ error: 'No files uploaded' })
    }
    
    const uploadedFiles = []
    const failedFiles = []
    
    for (const file of files) {
      try {
        // Enhanced file validation
        const validationErrors = await validateFile(file.path, file.originalname, file.mimetype)
        if (validationErrors.length > 0) {
          // Clean up the uploaded file
          await fs.unlink(file.path).catch(console.error)
          failedFiles.push({
            filename: file.originalname,
            errors: validationErrors
          })
          continue
        }

        // Virus scanning
        const virusScanResult = await scanFileForVirus(file.path)
        if (!virusScanResult.clean) {
          // Clean up the uploaded file
          await fs.unlink(file.path).catch(console.error)
          failedFiles.push({
            filename: file.originalname,
            errors: [virusScanResult.message]
          })
          continue
        }

        // Generate checksum for file integrity
        const fileBuffer = await fs.readFile(file.path)
        const checksum = crypto.createHash('sha256').update(fileBuffer).digest('hex')
        
        // Check if file already exists (by checksum)
        const existingFile = await prisma.file.findFirst({
          where: { checksum: checksum }
        })

        if (existingFile) {
          // Clean up the duplicate file
          await fs.unlink(file.path).catch(console.error)
          failedFiles.push({
            filename: file.originalname,
            errors: ['File already exists']
          })
          continue
        }
        
        // Process images with sharp for optimization
        if (file.mimetype.startsWith('image/')) {
          const optimizedPath = file.path.replace(path.extname(file.path), '_optimized.jpg')
          await sharp(file.path)
            .resize(1920, 1080, { fit: 'inside', withoutEnlargement: true })
            .jpeg({ quality: 85 })
            .toFile(optimizedPath)
          
          // Replace original with optimized version
          await fs.unlink(file.path)
          await fs.rename(optimizedPath, file.path)
        }
        
        const fileRecord = await prisma.file.create({
          data: {
            filename: file.filename,
            originalName: file.originalname,
            mimeType: file.mimetype,
            size: file.size,
            path: file.path,
            category,
            uploadedBy: req.user.id,
            checksum,
            metadata: JSON.stringify({
              uploadedAt: new Date().toISOString(),
              virusScanResult: virusScanResult.message,
              validationPassed: true
            })
          },
          include: {
            user: {
              select: {
                id: true,
                name: true,
                preferredName: true,
                email: true,
                role: true
              }
            }
          }
        })
        
        uploadedFiles.push(fileRecord)
      } catch (fileError) {
        console.error(`Error processing file ${file.originalname}:`, fileError)
        // Clean up the uploaded file
        await fs.unlink(file.path).catch(console.error)
        failedFiles.push({
          filename: file.originalname,
          errors: ['Processing error: ' + fileError.message]
        })
      }
    }
    
    // Log upload activity
    await prisma.activityLog.create({
      data: {
        userId: req.user.id,
        action: 'UPLOAD_FILES',
        details: `Uploaded ${uploadedFiles.length} files, ${failedFiles.length} failed`,
        category: 'FILE_MANAGEMENT'
      }
    })
    
    res.status(201).json({ 
      files: uploadedFiles,
      failedFiles: failedFiles,
      summary: {
        total: files.length,
        successful: uploadedFiles.length,
        failed: failedFiles.length
      }
    })
  } catch (error) {
    console.error('Upload files error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getFileById = async (req, res) => {
  try {
    const { id } = req.params
    const userId = req.user.id
    const userRole = req.user.role
    
    const file = await prisma.file.findUnique({
      where: { id },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true,
            role: true
          }
        }
      }
    })
    
    if (!file) {
      return res.status(404).json({ error: 'File not found' })
    }
    
    // Check access permissions
    if (!['ORGANIZER', 'BOARD'].includes(userRole) && 
        file.uploadedBy !== userId && 
        !file.isPublic) {
      return res.status(403).json({ error: 'Access denied' })
    }
    
    res.json(file)
  } catch (error) {
    console.error('Get file by ID error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const downloadFile = async (req, res) => {
  try {
    const { id } = req.params
    const userId = req.user.id
    const userRole = req.user.role
    
    const file = await prisma.file.findUnique({
      where: { id }
    })
    
    if (!file) {
      return res.status(404).json({ error: 'File not found' })
    }
    
    // Check access permissions
    if (!['ORGANIZER', 'BOARD'].includes(userRole) && 
        file.uploadedBy !== userId && 
        !file.isPublic) {
      return res.status(403).json({ error: 'Access denied' })
    }
    
    // Check if file exists on disk
    try {
      await fs.access(file.path)
    } catch (error) {
      return res.status(404).json({ error: 'File not found on disk' })
    }
    
    // Set appropriate headers
    res.setHeader('Content-Type', file.mimeType)
    res.setHeader('Content-Disposition', 'attachment; filename="' + file.originalName + '"')
    res.setHeader('Content-Length', file.size)
    
    // Stream the file
    const fileStream = require('fs').createReadStream(file.path)
    fileStream.pipe(res)
    
    // Log download activity
    await prisma.activityLog.create({
      data: {
        userId: userId,
        action: 'DOWNLOAD_FILE',
        details: `Downloaded file: ${file.originalName}`,
        category: 'FILE_MANAGEMENT'
      }
    })
    
  } catch (error) {
    console.error('Download file error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const updateFile = async (req, res) => {
  try {
    const { id } = req.params
    const { category, isPublic, metadata } = req.body
    const userId = req.user.id
    const userRole = req.user.role
    
    const file = await prisma.file.findUnique({
      where: { id }
    })
    
    if (!file) {
      return res.status(404).json({ error: 'File not found' })
    }
    
    // Check permissions - only file owner or admin can update
    if (file.uploadedBy !== userId && !['ORGANIZER', 'BOARD'].includes(userRole)) {
      return res.status(403).json({ error: 'Access denied' })
    }
    
    const updatedFile = await prisma.file.update({
      where: { id },
      data: {
        ...(category && { category }),
        ...(isPublic !== undefined && { isPublic }),
        ...(metadata && { metadata })
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true,
            role: true
          }
        }
      }
    })
    
    res.json(updatedFile)
  } catch (error) {
    console.error('Update file error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const deleteFile = async (req, res) => {
  try {
    const { id } = req.params
    const userId = req.user.id
    const userRole = req.user.role
    
    const file = await prisma.file.findUnique({
      where: { id }
    })
    
    if (!file) {
      return res.status(404).json({ error: 'File not found' })
    }
    
    // Check permissions - only file owner or admin can delete
    if (file.uploadedBy !== userId && !['ORGANIZER', 'BOARD'].includes(userRole)) {
      return res.status(403).json({ error: 'Access denied' })
    }
    
    // Delete file from disk
    try {
      await fs.unlink(file.path)
    } catch (error) {
      console.warn('File not found on disk:', file.path)
    }
    
    // Delete file record from database
    await prisma.file.delete({
      where: { id }
    })
    
    // Log deletion activity
    await prisma.activityLog.create({
      data: {
        userId: userId,
        action: 'DELETE_FILE',
        details: `Deleted file: ${file.originalName}`,
        category: 'FILE_MANAGEMENT'
      }
    })
    
    res.json({ message: 'File deleted successfully' })
  } catch (error) {
    console.error('Delete file error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getFileStats = async (req, res) => {
  try {
    const userRole = req.user.role

    if (!['ORGANIZER', 'BOARD'].includes(userRole)) {
      return res.status(403).json({ error: 'Access denied' })
    }

    const stats = {
      totalFiles: await prisma.file.count(),
      totalSize: await prisma.file.aggregate({
        _sum: { size: true }
      }),
      byCategory: await prisma.file.groupBy({
        by: ['category'],
        _count: { category: true },
        _sum: { size: true }
      }),
      recentUploads: await prisma.file.count({
        where: {
          uploadedAt: {
            gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) // Last 7 days
          }
        }
      })
    }
    
    res.json(stats)
  } catch (error) {
    console.error('Get file stats error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  getAllFiles,
  uploadFiles,
  getFileById,
  downloadFile,
  updateFile,
  deleteFile,
  getFileStats,
  upload // Export multer middleware
}
EOF

    # Performance Monitoring Controller
    cat > "$APP_DIR/src/controllers/performanceController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')
const os = require('os')
const fs = require('fs').promises
const path = require('path')

const prisma = new PrismaClient()

// Log performance metrics
const logPerformance = async (req, res, next) => {
  const startTime = Date.now()
  
  res.on('finish', async () => {
    try {
      const responseTime = Date.now() - startTime
      
      await prisma.performanceLog.create({
        data: {
          endpoint: req.path,
          method: req.method,
          responseTime,
          statusCode: res.statusCode,
          userId: req.user?.id,
          ipAddress: req.ip || req.connection.remoteAddress,
          userAgent: req.get('User-Agent')
        }
      })
    } catch (error) {
      console.error('Performance logging error:', error)
    }
  })
  
  next()
}

const getPerformanceStats = async (req, res) => {
  try {
    const { timeRange = '24h', endpoint, method } = req.query
    
    // Calculate time range
    const now = new Date()
    let startTime
    switch (timeRange) {
      case '1h':
        startTime = new Date(now.getTime() - 60 * 60 * 1000)
        break
      case '24h':
        startTime = new Date(now.getTime() - 24 * 60 * 60 * 1000)
        break
      case '7d':
        startTime = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)
        break
      case '30d':
        startTime = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000)
        break
      default:
        startTime = new Date(now.getTime() - 24 * 60 * 60 * 1000)
    }
    
    const whereClause = {
      createdAt: {
        gte: startTime
      },
      ...(endpoint && { endpoint }),
      ...(method && { method })
    }
    
    // Get performance statistics
    const stats = await prisma.performanceLog.aggregate({
      where: whereClause,
      _avg: {
        responseTime: true
      },
      _min: {
        responseTime: true
      },
      _max: {
        responseTime: true
      },
      _count: {
        id: true
      }
    })
    
    // Get response time distribution
    const responseTimeDistribution = await prisma.performanceLog.groupBy({
      by: ['statusCode'],
      where: whereClause,
      _count: {
        id: true
      },
      _avg: {
        responseTime: true
      }
    })
    
    // Get top slow endpoints
    const slowEndpoints = await prisma.performanceLog.groupBy({
      by: ['endpoint'],
      where: whereClause,
      _avg: {
        responseTime: true
      },
      _count: {
        id: true
      },
      orderBy: {
        _avg: {
          responseTime: 'desc'
        }
      },
      take: 10
    })
    
    // Get error rates
    const errorStats = await prisma.performanceLog.groupBy({
      by: ['statusCode'],
      where: {
        ...whereClause,
        statusCode: {
          gte: 400
        }
      },
      _count: {
        id: true
      }
    })
    
    res.json({
      timeRange,
      totalRequests: stats._count.id,
      averageResponseTime: Math.round(stats._avg.responseTime || 0),
      minResponseTime: stats._min.responseTime || 0,
      maxResponseTime: stats._max.responseTime || 0,
      responseTimeDistribution,
      slowEndpoints,
      errorStats,
      errorRate: stats._count.id > 0 ? 
        (errorStats.reduce((sum, stat) => sum + stat._count.id, 0) / stats._count.id * 100).toFixed(2) : 0
    })
  } catch (error) {
    console.error('Get performance stats error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getSystemMetrics = async (req, res) => {
  try {
    // CPU and Memory usage
    const cpuUsage = process.cpuUsage()
    const memoryUsage = process.memoryUsage()
    
    // System information
    const systemInfo = {
      platform: os.platform(),
      arch: os.arch(),
      hostname: os.hostname(),
      uptime: os.uptime(),
      loadAverage: os.loadavg(),
      totalMemory: os.totalmem(),
      freeMemory: os.freemem(),
      cpuCount: os.cpus().length
    }
    
    // Database connection status
    const dbStatus = await prisma.$queryRaw`SELECT 1 as status`
    
    // Disk usage (if possible)
    let diskUsage = null
    try {
      const stats = await fs.stat(path.join(__dirname, '../../'))
      diskUsage = {
        available: true,
        path: path.join(__dirname, '../../')
      }
    } catch (error) {
      diskUsage = { available: false, error: error.message }
    }
    
    res.json({
      timestamp: new Date().toISOString(),
      process: {
        pid: process.pid,
        uptime: process.uptime(),
        cpuUsage: {
          user: cpuUsage.user,
          system: cpuUsage.system
        },
        memoryUsage: {
          rss: memoryUsage.rss,
          heapTotal: memoryUsage.heapTotal,
          heapUsed: memoryUsage.heapUsed,
          external: memoryUsage.external
        }
      },
      system: systemInfo,
      database: {
        status: dbStatus ? 'connected' : 'disconnected',
        connectionCount: await prisma.$queryRaw`SELECT count(*) as count FROM pg_stat_activity WHERE state = 'active'`
      },
      disk: diskUsage
    })
  } catch (error) {
    console.error('Get system metrics error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getPerformanceLogs = async (req, res) => {
  try {
    const { 
      page = 1, 
      limit = 50, 
      endpoint, 
      method, 
      statusCode, 
      userId,
      minResponseTime,
      maxResponseTime,
      startDate,
      endDate
    } = req.query
    
    const whereClause = {
      ...(endpoint && { endpoint: { contains: endpoint } }),
      ...(method && { method }),
      ...(statusCode && { statusCode: parseInt(statusCode) }),
      ...(userId && { userId }),
      ...(minResponseTime && { responseTime: { gte: parseInt(minResponseTime) } }),
      ...(maxResponseTime && { responseTime: { lte: parseInt(maxResponseTime) } }),
      ...(startDate && endDate && {
        createdAt: {
          gte: new Date(startDate),
          lte: new Date(endDate)
        }
      })
    }
    
    const logs = await prisma.performanceLog.findMany({
      where: whereClause,
      include: {
        user: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true,
            role: true
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      },
      skip: (parseInt(page) - 1) * parseInt(limit),
      take: parseInt(limit)
    })
    
    const total = await prisma.performanceLog.count({
      where: whereClause
    })
    
    res.json({
      logs,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total,
        pages: Math.ceil(total / parseInt(limit))
      }
    })
  } catch (error) {
    console.error('Get performance logs error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const clearPerformanceLogs = async (req, res) => {
  try {
    const { olderThan } = req.body
    
    let whereClause = {}
    if (olderThan) {
      whereClause = {
        createdAt: {
          lt: new Date(olderThan)
        }
      }
    }
    
    const result = await prisma.performanceLog.deleteMany({
      where: whereClause
    })
    
    res.json({ 
      message: `Cleared ${result.count} performance log entries`,
      count: result.count
    })
  } catch (error) {
    console.error('Clear performance logs error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getHealthCheck = async (req, res) => {
  try {
    const checks = {
      database: false,
      memory: false,
      disk: false,
      uptime: false
    }
    
    // Database check
    try {
      await prisma.$queryRaw`SELECT 1`
      checks.database = true
    } catch (error) {
      console.error('Database health check failed:', error)
    }
    
    // Memory check
    const memoryUsage = process.memoryUsage()
    const memoryUsagePercent = (memoryUsage.heapUsed / memoryUsage.heapTotal) * 100
    checks.memory = memoryUsagePercent < 90 // Less than 90% memory usage
    
    // Disk check (basic)
    try {
      await fs.access(path.join(__dirname, '../../'))
      checks.disk = true
    } catch (error) {
      console.error('Disk health check failed:', error)
    }
    
    // Uptime check
    checks.uptime = process.uptime() > 0
    
    const allHealthy = Object.values(checks).every(check => check === true)
    
    res.status(allHealthy ? 200 : 503).json({
      status: allHealthy ? 'healthy' : 'unhealthy',
      timestamp: new Date().toISOString(),
      checks,
      uptime: process.uptime(),
      memory: {
        used: memoryUsage.heapUsed,
        total: memoryUsage.heapTotal,
        percent: memoryUsagePercent.toFixed(2)
      }
    })
  } catch (error) {
    console.error('Health check error:', error)
    res.status(503).json({ 
      status: 'unhealthy',
      error: 'Health check failed',
      timestamp: new Date().toISOString()
    })
  }
}

module.exports = {
  logPerformance,
  getPerformanceStats,
  getSystemMetrics,
  getPerformanceLogs,
  clearPerformanceLogs,
  getHealthCheck
}
EOF

    # Certification Controller
    cat > "$APP_DIR/src/controllers/certificationController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

const getAllCertifications = async (req, res) => {
  try {
    const { status, categoryId, contestId, eventId } = req.query
    
    const certifications = await prisma.certification.findMany({
      where: {
        ...(status && { status }),
        ...(categoryId && { categoryId }),
        ...(contestId && { contestId }),
        ...(eventId && { eventId }),
      },
      include: {
        category: {
          select: {
            id: true,
            name: true,
            description: true,
            scoreCap: true,
          }
        },
        contest: {
          select: {
            id: true,
            name: true,
            description: true,
          }
        },
        event: {
          select: {
            id: true,
            name: true,
            startDate: true,
            endDate: true,
          }
        }
      },
      orderBy: [
        { createdAt: 'desc' }
      ]
    })
    
    res.json(certifications)
  } catch (error) {
    console.error('Get certifications error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const createCertification = async (req, res) => {
  try {
    const { categoryId, contestId, eventId } = req.body
    
    // Check if certification already exists
    const existingCertification = await prisma.certification.findUnique({
      where: {
        categoryId_contestId_eventId: {
          categoryId,
          contestId,
          eventId
        }
      }
    })
    
    if (existingCertification) {
      return res.status(400).json({ error: 'Certification already exists' })
    }
    
    const certification = await prisma.certification.create({
      data: {
        categoryId,
        contestId,
        eventId,
        status: 'PENDING',
        currentStep: 1,
        totalSteps: 4
      },
      include: {
        category: true,
        contest: true,
        event: true
      }
    })
    
    res.status(201).json(certification)
  } catch (error) {
    console.error('Create certification error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const updateCertification = async (req, res) => {
  try {
    const { id } = req.params
    const { status, currentStep, judgeCertified, tallyCertified, auditorCertified, boardApproved, comments } = req.body
    
    const certification = await prisma.certification.update({
      where: { id },
      data: {
        ...(status && { status }),
        ...(currentStep !== undefined && { currentStep }),
        ...(judgeCertified !== undefined && { judgeCertified }),
        ...(tallyCertified !== undefined && { tallyCertified }),
        ...(auditorCertified !== undefined && { auditorCertified }),
        ...(boardApproved !== undefined && { boardApproved }),
        ...(comments !== undefined && { comments }),
      },
      include: {
        category: true,
        contest: true,
        event: true
      }
    })
    
    res.json(certification)
  } catch (error) {
    console.error('Update certification error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const deleteCertification = async (req, res) => {
  try {
    const { id } = req.params
    
    await prisma.certification.delete({
      where: { id }
    })
    
    res.json({ message: 'Certification deleted successfully' })
  } catch (error) {
    console.error('Delete certification error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getCertificationById = async (req, res) => {
  try {
    const { id } = req.params
    
    const certification = await prisma.certification.findUnique({
      where: { id },
      include: {
        category: {
          include: {
            criteria: true,
            contestants: true,
            scores: true
          }
        },
        contest: true,
        event: true
      }
    })
    
    if (!certification) {
      return res.status(404).json({ error: 'Certification not found' })
    }
    
    res.json(certification)
  } catch (error) {
    console.error('Get certification by ID error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const certifyJudge = async (req, res) => {
  try {
    const { id } = req.params
    const { comments } = req.body
    
    const certification = await prisma.certification.update({
      where: { id },
      data: {
        judgeCertified: true,
        currentStep: 2,
        comments: comments || ''
      },
      include: {
        category: true,
        contest: true,
        event: true
      }
    })
    
    res.json(certification)
  } catch (error) {
    console.error('Certify judge error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const certifyTally = async (req, res) => {
  try {
    const { id } = req.params
    const { comments } = req.body
    
    const certification = await prisma.certification.update({
      where: { id },
      data: {
        tallyCertified: true,
        currentStep: 3,
        comments: comments || ''
      },
      include: {
        category: true,
        contest: true,
        event: true
      }
    })
    
    res.json(certification)
  } catch (error) {
    console.error('Certify tally error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const certifyAuditor = async (req, res) => {
  try {
    const { id } = req.params
    const { comments } = req.body
    
    const certification = await prisma.certification.update({
      where: { id },
      data: {
        auditorCertified: true,
        currentStep: 4,
        comments: comments || ''
      },
      include: {
        category: true,
        contest: true,
        event: true
      }
    })
    
    res.json(certification)
  } catch (error) {
    console.error('Certify auditor error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const approveBoard = async (req, res) => {
  try {
    const { id } = req.params
    const { comments } = req.body
    
    const certification = await prisma.certification.update({
      where: { id },
      data: {
        boardApproved: true,
        status: 'CERTIFIED',
        certifiedAt: new Date(),
        certifiedBy: req.user.id,
        comments: comments || ''
      },
      include: {
        category: true,
        contest: true,
        event: true
      }
    })
    
    res.json(certification)
  } catch (error) {
    console.error('Approve board error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const rejectCertification = async (req, res) => {
  try {
    const { id } = req.params
    const { rejectionReason } = req.body
    
    const certification = await prisma.certification.update({
      where: { id },
      data: {
        status: 'REJECTED',
        rejectionReason,
        certifiedBy: req.user.id
      },
      include: {
        category: true,
        contest: true,
        event: true
      }
    })
    
    res.json(certification)
  } catch (error) {
    console.error('Reject certification error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getCertificationStats = async (req, res) => {
  try {
    const stats = {
      total: await prisma.certification.count(),
      pending: await prisma.certification.count({ where: { status: 'PENDING' } }),
      inProgress: await prisma.certification.count({ where: { status: 'IN_PROGRESS' } }),
      certified: await prisma.certification.count({ where: { status: 'CERTIFIED' } }),
      rejected: await prisma.certification.count({ where: { status: 'REJECTED' } }),
      judgeCertified: await prisma.certification.count({ where: { judgeCertified: true } }),
      tallyCertified: await prisma.certification.count({ where: { tallyCertified: true } }),
      auditorCertified: await prisma.certification.count({ where: { auditorCertified: true } }),
      boardApproved: await prisma.certification.count({ where: { boardApproved: true } })
    }
    
    res.json(stats)
  } catch (error) {
    console.error('Get certification stats error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  getAllCertifications,
  createCertification,
  updateCertification,
  deleteCertification,
  getCertificationById,
  certifyJudge,
  certifyTally,
  certifyAuditor,
  approveBoard,
  rejectCertification,
  getCertificationStats
}
EOF

    # Winners Controller
    cat > "$APP_DIR/src/controllers/winnersController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')
const crypto = require('crypto')

const prisma = new PrismaClient()

// Generate signature for winner verification
const generateSignature = (userId, categoryId, userRole, ipAddress, userAgent) => {
  const timestamp = new Date().toISOString()
  const data = `${userId}-${categoryId}-${userRole}-${timestamp}-${ipAddress || ''}-${userAgent || ''}`
  return crypto.createHash('sha256').update(data).digest('hex')
}

// Get winners by category with signature verification
const getWinnersByCategory = async (req, res) => {
  try {
    const { categoryId } = req.params
    const userRole = req.user.role

    // Get category with contest and event info
    const category = await prisma.category.findUnique({
      where: { id: categoryId },
      include: {
        contest: {
          include: {
            event: true
          }
        },
        contestants: {
          include: {
            contestant: true
          }
        }
      }
    })

    if (!category) {
      return res.status(404).json({ error: 'Category not found' })
    }

    // Get all scores for this category
    const scores = await prisma.score.findMany({
      where: { categoryId },
      include: {
        contestant: true,
        judge: {
          include: {
            user: true
          }
        },
        criterion: true
      }
    })

    // Calculate total scores per contestant
    const contestantScores = {}
    scores.forEach(score => {
      const contestantId = score.contestantId
      if (!contestantScores[contestantId]) {
        contestantScores[contestantId] = {
          contestant: score.contestant,
          totalScore: 0,
          averageScore: 0,
          scores: []
        }
      }
      contestantScores[contestantId].totalScore += score.score
      contestantScores[contestantId].scores.push(score)
    })

    // Calculate averages and sort by total score
    const contestants = Object.values(contestantScores).map(contestant => {
      const scoreCount = contestant.scores.length
      contestant.averageScore = scoreCount > 0 ? contestant.totalScore / scoreCount : 0
      return contestant
    }).sort((a, b) => b.totalScore - a.totalScore)

    // Get signatures for this category
    const signatures = await prisma.winnerSignature.findMany({
      where: { categoryId },
      include: {
        user: true
      }
    })

    // Check if all required signatures are present
    const requiredRoles = ['JUDGE', 'TALLY_MASTER', 'AUDITOR', 'BOARD']
    const signedRoles = signatures.map(sig => sig.userRole)
    const allSigned = requiredRoles.every(role => signedRoles.includes(role))

    // For emcee role, require board signature
    const boardSigned = signatures.some(sig => sig.userRole === 'BOARD')
    const canShowWinners = userRole === 'EMCEE' ? boardSigned : allSigned

    res.json({
      category,
      contestants: canShowWinners ? contestants : [],
      signatures,
      allSigned,
      boardSigned,
      canShowWinners,
      requiredRoles,
      message: canShowWinners ? 'Winners available' : 'Waiting for required signatures'
    })
  } catch (error) {
    console.error('Get winners by category error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get winners by contest
const getWinnersByContest = async (req, res) => {
  try {
    const { contestId } = req.params
    const userRole = req.user.role

    // Get contest with categories
    const contest = await prisma.contest.findUnique({
      where: { id: contestId },
      include: {
        event: true,
        categories: {
          include: {
            contestants: {
              include: {
                contestant: true
              }
            }
          }
        }
      }
    })

    if (!contest) {
      return res.status(404).json({ error: 'Contest not found' })
    }

    const categoryResults = []

    for (const category of contest.categories) {
      // Get scores for this category
      const scores = await prisma.score.findMany({
        where: { categoryId: category.id },
        include: {
          contestant: true,
          judge: {
            include: {
              user: true
            }
          },
          criterion: true
        }
      })

      // Calculate scores
      const contestantScores = {}
      scores.forEach(score => {
        const contestantId = score.contestantId
        if (!contestantScores[contestantId]) {
          contestantScores[contestantId] = {
            contestant: score.contestant,
            totalScore: 0,
            averageScore: 0,
            scores: []
          }
        }
        contestantScores[contestantId].totalScore += score.score
        contestantScores[contestantId].scores.push(score)
      })

      const contestants = Object.values(contestantScores).map(contestant => {
        const scoreCount = contestant.scores.length
        contestant.averageScore = scoreCount > 0 ? contestant.totalScore / scoreCount : 0
        return contestant
      }).sort((a, b) => b.totalScore - a.totalScore)

      // Get signatures
      const signatures = await prisma.winnerSignature.findMany({
        where: { categoryId: category.id },
        include: {
          user: true
        }
      })

      const requiredRoles = ['JUDGE', 'TALLY_MASTER', 'AUDITOR', 'BOARD']
      const signedRoles = signatures.map(sig => sig.userRole)
      const allSigned = requiredRoles.every(role => signedRoles.includes(role))
      const boardSigned = signatures.some(sig => sig.userRole === 'BOARD')
      const canShowWinners = userRole === 'EMCEE' ? boardSigned : allSigned

      categoryResults.push({
        category,
        contestants: canShowWinners ? contestants : [],
        signatures,
        allSigned,
        boardSigned,
        canShowWinners
      })
    }

    res.json({
      contest,
      categories: categoryResults,
      message: 'Contest winners retrieved'
    })
  } catch (error) {
    console.error('Get winners by contest error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Sign winners (add signature)
const signWinners = async (req, res) => {
  try {
    const { categoryId } = req.params
    const userId = req.user.id
    const userRole = req.user.role
    const ipAddress = req.ip || req.connection.remoteAddress
    const userAgent = req.headers['user-agent']

    // Check if user already signed this category
    const existingSignature = await prisma.winnerSignature.findFirst({
      where: {
        categoryId,
        userId
      }
    })

    if (existingSignature) {
      return res.status(400).json({ error: 'User has already signed this category' })
    }

    // Generate signature
    const signature = generateSignature(userId, categoryId, userRole, ipAddress, userAgent)

    // Create signature record
    const winnerSignature = await prisma.winnerSignature.create({
      data: {
        categoryId,
        contestId: req.body.contestId,
        eventId: req.body.eventId,
        userId,
        userRole,
        signature,
        ipAddress,
        userAgent
      },
      include: {
        user: true,
        category: true
      }
    })

    res.json({
      message: 'Winners signed successfully',
      signature: winnerSignature
    })
  } catch (error) {
    console.error('Sign winners error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get signature status for a category
const getSignatureStatus = async (req, res) => {
  try {
    const { categoryId } = req.params

    const signatures = await prisma.winnerSignature.findMany({
      where: { categoryId },
      include: {
        user: true
      }
    })

    const requiredRoles = ['JUDGE', 'TALLY_MASTER', 'AUDITOR', 'BOARD']
    const signedRoles = signatures.map(sig => sig.userRole)
    const allSigned = requiredRoles.every(role => signedRoles.includes(role))
    const boardSigned = signatures.some(sig => sig.userRole === 'BOARD')

    res.json({
      signatures,
      allSigned,
      boardSigned,
      requiredRoles,
      signedRoles,
      missingRoles: requiredRoles.filter(role => !signedRoles.includes(role))
    })
  } catch (error) {
    console.error('Get signature status error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get certification progress for all roles
const getCertificationProgress = async (req, res) => {
  try {
    const { categoryId } = req.params

    // Get all certifications for this category
    const [judgeCertifications, tallyCertifications, auditorCertifications, boardCertifications] = await Promise.all([
      prisma.judgeCertification.findMany({
        where: { categoryId },
        include: { judge: { include: { user: true } } }
      }),
      prisma.tallyMasterCertification.findMany({
        where: { categoryId }
      }),
      prisma.auditorCertification.findMany({
        where: { categoryId }
      }),
      prisma.winnerSignature.findMany({
        where: { categoryId, userRole: 'BOARD' },
        include: { user: true }
      })
    ])

    // Get all judges assigned to this category
    const categoryJudges = await prisma.categoryJudge.findMany({
      where: { categoryId },
      include: { judge: { include: { user: true } } }
    })

    const progress = {
      judges: {
        total: categoryJudges.length,
        certified: judgeCertifications.length,
        certifications: judgeCertifications.map(cert => ({
          judgeId: cert.judgeId,
          judgeName: cert.judge.user.name,
          signatureName: cert.signatureName,
          certifiedAt: cert.certifiedAt
        }))
      },
      tallyMaster: {
        certified: tallyCertifications.length > 0,
        certification: tallyCertifications[0] || null
      },
      auditor: {
        certified: auditorCertifications.length > 0,
        certification: auditorCertifications[0] || null
      },
      board: {
        certified: boardCertifications.length > 0,
        certification: boardCertifications[0] || null
      }
    }

    res.json(progress)
  } catch (error) {
    console.error('Get certification progress error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get certification status for specific role
const getRoleCertificationStatus = async (req, res) => {
  try {
    const { categoryId, role } = req.params
    const userId = req.user.id

    let certification = null
    let canCertify = false

    switch (role.toUpperCase()) {
      case 'JUDGE':
        certification = await prisma.judgeCertification.findFirst({
          where: { categoryId, judgeId: req.user.judgeId }
        })
        canCertify = !certification && req.user.role === 'JUDGE'
        break

      case 'TALLY_MASTER':
        certification = await prisma.tallyMasterCertification.findFirst({
          where: { categoryId }
        })
        canCertify = !certification && req.user.role === 'TALLY_MASTER'
        break

      case 'AUDITOR':
        certification = await prisma.auditorCertification.findFirst({
          where: { categoryId }
        })
        canCertify = !certification && req.user.role === 'AUDITOR'
        break

      case 'BOARD':
        certification = await prisma.winnerSignature.findFirst({
          where: { categoryId, userId, userRole: 'BOARD' }
        })
        canCertify = !certification && req.user.role === 'BOARD'
        break

      default:
        return res.status(400).json({ error: 'Invalid role' })
    }

    res.json({
      role: role.toUpperCase(),
      certified: !!certification,
      certification,
      canCertify,
      userId
    })
  } catch (error) {
    console.error('Get role certification status error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Certify scores for specific role
const certifyScores = async (req, res) => {
  try {
    const { categoryId } = req.params
    const { signatureName, comments } = req.body
    const userId = req.user.id
    const userRole = req.user.role

    if (!signatureName) {
      return res.status(400).json({ error: 'Signature name is required' })
    }

    let certification = null

    switch (userRole) {
      case 'JUDGE':
        if (!req.user.judgeId) {
          return res.status(400).json({ error: 'User must be linked to a judge' })
        }
        certification = await prisma.judgeCertification.create({
          data: {
            categoryId,
            judgeId: req.user.judgeId,
            signatureName,
            certifiedAt: new Date()
          }
        })
        break

      case 'TALLY_MASTER':
        certification = await prisma.tallyMasterCertification.create({
          data: {
            categoryId,
            signatureName,
            certifiedAt: new Date()
          }
        })
        break

      case 'AUDITOR':
        certification = await prisma.auditorCertification.create({
          data: {
            categoryId,
            signatureName,
            certifiedAt: new Date()
          }
        })
        break

      case 'BOARD':
        certification = await prisma.winnerSignature.create({
          data: {
            categoryId,
            userId,
            userRole: 'BOARD',
            signatureName,
            signatureHash: generateSignature(userId, categoryId, 'BOARD', req.ip, req.get('User-Agent')),
            signedAt: new Date(),
            comments: comments || null
          }
        })
        break

      default:
        return res.status(403).json({ error: 'Role not authorized to certify' })
    }

    res.status(201).json({
      message: 'Scores certified successfully',
      certification,
      role: userRole
    })
  } catch (error) {
    console.error('Certify scores error:', error)
    if (error.code === 'P2002') {
      res.status(400).json({ error: 'Scores already certified by this role' })
    } else {
      res.status(500).json({ error: 'Internal server error' })
    }
  }
}

module.exports = {
  getWinnersByCategory,
  getWinnersByContest,
  signWinners,
  getSignatureStatus,
  getCertificationProgress,
  getRoleCertificationStatus,
  certifyScores
}
EOF

    # Password Validation Middleware
    cat > "$APP_DIR/src/middleware/passwordValidation.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

const validatePassword = async (req, res, next) => {
  try {
    const { password } = req.body

    if (!password) {
      return res.status(400).json({ error: 'Password is required' })
    }

    // Get active password policy
    const policy = await prisma.passwordPolicy.findFirst({
      where: { isActive: true }
    })

    if (!policy) {
      // No policy set, allow any password
      return next()
    }

    const errors = []

    // Check minimum length
    if (password.length < policy.minLength) {
      errors.push(`Password must be at least ${policy.minLength} characters long`)
    }

    // Check for uppercase letters
    if (policy.requireUppercase && !/[A-Z]/.test(password)) {
      errors.push('Password must contain at least one uppercase letter')
    }

    // Check for lowercase letters
    if (policy.requireLowercase && !/[a-z]/.test(password)) {
      errors.push('Password must contain at least one lowercase letter')
    }

    // Check for numbers
    if (policy.requireNumbers && !/\d/.test(password)) {
      errors.push('Password must contain at least one number')
    }

    // Check for special characters
    if (policy.requireSpecialChars && !/[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(password)) {
      errors.push('Password must contain at least one special character')
    }

    if (errors.length > 0) {
      return res.status(400).json({ 
        error: 'Password does not meet requirements',
        details: errors
      })
    }

    next()
  } catch (error) {
    console.error('Password validation error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const getPasswordPolicy = async (req, res) => {
  try {
    const policy = await prisma.passwordPolicy.findFirst({
      where: { isActive: true }
    })

    if (!policy) {
      return res.json({
        minLength: 8,
        requireUppercase: true,
        requireLowercase: true,
        requireNumbers: true,
        requireSpecialChars: true,
        isActive: false
      })
    }

    res.json({
      minLength: policy.minLength,
      requireUppercase: policy.requireUppercase,
      requireLowercase: policy.requireLowercase,
      requireNumbers: policy.requireNumbers,
      requireSpecialChars: policy.requireSpecialChars,
      isActive: policy.isActive
    })
  } catch (error) {
    console.error('Get password policy error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

const updatePasswordPolicy = async (req, res) => {
  try {
    const { minLength, requireUppercase, requireLowercase, requireNumbers, requireSpecialChars, isActive } = req.body

    // Deactivate all existing policies
    await prisma.passwordPolicy.updateMany({
      where: { isActive: true },
      data: { isActive: false }
    })

    // Create new policy
    const policy = await prisma.passwordPolicy.create({
      data: {
        minLength: minLength || 8,
        requireUppercase: requireUppercase !== false,
        requireLowercase: requireLowercase !== false,
        requireNumbers: requireNumbers !== false,
        requireSpecialChars: requireSpecialChars !== false,
        isActive: isActive !== false
      }
    })

    res.json({
      id: policy.id,
      minLength: policy.minLength,
      requireUppercase: policy.requireUppercase,
      requireLowercase: policy.requireLowercase,
      requireNumbers: policy.requireNumbers,
      requireSpecialChars: policy.requireSpecialChars,
      isActive: policy.isActive,
      createdAt: policy.createdAt
    })
  } catch (error) {
    console.error('Update password policy error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  validatePassword,
  getPasswordPolicy,
  updatePasswordPolicy
}
EOF

    print_success "Controller files created successfully"
}

# Create modular route files
create_route_files() {
    print_status "Creating route files..."
    
    # Auth Routes
    cat > "$APP_DIR/src/routes/authRoutes.js" << 'EOF'
const express = require('express')
const { login, getProfile } = require('../controllers/authController')
const { authenticateToken } = require('../middleware/auth')
const { authLimiter } = require('../middleware/rateLimiting')

const router = express.Router()

// Apply rate limiting to auth routes
router.use(authLimiter)

// Auth endpoints
router.post('/login', login)
router.get('/profile', authenticateToken, getProfile)

module.exports = router
EOF

    # Events Routes
    cat > "$APP_DIR/src/routes/eventsRoutes.js" << 'EOF'
const express = require('express')
const { getAllEvents, getEventById, createEvent, updateEvent, deleteEvent } = require('../controllers/eventsController')
const { authenticateToken } = require('../middleware/auth')
const { validateEvent } = require('../middleware/validation')
const { logActivity } = require('../middleware/errorHandler')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)

// Events endpoints
router.get('/', getAllEvents)
router.get('/:id', getEventById)
router.post('/', validateEvent, logActivity('CREATE_EVENT', 'EVENT'), createEvent)
router.put('/:id', validateEvent, logActivity('UPDATE_EVENT', 'EVENT'), updateEvent)
router.delete('/:id', logActivity('DELETE_EVENT', 'EVENT'), deleteEvent)

module.exports = router
EOF

    # Contests Routes
    cat > "$APP_DIR/src/routes/contestsRoutes.js" << 'EOF'
const express = require('express')
const { getContestById, getContestsByEvent, createContest, updateContest, deleteContest } = require('../controllers/contestsController')
const { authenticateToken } = require('../middleware/auth')
const { validateContest } = require('../middleware/validation')
const { logActivity } = require('../middleware/errorHandler')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)

// Contests endpoints
router.get('/event/:eventId', getContestsByEvent)
router.get('/:id', getContestById)
router.post('/event/:eventId', validateContest, logActivity('CREATE_CONTEST', 'CONTEST'), createContest)
router.put('/:id', validateContest, logActivity('UPDATE_CONTEST', 'CONTEST'), updateContest)
router.delete('/:id', logActivity('DELETE_CONTEST', 'CONTEST'), deleteContest)

module.exports = router
EOF

    # Categories Routes
    cat > "$APP_DIR/src/routes/categoriesRoutes.js" << 'EOF'
const express = require('express')
const { getAllCategories, getCategoryById, getCategoriesByContest, createCategory, updateCategory, deleteCategory, getCategoryCriteria, createCriterion, updateCriterion, deleteCriterion, updateCategoryWithTimeLimit } = require('../controllers/categoriesController')
const { authenticateToken } = require('../middleware/auth')
const { validateCategory } = require('../middleware/validation')
const { logActivity } = require('../middleware/errorHandler')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)

// Categories endpoints
router.get('/', getAllCategories)
router.get('/contest/:contestId', getCategoriesByContest)
router.get('/:id', getCategoryById)
router.post('/', validateCategory, logActivity('CREATE_CATEGORY', 'CATEGORY'), createCategory)
router.put('/:id', validateCategory, logActivity('UPDATE_CATEGORY', 'CATEGORY'), updateCategory)
router.put('/:id/time-limit', logActivity('UPDATE_CATEGORY_TIME_LIMIT', 'CATEGORY'), updateCategoryWithTimeLimit)
router.delete('/:id', logActivity('DELETE_CATEGORY', 'CATEGORY'), deleteCategory)

// Criteria endpoints
router.get('/:categoryId/criteria', getCategoryCriteria)
router.post('/:categoryId/criteria', logActivity('CREATE_CRITERION', 'CRITERION'), createCriterion)
router.put('/criteria/:criterionId', logActivity('UPDATE_CRITERION', 'CRITERION'), updateCriterion)
router.delete('/criteria/:criterionId', logActivity('DELETE_CRITERION', 'CRITERION'), deleteCriterion)

module.exports = router
EOF

    # Users Routes
    cat > "$APP_DIR/src/routes/usersRoutes.js" << 'EOF'
const express = require('express')
const { getAllUsers, getUserById, createUser, updateUser, deleteUser, resetPassword, importUsersFromCSV, getCSVTemplate, updateLastLogin, bulkRemoveUsers, getUsersByRole, updateUserRoleFields, getUserStats } = require('../controllers/usersController')
const { authenticateToken, requireRole } = require('../middleware/auth')
const { validateUser, validateUserUpdate } = require('../middleware/validation')
const { logActivity } = require('../middleware/errorHandler')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)

// Users endpoints
router.get('/', requireRole(['ORGANIZER', 'BOARD']), getAllUsers)
router.get('/:id', getUserById)
router.post('/', requireRole(['ORGANIZER', 'BOARD']), validateUser, logActivity('CREATE_USER', 'USER'), createUser)
router.put('/:id', requireRole(['ORGANIZER', 'BOARD']), validateUserUpdate, logActivity('UPDATE_USER', 'USER'), updateUser)
router.put('/profile/:id', validateUserUpdate, logActivity('UPDATE_PROFILE', 'USER'), updateUser)
router.delete('/:id', requireRole(['ORGANIZER', 'BOARD']), logActivity('DELETE_USER', 'USER'), deleteUser)
router.post('/:id/reset-password', requireRole(['ORGANIZER', 'BOARD']), resetPassword)

// CSV Import routes
router.post('/import-csv', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), logActivity('IMPORT_USERS_CSV', 'USER'), importUsersFromCSV)
router.get('/csv-template', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), getCSVTemplate)

// User management routes
router.put('/:id/last-login', updateLastLogin)
router.post('/bulk-remove', requireRole(['ORGANIZER', 'BOARD']), logActivity('BULK_REMOVE_USERS', 'USER'), bulkRemoveUsers)
router.get('/role/:role', requireRole(['ORGANIZER', 'BOARD']), getUsersByRole)
router.put('/:id/role-fields', requireRole(['ORGANIZER', 'BOARD']), logActivity('UPDATE_USER_ROLE_FIELDS', 'USER'), updateUserRoleFields)
router.get('/stats', requireRole(['ORGANIZER', 'BOARD']), getUserStats)

module.exports = router
EOF

    # Scoring Routes
    cat > "$APP_DIR/src/routes/scoringRoutes.js" << 'EOF'
const express = require('express')
const { getScores, submitScore, updateScore, deleteScore, certifyScores, certifyTotals, finalCertification, requestDeduction, approveDeduction, rejectDeduction, getDeductions } = require('../controllers/scoringController')
const { authenticateToken, requireRole } = require('../middleware/auth')
const { logActivity } = require('../middleware/errorHandler')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)

// Scoring endpoints
router.get('/category/:categoryId', getScores)
router.get('/category/:categoryId/contestant/:contestantId', getScores)
router.post('/category/:categoryId/contestant/:contestantId', requireRole(['JUDGE']), logActivity('SUBMIT_SCORE', 'SCORE'), submitScore)
router.put('/:scoreId', requireRole(['JUDGE']), logActivity('UPDATE_SCORE', 'SCORE'), updateScore)
router.delete('/:scoreId', requireRole(['JUDGE']), logActivity('DELETE_SCORE', 'SCORE'), deleteScore)
router.post('/category/:categoryId/certify', requireRole(['JUDGE']), certifyScores)
router.post('/category/:categoryId/certify-totals', requireRole(['TALLY_MASTER']), certifyTotals)
router.post('/category/:categoryId/final-certification', requireRole(['AUDITOR']), finalCertification)

// Deduction endpoints
router.post('/deductions', requireRole(['JUDGE', 'TALLY_MASTER', 'AUDITOR', 'BOARD']), logActivity('REQUEST_DEDUCTION', 'DEDUCTION'), requestDeduction)
router.get('/deductions', requireRole(['JUDGE', 'TALLY_MASTER', 'AUDITOR', 'BOARD']), getDeductions)
router.post('/deductions/:deductionId/approve', requireRole(['BOARD', 'AUDITOR', 'TALLY_MASTER']), logActivity('APPROVE_DEDUCTION', 'DEDUCTION'), approveDeduction)
router.post('/deductions/:deductionId/reject', requireRole(['BOARD', 'AUDITOR']), logActivity('REJECT_DEDUCTION', 'DEDUCTION'), rejectDeduction)

module.exports = router
EOF

    # Results Routes
    cat > "$APP_DIR/src/routes/resultsRoutes.js" << 'EOF'
const express = require('express')
const { getAllResults, getCategories, getContestantResults, getCategoryResults, getContestResults, getEventResults } = require('../controllers/resultsController')
const { authenticateToken } = require('../middleware/auth')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)

// Results endpoints
router.get('/', getAllResults)
router.get('/categories', getCategories)
router.get('/contestant/:contestantId', getContestantResults)
router.get('/category/:categoryId', getCategoryResults)
router.get('/contest/:contestId', getContestResults)
router.get('/event/:eventId', getEventResults)

module.exports = router
EOF

    # Admin Routes
    cat > "$APP_DIR/src/routes/adminRoutes.js" << 'EOF'
const express = require('express')
const { getStats, getLogs, getActiveUsers, getUsers, getEvents, getContests, getCategories, getScores, getActivityLogs, getAuditLogs, exportAuditLogs, testConnection } = require('../controllers/adminController')                             
const { getDatabaseTables, getTableData, getTableSchema, executeQuery, getDatabaseStats, insertRecord, updateRecord, deleteRecord, executeCustomQuery } = require('../controllers/databaseBrowserController')                 
const { getSettings, updateSettings, testSettings, updateJWTConfig, getJWTConfig, getLoggingLevels, updateLoggingLevel, getSecuritySettings, updateSecuritySettings, getBackupSettings, updateBackupSettings, getEmailSettings, updateEmailSettings } = require('../controllers/settingsController')
const { authenticateToken, requireRole } = require('../middleware/auth')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)
router.use(requireRole(['ORGANIZER', 'BOARD']))

// Admin endpoints
router.get('/stats', getStats)
router.get('/logs', getLogs)
router.get('/activity-logs', getActivityLogs)
router.get('/active-users', getActiveUsers)
router.get('/users', getUsers)
router.get('/events', getEvents)
router.get('/contests', getContests)
router.get('/categories', getCategories)
router.get('/scores', getScores)
router.get('/audit-logs', getAuditLogs)
router.post('/export-audit-logs', exportAuditLogs)
router.post('/test/:type', testConnection)

// Admin settings endpoints
router.get('/settings', getSettings)
router.get('/settings/logging', getLoggingLevels)
router.put('/settings/logging', updateLoggingLevel)
router.get('/settings/security', getSecuritySettings)
router.put('/settings/security', updateSecuritySettings)
router.get('/settings/backup', getBackupSettings)
router.put('/settings/backup', updateBackupSettings)
router.get('/settings/email', getEmailSettings)
router.put('/settings/email', updateEmailSettings)

// Database browser routes
router.get('/database/tables', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), getDatabaseTables)
router.get('/database/tables/:tableName', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), getTableData)
router.get('/database/tables/:tableName/schema', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), getTableSchema)
router.post('/database/query', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), executeQuery)
router.get('/database/stats', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), getDatabaseStats)

// Database CRUD operations
router.post('/database/insert', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), insertRecord)
router.put('/database/update', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), updateRecord)
router.delete('/database/delete', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), deleteRecord)
router.post('/database/custom-query', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), executeCustomQuery)

module.exports = router
EOF

    # Upload Routes
    cat > "$APP_DIR/src/routes/uploadRoutes.js" << 'EOF'
const express = require('express')
const multer = require('multer')
const { uploadFile, uploadImage, deleteFile, getFiles } = require('../controllers/uploadController')
const { authenticateToken } = require('../middleware/auth')
const { logActivity } = require('../middleware/errorHandler')

const router = express.Router()

// Configure multer for file uploads
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/')
  },
  filename: (req, file, cb) => {
    cb(null, Date.now() + '-' + file.originalname)
  }
})

const upload = multer({ 
  storage: storage,
  limits: { fileSize: 10 * 1024 * 1024 } // 10MB limit
})

// Apply authentication to all routes
router.use(authenticateToken)

// Upload endpoints
router.post('/', upload.single('file'), logActivity('UPLOAD_FILE', 'FILE'), uploadFile)
router.post('/image', upload.single('image'), logActivity('UPLOAD_IMAGE', 'FILE'), uploadImage)
router.delete('/:fileId', logActivity('DELETE_FILE', 'FILE'), deleteFile)
router.get('/files', getFiles)

module.exports = router
EOF

    # Settings Routes
    cat > "$APP_DIR/src/routes/settingsRoutes.js" << 'EOF'
const express = require('express')
const { 
  getAllSettings, 
  getSettings, 
  updateSettings, 
  testSettings, 
  updateJWTConfig, 
  getJWTConfig,
  getLoggingLevels,
  updateLoggingLevel,
  getSecuritySettings,
  updateSecuritySettings,
  getBackupSettings,
  updateBackupSettings,
  getEmailSettings,
  updateEmailSettings
} = require('../controllers/settingsController')
const { authenticateToken, requireRole } = require('../middleware/auth')
const { logActivity } = require('../middleware/errorHandler')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)

// Settings endpoints
router.get('/', getAllSettings)
router.get('/settings', getSettings)
router.put('/', requireRole(['ORGANIZER', 'BOARD']), logActivity('UPDATE_SETTINGS', 'SETTINGS'), updateSettings)
router.put('/settings', requireRole(['ORGANIZER', 'BOARD']), logActivity('UPDATE_SETTINGS', 'SETTINGS'), updateSettings)
router.post('/test/:type', requireRole(['ORGANIZER', 'BOARD']), testSettings)

// Logging settings
router.get('/logging-levels', getLoggingLevels)
router.put('/logging-levels', requireRole(['ORGANIZER', 'BOARD']), logActivity('UPDATE_LOGGING_LEVEL', 'SETTINGS'), updateLoggingLevel)

// Security settings
router.get('/security', getSecuritySettings)
router.put('/security', requireRole(['ORGANIZER', 'BOARD']), logActivity('UPDATE_SECURITY_SETTINGS', 'SETTINGS'), updateSecuritySettings)

// Backup settings
router.get('/backup', getBackupSettings)
router.put('/backup', requireRole(['ORGANIZER', 'BOARD']), logActivity('UPDATE_BACKUP_SETTINGS', 'SETTINGS'), updateBackupSettings)

// Email settings
router.get('/email', getEmailSettings)
router.put('/email', requireRole(['ORGANIZER', 'BOARD']), logActivity('UPDATE_EMAIL_SETTINGS', 'SETTINGS'), updateEmailSettings)

// JWT configuration routes
router.get('/jwt-config', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), getJWTConfig)
router.put('/jwt-config', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), logActivity('UPDATE_JWT_CONFIG', 'SETTINGS'), updateJWTConfig)

module.exports = router
EOF

    # SMS Routes
    cat > "$APP_DIR/src/routes/smsRoutes.js" << 'EOF'
const express = require('express')
const { sendSMS, sendBulkSMS, sendNotificationSMS, getSMSHistory } = require('../controllers/smsController')
const { authenticateToken, requireRole } = require('../middleware/auth')
const { logActivity } = require('../middleware/errorHandler')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)

// SMS endpoints
router.post('/send', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), logActivity('SEND_SMS', 'SMS'), sendSMS)
router.post('/send-bulk', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), logActivity('SEND_BULK_SMS', 'SMS'), sendBulkSMS)
router.post('/send-notification', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), logActivity('SEND_NOTIFICATION_SMS', 'SMS'), sendNotificationSMS)
router.get('/history', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), getSMSHistory)

module.exports = router
EOF

    # Archive Routes
    cat > "$APP_DIR/src/routes/archiveRoutes.js" << 'EOF'
const express = require('express')
const { getAllArchives, archiveEvent, restoreEvent, deleteArchivedItem } = require('../controllers/archiveController')
const { authenticateToken, requireRole } = require('../middleware/auth')
const { logActivity } = require('../middleware/errorHandler')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)

// Archive endpoints
router.get('/', getAllArchives)
router.post('/events/:eventId', requireRole(['ORGANIZER', 'BOARD']), logActivity('ARCHIVE_EVENT', 'EVENT'), archiveEvent)
router.post('/events/:eventId/restore', requireRole(['ORGANIZER', 'BOARD']), logActivity('RESTORE_EVENT', 'EVENT'), restoreEvent)
router.delete('/events/:eventId', requireRole(['ORGANIZER', 'BOARD']), logActivity('DELETE_ARCHIVE', 'EVENT'), deleteArchivedItem)

module.exports = router
EOF

    # Backup Routes
    cat > "$APP_DIR/src/routes/backupRoutes.js" << 'EOF'
const express = require('express')
const multer = require('multer')
const { createBackup, restoreBackup, downloadBackup, listBackups, deleteBackup } = require('../controllers/backupController')
const { authenticateToken, requireRole } = require('../middleware/auth')
const { logActivity } = require('../middleware/errorHandler')

const router = express.Router()

const upload = multer({ dest: 'temp/' })

// Apply authentication to all routes
router.use(authenticateToken)

// Backup endpoints
router.get('/', listBackups)
router.post('/', requireRole(['ORGANIZER', 'BOARD']), logActivity('CREATE_BACKUP', 'BACKUP'), createBackup)
router.post('/create', requireRole(['ORGANIZER', 'BOARD']), logActivity('CREATE_BACKUP', 'BACKUP'), createBackup)
router.post('/restore', requireRole(['ORGANIZER', 'BOARD']), upload.single('backup'), logActivity('RESTORE_BACKUP', 'BACKUP'), restoreBackup)
router.get('/download/:filename', requireRole(['ORGANIZER', 'BOARD']), downloadBackup)
router.delete('/:filename', requireRole(['ORGANIZER', 'BOARD']), logActivity('DELETE_BACKUP', 'BACKUP'), deleteBackup)

module.exports = router
EOF

    # Assignments Routes
    cat > "$APP_DIR/src/routes/assignmentsRoutes.js" << 'EOF'
const express = require('express')
const { 
  getAllAssignments, 
  createAssignment, 
  updateAssignment, 
  deleteAssignment, 
  getJudgeAssignments,
  getJudges,
  getCategories,
  assignJudge,
  removeAssignment 
} = require('../controllers/assignmentsController')
const { authenticateToken, requireRole } = require('../middleware/auth')
const { logActivity } = require('../middleware/errorHandler')
const {
  validateAssignmentCreation,
  validateAssignmentUpdate,
  validateAssignmentDeletion,
  validateBulkAssignmentOperation,
  validateAssignmentQuery
} = require('../middleware/assignmentValidation')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)

// Assignment endpoints with validation
router.get('/', validateAssignmentQuery, getAllAssignments)
router.post('/', validateAssignmentCreation, requireRole(['ORGANIZER', 'BOARD']), logActivity('CREATE_ASSIGNMENT', 'ASSIGNMENT'), createAssignment)
router.put('/:id', validateAssignmentUpdate, requireRole(['ORGANIZER', 'BOARD']), logActivity('UPDATE_ASSIGNMENT', 'ASSIGNMENT'), updateAssignment)
router.delete('/:id', validateAssignmentDeletion, requireRole(['ORGANIZER', 'BOARD']), logActivity('DELETE_ASSIGNMENT', 'ASSIGNMENT'), deleteAssignment)

// Judge-specific endpoints
router.get('/judges', getJudges)
router.get('/judges/:judgeId', validateAssignmentQuery, getJudgeAssignments)
router.get('/categories', getCategories)

// Legacy endpoints for backward compatibility
router.post('/judge', requireRole(['ORGANIZER', 'BOARD']), logActivity('ASSIGN_JUDGE', 'ASSIGNMENT'), assignJudge)
router.put('/remove/:assignmentId', requireRole(['ORGANIZER', 'BOARD']), logActivity('REMOVE_ASSIGNMENT', 'ASSIGNMENT'), removeAssignment)

module.exports = router
EOF

    # Auditor Routes
    cat > "$APP_DIR/src/routes/auditorRoutes.js" << 'EOF'
const express = require('express')
const { 
  getStats, 
  getPendingAudits,
  getCompletedAudits,
  finalCertification, 
  rejectAudit,
  getScoreVerification,
  verifyScore,
  getTallyMasterStatus,
  getCertificationWorkflow,
  generateSummaryReport,
  getAuditHistory
} = require('../controllers/auditorController')
const { authenticateToken, requireRole } = require('../middleware/auth')
const { logActivity } = require('../middleware/errorHandler')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)
router.use(requireRole(['AUDITOR', 'ORGANIZER', 'BOARD']))

// Auditor dashboard endpoints
router.get('/stats', getStats)
router.get('/pending-audits', getPendingAudits)
router.get('/completed-audits', getCompletedAudits)

// Score verification endpoints
router.get('/score-verification/:categoryId', getScoreVerification)
router.get('/score-verification/:categoryId/:contestantId', getScoreVerification)
router.post('/verify-score/:scoreId', logActivity('VERIFY_SCORE', 'SCORE'), verifyScore)

// Tally master status tracking
router.get('/tally-status/:categoryId', getTallyMasterStatus)

// Certification workflow
router.get('/certification-workflow/:categoryId', getCertificationWorkflow)

// Final certification
router.post('/category/:categoryId/final-certification', logActivity('FINAL_CERTIFICATION', 'CATEGORY'), finalCertification)
router.post('/category/:categoryId/reject', logActivity('REJECT_AUDIT', 'CATEGORY'), rejectAudit)

// Summary reports
router.post('/summary-report', logActivity('GENERATE_SUMMARY_REPORT', 'REPORT'), generateSummaryReport)

// Audit history
router.get('/audit-history', getAuditHistory)

module.exports = router
EOF

    # Board Routes
    cat > "$APP_DIR/src/routes/boardRoutes.js" << 'EOF'
const express = require('express')
const { 
  getStats, 
  getCertifications,
  approveCertification,
  rejectCertification,
  getCertificationStatus, 
  getEmceeScripts,
  createEmceeScript,
  updateEmceeScript,
  deleteEmceeScript,
  generateReport,
  getScoreRemovalRequests,
  approveScoreRemoval,
  rejectScoreRemoval
} = require('../controllers/boardController')
const { authenticateToken, requireRole } = require('../middleware/auth')
const { logActivity } = require('../middleware/errorHandler')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)
router.use(requireRole(['BOARD', 'ORGANIZER']))

// Board dashboard endpoints
router.get('/stats', getStats)
router.get('/certifications', getCertifications)
router.get('/certification-status', getCertificationStatus)

// Certification management
router.post('/certifications/:id/approve', logActivity('APPROVE_CERTIFICATION', 'CERTIFICATION'), approveCertification)
router.post('/certifications/:id/reject', logActivity('REJECT_CERTIFICATION', 'CERTIFICATION'), rejectCertification)

// Emcee script management
router.get('/emcee-scripts', getEmceeScripts)
router.post('/emcee-scripts', logActivity('CREATE_EMCEE_SCRIPT', 'EMCEE_SCRIPT'), createEmceeScript)
router.put('/emcee-scripts/:id', logActivity('UPDATE_EMCEE_SCRIPT', 'EMCEE_SCRIPT'), updateEmceeScript)
router.delete('/emcee-scripts/:id', logActivity('DELETE_EMCEE_SCRIPT', 'EMCEE_SCRIPT'), deleteEmceeScript)

// Report generation
router.post('/reports', logActivity('GENERATE_REPORT', 'REPORT'), generateReport)

// Score removal requests
router.get('/score-removal-requests', getScoreRemovalRequests)
router.post('/score-removal-requests/:id/approve', logActivity('APPROVE_SCORE_REMOVAL', 'SCORE_REMOVAL'), approveScoreRemoval)
router.post('/score-removal-requests/:id/reject', logActivity('REJECT_SCORE_REMOVAL', 'SCORE_REMOVAL'), rejectScoreRemoval)

module.exports = router
EOF

    # Tally Master Routes
    cat > "$APP_DIR/src/routes/tallyMasterRoutes.js" << 'EOF'
const express = require('express')
const { 
  getStats, 
  getCertifications,
  getCertificationQueue,
  getPendingCertifications, 
  certifyTotals,
  getScoreReview,
  getCertificationWorkflow,
  getBiasCheckingTools,
  getTallyMasterHistory,
  requestScoreRemoval,
  getScoreRemovalRequests,
  approveScoreRemoval,
  rejectScoreRemoval
} = require('../controllers/tallyMasterController')
const { authenticateToken, requireRole } = require('../middleware/auth')
const { logActivity } = require('../middleware/errorHandler')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)
router.use(requireRole(['TALLY_MASTER', 'ORGANIZER', 'BOARD']))

// Tally Master dashboard endpoints
router.get('/stats', getStats)
router.get('/certifications', getCertifications)
router.get('/certification-queue', getCertificationQueue)
router.get('/pending-certifications', getPendingCertifications)

// Score review interface
router.get('/score-review/:categoryId', getScoreReview)

// Certification workflow
router.get('/certification-workflow/:categoryId', getCertificationWorkflow)

// Bias checking tools
router.get('/bias-checking/:categoryId', getBiasCheckingTools)

// Certify totals
router.post('/certify-totals', logActivity('CERTIFY_TOTALS', 'CATEGORY'), certifyTotals)

// Tally master history
router.get('/history', getTallyMasterHistory)

// Score removal routes
router.post('/score-removal-requests', requireRole(['TALLY_MASTER', 'AUDITOR', 'BOARD']), logActivity('REQUEST_SCORE_REMOVAL', 'SCORE_REMOVAL'), requestScoreRemoval)
router.get('/score-removal-requests', requireRole(['TALLY_MASTER', 'AUDITOR', 'BOARD']), getScoreRemovalRequests)
router.post('/score-removal-requests/:id/approve', requireRole(['TALLY_MASTER', 'AUDITOR', 'BOARD']), logActivity('APPROVE_SCORE_REMOVAL', 'SCORE_REMOVAL'), approveScoreRemoval)
router.post('/score-removal-requests/:id/reject', requireRole(['BOARD', 'AUDITOR']), logActivity('REJECT_SCORE_REMOVAL', 'SCORE_REMOVAL'), rejectScoreRemoval)

module.exports = router
EOF

    # Email Routes
    cat > "$APP_DIR/src/routes/emailRoutes.js" << 'EOF'
const express = require('express')
const { getTemplates, createTemplate, updateTemplate, deleteTemplate, getCampaigns, createCampaign, sendCampaign, getLogs, sendMultipleEmails, sendEmailByRole } = require('../controllers/emailController')
const { authenticateToken, requireRole } = require('../middleware/auth')
const { logActivity } = require('../middleware/errorHandler')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)

// Email endpoints
router.get('/templates', getTemplates)
router.post('/templates', requireRole(['ORGANIZER', 'BOARD']), logActivity('CREATE_EMAIL_TEMPLATE', 'EMAIL'), createTemplate)
router.put('/templates/:id', requireRole(['ORGANIZER', 'BOARD']), logActivity('UPDATE_EMAIL_TEMPLATE', 'EMAIL'), updateTemplate)
router.delete('/templates/:id', requireRole(['ORGANIZER', 'BOARD']), logActivity('DELETE_EMAIL_TEMPLATE', 'EMAIL'), deleteTemplate)
router.get('/campaigns', getCampaigns)
router.post('/campaigns', requireRole(['ORGANIZER', 'BOARD']), logActivity('CREATE_EMAIL_CAMPAIGN', 'EMAIL'), createCampaign)
router.post('/campaigns/:id/send', requireRole(['ORGANIZER', 'BOARD']), logActivity('SEND_CAMPAIGN', 'EMAIL'), sendCampaign)
router.get('/logs', getLogs)

// Multiple recipient email endpoints
router.post('/send-multiple', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), logActivity('SEND_MULTIPLE_EMAILS', 'EMAIL'), sendMultipleEmails)
router.post('/send-by-role', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), logActivity('SEND_EMAIL_BY_ROLE', 'EMAIL'), sendEmailByRole)

module.exports = router
EOF

    # Reports Routes
    cat > "$APP_DIR/src/routes/reportsRoutes.js" << 'EOF'
const express = require('express')
const { 
  getTemplates, 
  generateReport, 
  getHistory,
  generateEventReport,
  generateContestResultsReport,
  generateJudgePerformanceReport,
  generateSystemAnalyticsReport,
  getAllReports,
  getReportById,
  deleteReport,
  exportReport,
  emailReport
} = require('../controllers/reportsController')
const { authenticateToken, requireRole } = require('../middleware/auth')
const { logActivity } = require('../middleware/errorHandler')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)

// Report templates and basic reports
router.get('/templates', getTemplates)
router.post('/generate', requireRole(['ORGANIZER', 'BOARD', 'JUDGE']), logActivity('GENERATE_REPORT', 'REPORT'), generateReport)
router.get('/history', getHistory)

// Advanced reporting endpoints
router.post('/event', requireRole(['ORGANIZER', 'BOARD']), logActivity('GENERATE_EVENT_REPORT', 'REPORT'), generateEventReport)
router.post('/contest-results', requireRole(['ORGANIZER', 'BOARD', 'AUDITOR']), logActivity('GENERATE_CONTEST_RESULTS_REPORT', 'REPORT'), generateContestResultsReport)
router.post('/judge-performance', requireRole(['ORGANIZER', 'BOARD', 'AUDITOR']), logActivity('GENERATE_JUDGE_PERFORMANCE_REPORT', 'REPORT'), generateJudgePerformanceReport)
router.post('/system-analytics', requireRole(['ORGANIZER', 'BOARD']), logActivity('GENERATE_SYSTEM_ANALYTICS_REPORT', 'REPORT'), generateSystemAnalyticsReport)

// Report management
router.get('/', getAllReports)
router.get('/:id', getReportById)
router.delete('/:id', requireRole(['ORGANIZER', 'BOARD']), logActivity('DELETE_REPORT', 'REPORT'), deleteReport)
router.post('/:id/export', requireRole(['ORGANIZER', 'BOARD', 'AUDITOR']), logActivity('EXPORT_REPORT', 'REPORT'), exportReport)
router.post('/:id/email', requireRole(['ORGANIZER', 'BOARD', 'AUDITOR']), logActivity('EMAIL_REPORT', 'REPORT'), emailReport)

module.exports = router
EOF

    # Print Routes
    cat > "$APP_DIR/src/routes/printRoutes.js" << 'EOF'
const express = require('express')
const { 
  getPrintTemplates, 
  createPrintTemplate, 
  updatePrintTemplate, 
  deletePrintTemplate,
  printEventReport,
  printContestResults,
  printJudgePerformance
} = require('../controllers/printController')
const { authenticateToken, requireRole } = require('../middleware/auth')
const { logActivity } = require('../middleware/errorHandler')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)

// Print template management
router.get('/templates', getPrintTemplates)
router.post('/templates', requireRole(['ORGANIZER', 'BOARD']), logActivity('CREATE_PRINT_TEMPLATE', 'TEMPLATE'), createPrintTemplate)
router.put('/templates/:id', requireRole(['ORGANIZER', 'BOARD']), logActivity('UPDATE_PRINT_TEMPLATE', 'TEMPLATE'), updatePrintTemplate)
router.delete('/templates/:id', requireRole(['ORGANIZER', 'BOARD']), logActivity('DELETE_PRINT_TEMPLATE', 'TEMPLATE'), deletePrintTemplate)

// Print functionality
router.post('/event-report', requireRole(['ORGANIZER', 'BOARD', 'AUDITOR']), logActivity('PRINT_EVENT_REPORT', 'PRINT'), printEventReport)
router.post('/contest-results', requireRole(['ORGANIZER', 'BOARD', 'AUDITOR']), logActivity('PRINT_CONTEST_RESULTS', 'PRINT'), printContestResults)
router.post('/judge-performance', requireRole(['ORGANIZER', 'BOARD', 'AUDITOR']), logActivity('PRINT_JUDGE_PERFORMANCE', 'PRINT'), printJudgePerformance)

module.exports = router
EOF

    # File Management Routes
    cat > "$APP_DIR/src/routes/fileManagementRoutes.js" << 'EOF'
const express = require('express')
const { 
  getFilesWithFilters,
  bulkFileOperations,
  getFileSearchSuggestions,
  getFileAnalytics,
  checkFileIntegrity,
  bulkCheckFileIntegrity
} = require('../controllers/fileManagementController')
const { authenticateToken, requireRole } = require('../middleware/auth')
const { logActivity } = require('../middleware/errorHandler')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)

// File management interface
router.get('/files', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), getFilesWithFilters)
router.post('/files/bulk', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), logActivity('BULK_FILE_OPERATION', 'FILE'), bulkFileOperations)

// File search and suggestions
router.get('/files/search', getFileSearchSuggestions)

// File analytics
router.get('/files/analytics', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), getFileAnalytics)

// File integrity checks
router.get('/files/:fileId/integrity', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), checkFileIntegrity)
router.post('/files/integrity/bulk', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), logActivity('BULK_INTEGRITY_CHECK', 'FILE'), bulkCheckFileIntegrity)

module.exports = router
EOF

    # File Backup and Recovery Controller
    cat > "$APP_DIR/src/controllers/fileBackupController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')
const fs = require('fs').promises
const path = require('path')
const { exec } = require('child_process')
const { promisify } = require('util')
const { generateSecurePassword, encryptMetadata, decryptMetadata } = require('../middleware/fileEncryption')

const prisma = new PrismaClient()
const execAsync = promisify(exec)

// File Backup and Recovery Functions

// Create file backup
const createFileBackup = async (req, res) => {
  try {
    const { backupType = 'FULL', description = '', includeMetadata = true } = req.body

    const backupId = `file-backup-${Date.now()}`
    const backupDir = path.join(__dirname, '../backups/files', backupId)
    
    // Create backup directory
    await fs.mkdir(backupDir, { recursive: true })

    let backupData = {
      id: backupId,
      type: backupType,
      description,
      createdAt: new Date().toISOString(),
      createdBy: req.user.id,
      status: 'IN_PROGRESS',
      files: [],
      metadata: {}
    }

    // Get all files to backup
    const files = await prisma.file.findMany({
      include: {
        user: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true,
            role: true
          }
        }
      }
    })

    let totalSize = 0
    let processedFiles = 0
    const errors = []

    for (const file of files) {
      try {
        // Check if file exists on disk
        const fileExists = await fs.access(file.path).then(() => true).catch(() => false)
        
        if (!fileExists) {
          errors.push({ fileId: file.id, error: 'File not found on disk' })
          continue
        }

        // Create file backup entry
        const fileBackup = {
          id: file.id,
          filename: file.filename,
          originalName: file.originalName,
          mimeType: file.mimeType,
          size: file.size,
          category: file.category,
          uploadedAt: file.uploadedAt,
          uploadedBy: file.uploadedBy,
          isPublic: file.isPublic,
          checksum: file.checksum,
          metadata: includeMetadata ? file.metadata : null,
          user: file.user
        }

        // Copy file to backup directory
        const backupFilePath = path.join(backupDir, file.filename)
        await fs.copyFile(file.path, backupFilePath)

        // Verify backup integrity
        const stats = await fs.stat(backupFilePath)
        if (stats.size !== file.size) {
          errors.push({ fileId: file.id, error: 'Backup size mismatch' })
          await fs.unlink(backupFilePath)
          continue
        }

        backupData.files.push(fileBackup)
        totalSize += file.size
        processedFiles++

      } catch (error) {
        errors.push({ fileId: file.id, error: error.message })
      }
    }

    // Create backup manifest
    backupData.metadata = {
      totalFiles: files.length,
      processedFiles,
      totalSize,
      errors,
      backupVersion: '1.0',
      systemInfo: {
        nodeVersion: process.version,
        platform: process.platform,
        arch: process.arch
      }
    }

    // Save backup manifest
    const manifestPath = path.join(backupDir, 'manifest.json')
    await fs.writeFile(manifestPath, JSON.stringify(backupData, null, 2))

    // Create compressed backup
    const compressedPath = `${backupDir}.tar.gz`
    await execAsync(`tar -czf "${compressedPath}" -C "${path.dirname(backupDir)}" "${path.basename(backupDir)}"`)

    // Remove uncompressed directory
    await fs.rmdir(backupDir, { recursive: true })

    // Save backup record to database
    const backupRecord = await prisma.report.create({
      data: {
        name: `File Backup - ${backupType}`,
        description: description || `File backup created on ${new Date().toISOString()}`,
        type: 'FILE_BACKUP',
        parameters: {
          backupId,
          backupType,
          totalFiles: files.length,
          processedFiles,
          totalSize,
          errors: errors.length
        },
        generatedBy: req.user.id,
        status: 'COMPLETED'
      }
    })

    res.json({
      backup: backupRecord,
      backupData: {
        id: backupId,
        type: backupType,
        totalFiles: files.length,
        processedFiles,
        totalSize,
        errors: errors.length,
        compressedPath,
        manifestPath
      },
      message: 'File backup created successfully'
    })
  } catch (error) {
    console.error('Create file backup error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Restore file backup
const restoreFileBackup = async (req, res) => {
  try {
    const { backupId } = req.params
    const { restoreOptions = {} } = req.body

    const backupDir = path.join(__dirname, '../backups/files', backupId)
    const compressedPath = `${backupDir}.tar.gz`

    // Check if backup exists
    const backupExists = await fs.access(compressedPath).then(() => true).catch(() => false)
    
    if (!backupExists) {
      return res.status(404).json({ error: 'Backup not found' })
    }

    // Extract backup
    await execAsync(`tar -xzf "${compressedPath}" -C "${path.dirname(backupDir)}"`)

    // Read backup manifest
    const manifestPath = path.join(backupDir, 'manifest.json')
    const manifestData = await fs.readFile(manifestPath, 'utf8')
    const backupData = JSON.parse(manifestData)

    const restoreResults = {
      restored: 0,
      skipped: 0,
      errors: [],
      totalSize: 0
    }

    // Restore files
    for (const fileBackup of backupData.files) {
      try {
        // Check if file already exists
        const existingFile = await prisma.file.findUnique({
          where: { id: fileBackup.id }
        })

        if (existingFile && !restoreOptions.overwrite) {
          restoreResults.skipped++
          continue
        }

        // Restore file to original location
        const backupFilePath = path.join(backupDir, fileBackup.filename)
        const fileExists = await fs.access(backupFilePath).then(() => true).catch(() => false)
        
        if (!fileExists) {
          restoreResults.errors.push({ fileId: fileBackup.id, error: 'Backup file not found' })
          continue
        }

        // Create directory if it doesn't exist
        const targetDir = path.dirname(fileBackup.path || `/uploads/${fileBackup.filename}`)
        await fs.mkdir(targetDir, { recursive: true })

        // Copy file back
        const targetPath = fileBackup.path || `/uploads/${fileBackup.filename}`
        await fs.copyFile(backupFilePath, targetPath)

        // Update or create database record
        if (existingFile) {
          await prisma.file.update({
            where: { id: fileBackup.id },
            data: {
              filename: fileBackup.filename,
              originalName: fileBackup.originalName,
              mimeType: fileBackup.mimeType,
              size: fileBackup.size,
              category: fileBackup.category,
              path: targetPath,
              checksum: fileBackup.checksum,
              metadata: fileBackup.metadata,
              isPublic: fileBackup.isPublic
            }
          })
        } else {
          await prisma.file.create({
            data: {
              id: fileBackup.id,
              filename: fileBackup.filename,
              originalName: fileBackup.originalName,
              mimeType: fileBackup.mimeType,
              size: fileBackup.size,
              category: fileBackup.category,
              path: targetPath,
              uploadedBy: fileBackup.uploadedBy,
              uploadedAt: new Date(fileBackup.uploadedAt),
              checksum: fileBackup.checksum,
              metadata: fileBackup.metadata,
              isPublic: fileBackup.isPublic
            }
          })
        }

        restoreResults.restored++
        restoreResults.totalSize += fileBackup.size

      } catch (error) {
        restoreResults.errors.push({ fileId: fileBackup.id, error: error.message })
      }
    }

    // Clean up extracted files
    await fs.rmdir(backupDir, { recursive: true })

    // Log restore operation
    await prisma.report.create({
      data: {
        name: `File Restore - ${backupId}`,
        description: `File backup restored on ${new Date().toISOString()}`,
        type: 'FILE_RESTORE',
        parameters: {
          backupId,
          restoreResults
        },
        generatedBy: req.user.id,
        status: 'COMPLETED'
      }
    })

    res.json({
      restoreResults,
      message: 'File backup restored successfully'
    })
  } catch (error) {
    console.error('Restore file backup error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// List file backups
const listFileBackups = async (req, res) => {
  try {
    const backups = await prisma.report.findMany({
      where: {
        type: {
          in: ['FILE_BACKUP', 'FILE_RESTORE']
        }
      },
      orderBy: { createdAt: 'desc' },
      take: 50,
      include: {
        user: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true
          }
        }
      }
    })

    res.json({
      backups,
      message: 'File backups retrieved successfully'
    })
  } catch (error) {
    console.error('List file backups error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Delete file backup
const deleteFileBackup = async (req, res) => {
  try {
    const { backupId } = req.params

    // Find backup record
    const backup = await prisma.report.findFirst({
      where: {
        type: 'FILE_BACKUP',
        parameters: {
          path: ['backupId'],
          equals: backupId
        }
      }
    })

    if (!backup) {
      return res.status(404).json({ error: 'Backup not found' })
    }

    // Delete backup files
    const compressedPath = path.join(__dirname, '../backups/files', `${backupId}.tar.gz`)
    const backupExists = await fs.access(compressedPath).then(() => true).catch(() => false)
    
    if (backupExists) {
      await fs.unlink(compressedPath)
    }

    // Delete backup record
    await prisma.report.delete({
      where: { id: backup.id }
    })

    res.json({ message: 'File backup deleted successfully' })
  } catch (error) {
    console.error('Delete file backup error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get backup details
const getBackupDetails = async (req, res) => {
  try {
    const { backupId } = req.params

    const backup = await prisma.report.findFirst({
      where: {
        type: 'FILE_BACKUP',
        parameters: {
          path: ['backupId'],
          equals: backupId
        }
      },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true
          }
        }
      }
    })

    if (!backup) {
      return res.status(404).json({ error: 'Backup not found' })
    }

    // Check if backup file exists
    const compressedPath = path.join(__dirname, '../backups/files', `${backupId}.tar.gz`)
    const backupExists = await fs.access(compressedPath).then(() => true).catch(() => false)

    const stats = backupExists ? await fs.stat(compressedPath) : null

    res.json({
      backup: {
        ...backup,
        fileExists: backupExists,
        fileSize: stats ? stats.size : 0,
        lastModified: stats ? stats.mtime : null
      },
      message: 'Backup details retrieved successfully'
    })
  } catch (error) {
    console.error('Get backup details error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Download backup
const downloadBackup = async (req, res) => {
  try {
    const { backupId } = req.params

    const compressedPath = path.join(__dirname, '../backups/files', `${backupId}.tar.gz`)
    const backupExists = await fs.access(compressedPath).then(() => true).catch(() => false)
    
    if (!backupExists) {
      return res.status(404).json({ error: 'Backup file not found' })
    }

    const stats = await fs.stat(compressedPath)
    
    res.setHeader('Content-Type', 'application/gzip')
    res.setHeader('Content-Disposition', 'attachment; filename="' + backupId + '.tar.gz"')
    res.setHeader('Content-Length', stats.size)

    const fileStream = require('fs').createReadStream(compressedPath)
    fileStream.pipe(res)
  } catch (error) {
    console.error('Download backup error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

module.exports = {
  createFileBackup,
  restoreFileBackup,
  listFileBackups,
  deleteFileBackup,
  getBackupDetails,
  downloadBackup
}
EOF

    # File Backup Routes
    cat > "$APP_DIR/src/routes/fileBackupRoutes.js" << 'EOF'
const express = require('express')
const { 
  createFileBackup,
  restoreFileBackup,
  listFileBackups,
  deleteFileBackup,
  getBackupDetails,
  downloadBackup
} = require('../controllers/fileBackupController')
const { authenticateToken, requireRole } = require('../middleware/auth')
const { logActivity } = require('../middleware/errorHandler')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)

// File backup operations
router.post('/create', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), logActivity('CREATE_FILE_BACKUP', 'BACKUP'), createFileBackup)
router.post('/:backupId/restore', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), logActivity('RESTORE_FILE_BACKUP', 'BACKUP'), restoreFileBackup)
router.get('/', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), listFileBackups)
router.get('/:backupId', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), getBackupDetails)
router.get('/:backupId/download', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), downloadBackup)
router.delete('/:backupId', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), logActivity('DELETE_FILE_BACKUP', 'BACKUP'), deleteFileBackup)

module.exports = router
EOF
    cat > "$APP_DIR/src/routes/performanceRoutes.js" << 'EOF'
const express = require('express')
const { 
  getPerformanceStats,
  getSystemMetrics,
  getPerformanceLogs,
  clearPerformanceLogs,
  getHealthCheck
} = require('../controllers/performanceController')
const { authenticateToken, requireRole } = require('../middleware/auth')
const { logActivity } = require('../middleware/errorHandler')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)

// Performance monitoring
router.get('/metrics', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), getSystemMetrics)
router.get('/stats', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), getPerformanceStats)
router.get('/logs', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), getPerformanceLogs)
router.get('/health', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), getHealthCheck)
router.post('/clear-logs', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), logActivity('CLEAR_PERFORMANCE_LOGS', 'SYSTEM'), clearPerformanceLogs)

module.exports = router
EOF

    # Comprehensive Error Handling Controller
    cat > "$APP_DIR/src/controllers/errorHandlingController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')
const fs = require('fs').promises
const path = require('path')

const prisma = new PrismaClient()

// Comprehensive Error Handling Functions

// Log error with context
const logError = async (error, context = {}) => {
  try {
    const errorLog = {
      message: error.message,
      stack: error.stack,
      name: error.name,
      timestamp: new Date().toISOString(),
      context: {
        userId: context.userId,
        userAgent: context.userAgent,
        ipAddress: context.ipAddress,
        url: context.url,
        method: context.method,
        body: context.body,
        query: context.query,
        params: context.params,
        ...context.additionalContext
      },
      severity: determineErrorSeverity(error),
      category: categorizeError(error),
      resolved: false
    }

    // Save to database
    await prisma.activityLog.create({
      data: {
        action: `ERROR_${errorLog.category}`,
        resourceType: 'ERROR',
        resourceId: `error-${Date.now()}`,
        userId: context.userId,
        details: errorLog,
        severity: errorLog.severity
      }
    })

    // Save to file for detailed analysis
    await saveErrorToFile(errorLog)

    return errorLog
  } catch (logError) {
    console.error('Failed to log error:', logError)
    // Fallback to console
    console.error('Original error:', error)
  }
}

// Determine error severity
const determineErrorSeverity = (error) => {
  if (error.name === 'ValidationError' || error.name === 'CastError') {
    return 'LOW'
  }
  if (error.name === 'UnauthorizedError' || error.name === 'ForbiddenError') {
    return 'MEDIUM'
  }
  if (error.name === 'DatabaseError' || error.name === 'ConnectionError') {
    return 'HIGH'
  }
  if (error.name === 'SyntaxError' || error.name === 'ReferenceError') {
    return 'CRITICAL'
  }
  return 'MEDIUM'
}

// Categorize error type
const categorizeError = (error) => {
  if (error.name === 'ValidationError') return 'VALIDATION'
  if (error.name === 'DatabaseError') return 'DATABASE'
  if (error.name === 'AuthenticationError') return 'AUTHENTICATION'
  if (error.name === 'AuthorizationError') return 'AUTHORIZATION'
  if (error.name === 'NetworkError') return 'NETWORK'
  if (error.name === 'FileSystemError') return 'FILESYSTEM'
  if (error.name === 'SyntaxError') return 'SYNTAX'
  if (error.name === 'ReferenceError') return 'REFERENCE'
  return 'UNKNOWN'
}

// Save error to file for detailed analysis
const saveErrorToFile = async (errorLog) => {
  try {
    const errorDir = path.join(__dirname, '../logs/errors')
    await fs.mkdir(errorDir, { recursive: true })

    const filename = `error-${Date.now()}-${errorLog.category.toLowerCase()}.json`
    const filepath = path.join(errorDir, filename)

    await fs.writeFile(filepath, JSON.stringify(errorLog, null, 2))
  } catch (error) {
    console.error('Failed to save error to file:', error)
  }
}

// Get error statistics
const getErrorStatistics = async (req, res) => {
  try {
    const { period = '24h' } = req.query

    // Calculate time range
    const now = new Date()
    const periodHours = period === '1h' ? 1 : period === '6h' ? 6 : period === '24h' ? 24 : period === '7d' ? 168 : 24
    const startTime = new Date(now.getTime() - (periodHours * 60 * 60 * 1000))

    // Get error counts by category
    const errorCounts = await prisma.activityLog.groupBy({
      by: ['action'],
      where: {
        createdAt: { gte: startTime },
        action: { startsWith: 'ERROR_' }
      },
      _count: { id: true }
    })

    // Get error counts by severity
    const severityCounts = await prisma.activityLog.groupBy({
      by: ['severity'],
      where: {
        createdAt: { gte: startTime },
        action: { startsWith: 'ERROR_' }
      },
      _count: { id: true }
    })

    // Get recent errors
    const recentErrors = await prisma.activityLog.findMany({
      where: {
        createdAt: { gte: startTime },
        action: { startsWith: 'ERROR_' }
      },
      orderBy: { createdAt: 'desc' },
      take: 20,
      include: {
        user: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true
          }
        }
      }
    })

    // Calculate error rate
    const totalActivity = await prisma.activityLog.count({
      where: { createdAt: { gte: startTime } }
    })
    const totalErrors = await prisma.activityLog.count({
      where: {
        createdAt: { gte: startTime },
        action: { startsWith: 'ERROR_' }
      }
    })

    res.json({
      period,
      statistics: {
        totalErrors,
        totalActivity,
        errorRate: totalActivity > 0 ? (totalErrors / totalActivity) * 100 : 0,
        categoryCounts: errorCounts,
        severityCounts
      },
      recentErrors,
      generatedAt: new Date().toISOString()
    })
  } catch (error) {
    console.error('Get error statistics error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get error details
const getErrorDetails = async (req, res) => {
  try {
    const { errorId } = req.params

    const error = await prisma.activityLog.findUnique({
      where: { id: errorId },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true,
            role: true
          }
        }
      }
    })

    if (!error) {
      return res.status(404).json({ error: 'Error not found' })
    }

    res.json({ error })
  } catch (error) {
    console.error('Get error details error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Mark error as resolved
const markErrorResolved = async (req, res) => {
  try {
    const { errorId } = req.params
    const { resolution, notes } = req.body

    const error = await prisma.activityLog.findUnique({
      where: { id: errorId }
    })

    if (!error) {
      return res.status(404).json({ error: 'Error not found' })
    }

    // Update error details
    const updatedDetails = {
      ...error.details,
      resolved: true,
      resolvedAt: new Date().toISOString(),
      resolvedBy: req.user.id,
      resolution,
      notes
    }

    await prisma.activityLog.update({
      where: { id: errorId },
      data: {
        details: updatedDetails
      }
    })

    res.json({ message: 'Error marked as resolved' })
  } catch (error) {
    console.error('Mark error resolved error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Get error trends
const getErrorTrends = async (req, res) => {
  try {
    const { period = '7d' } = req.query

    // Calculate time range
    const now = new Date()
    const periodDays = period === '1d' ? 1 : period === '7d' ? 7 : period === '30d' ? 30 : 7
    const startTime = new Date(now.getTime() - (periodDays * 24 * 60 * 60 * 1000))

    // Get daily error counts
    const dailyErrors = await prisma.activityLog.groupBy({
      by: ['createdAt'],
      where: {
        createdAt: { gte: startTime },
        action: { startsWith: 'ERROR_' }
      },
      _count: { id: true },
      orderBy: { createdAt: 'asc' }
    })

    // Get error trends by category
    const categoryTrends = await prisma.activityLog.groupBy({
      by: ['action', 'createdAt'],
      where: {
        createdAt: { gte: startTime },
        action: { startsWith: 'ERROR_' }
      },
      _count: { id: true },
      orderBy: { createdAt: 'asc' }
    })

    res.json({
      period,
      dailyErrors,
      categoryTrends,
      generatedAt: new Date().toISOString()
    })
  } catch (error) {
    console.error('Get error trends error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Clean up old error logs
const cleanupErrorLogs = async (req, res) => {
  try {
    const { daysToKeep = 30 } = req.body

    const cutoffDate = new Date(Date.now() - (daysToKeep * 24 * 60 * 60 * 1000))

    const deletedCount = await prisma.activityLog.deleteMany({
      where: {
        createdAt: { lt: cutoffDate },
        action: { startsWith: 'ERROR_' }
      }
    })

    // Also clean up error files
    const errorDir = path.join(__dirname, '../logs/errors')
    try {
      const files = await fs.readdir(errorDir)
      let deletedFiles = 0

      for (const file of files) {
        const filepath = path.join(errorDir, file)
        const stats = await fs.stat(filepath)
        
        if (stats.mtime < cutoffDate) {
          await fs.unlink(filepath)
          deletedFiles++
        }
      }

      res.json({
        deletedLogs: deletedCount.count,
        deletedFiles,
        cutoffDate: cutoffDate.toISOString(),
        message: 'Error logs cleanup completed'
      })
    } catch (fileError) {
      res.json({
        deletedLogs: deletedCount.count,
        deletedFiles: 0,
        cutoffDate: cutoffDate.toISOString(),
        message: 'Error logs cleanup completed (file cleanup failed)'
      })
    }
  } catch (error) {
    console.error('Cleanup error logs error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Export error logs
const exportErrorLogs = async (req, res) => {
  try {
    const { format = 'json', period = '7d' } = req.query

    // Calculate time range
    const now = new Date()
    const periodDays = period === '1d' ? 1 : period === '7d' ? 7 : period === '30d' ? 30 : 7
    const startTime = new Date(now.getTime() - (periodDays * 24 * 60 * 60 * 1000))

    const errors = await prisma.activityLog.findMany({
      where: {
        createdAt: { gte: startTime },
        action: { startsWith: 'ERROR_' }
      },
      orderBy: { createdAt: 'desc' },
      include: {
        user: {
          select: {
            id: true,
            name: true,
            preferredName: true,
            email: true,
            role: true
          }
        }
      }
    })

    if (format === 'csv') {
      const csv = convertToCSV(errors)
      res.setHeader('Content-Type', 'text/csv')
      res.setHeader('Content-Disposition', 'attachment; filename="error-logs-' + period + '.csv"')
      res.send(csv)
    } else {
      res.json({
        errors,
        period,
        totalCount: errors.length,
        generatedAt: new Date().toISOString()
      })
    }
  } catch (error) {
    console.error('Export error logs error:', error)
    res.status(500).json({ error: 'Internal server error' })
  }
}

// Convert errors to CSV format
const convertToCSV = (errors) => {
  const headers = ['Timestamp', 'Action', 'Severity', 'User', 'Message', 'Details']
  const rows = errors.map(error => [
    error.createdAt.toISOString(),
    error.action,
    error.severity,
    error.user?.preferredName || error.user?.name || 'Unknown',
    error.details?.message || '',
    JSON.stringify(error.details)
  ])

  return [headers, ...rows].map(row => row.join(',')).join('\n')
}

module.exports = {
  logError,
  getErrorStatistics,
  getErrorDetails,
  markErrorResolved,
  getErrorTrends,
  cleanupErrorLogs,
  exportErrorLogs
}
EOF

    # Assignment Validation Middleware
    cat > "$APP_DIR/src/middleware/assignmentValidation.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

// Assignment Validation Middleware Functions

// Validate assignment creation
const validateAssignmentCreation = async (req, res, next) => {
  try {
    const { judgeId, categoryId, eventId, contestId } = req.body

    // Check if judge exists and has JUDGE role
    const judge = await prisma.user.findUnique({
      where: { id: judgeId },
      include: { judge: true }
    })

    if (!judge) {
      return res.status(404).json({ error: 'Judge not found' })
    }

    if (judge.role !== 'JUDGE') {
      return res.status(400).json({ error: 'User must have JUDGE role to be assigned' })
    }

    // Check if category exists
    const category = await prisma.category.findUnique({
      where: { id: categoryId },
      include: {
        contest: {
          include: {
            event: true
          }
        }
      }
    })

    if (!category) {
      return res.status(404).json({ error: 'Category not found' })
    }

    // Validate event and contest relationships
    if (eventId && category.contest.eventId !== eventId) {
      return res.status(400).json({ error: 'Category does not belong to the specified event' })
    }

    if (contestId && category.contestId !== contestId) {
      return res.status(400).json({ error: 'Category does not belong to the specified contest' })
    }

    // Check for existing assignment
    const existingAssignment = await prisma.assignment.findFirst({
      where: {
        judgeId,
        categoryId,
        status: {
          in: ['PENDING', 'ACCEPTED', 'IN_PROGRESS']
        }
      }
    })

    if (existingAssignment) {
      return res.status(400).json({ error: 'Judge is already assigned to this category' })
    }

    // Check judge availability (no overlapping assignments)
    const overlappingAssignments = await prisma.assignment.findMany({
      where: {
        judgeId,
        status: {
          in: ['ACCEPTED', 'IN_PROGRESS']
        },
        category: {
          contest: {
            event: {
              startDate: {
                lte: category.contest.event.endDate
              },
              endDate: {
                gte: category.contest.event.startDate
              }
            }
          }
        }
      }
    })

    if (overlappingAssignments.length > 0) {
      return res.status(400).json({ 
        error: 'Judge has overlapping assignments during this event period',
        conflictingAssignments: overlappingAssignments.map(a => ({
          id: a.id,
          categoryId: a.categoryId,
          eventName: a.category?.contest?.event?.name
        }))
      })
    }

    // Check category capacity (max judges per category)
    const currentAssignments = await prisma.assignment.count({
      where: {
        categoryId,
        status: {
          in: ['ACCEPTED', 'IN_PROGRESS']
        }
      }
    })

    const maxJudgesPerCategory = 5 // This could be configurable
    if (currentAssignments >= maxJudgesPerCategory) {
      return res.status(400).json({ 
        error: `Category has reached maximum judge capacity (${maxJudgesPerCategory})`,
        currentAssignments,
        maxCapacity: maxJudgesPerCategory
      })
    }

    // Check judge workload (max categories per judge per event)
    const judgeEventAssignments = await prisma.assignment.count({
      where: {
        judgeId,
        status: {
          in: ['ACCEPTED', 'IN_PROGRESS']
        },
        category: {
          contest: {
            eventId: category.contest.eventId
          }
        }
      }
    })

    const maxCategoriesPerJudge = 3 // This could be configurable
    if (judgeEventAssignments >= maxCategoriesPerJudge) {
      return res.status(400).json({ 
        error: `Judge has reached maximum category assignments for this event (${maxCategoriesPerJudge})`,
        currentAssignments: judgeEventAssignments,
        maxCapacity: maxCategoriesPerJudge
      })
    }

    // Add validation data to request for use in controller
    req.validationData = {
      judge,
      category,
      currentAssignments,
      judgeEventAssignments
    }

    next()
  } catch (error) {
    console.error('Assignment validation error:', error)
    res.status(500).json({ error: 'Internal server error during validation' })
  }
}

// Validate assignment update
const validateAssignmentUpdate = async (req, res, next) => {
  try {
    const { assignmentId } = req.params
    const { status, notes } = req.body

    // Check if assignment exists
    const assignment = await prisma.assignment.findUnique({
      where: { id: assignmentId },
      include: {
        judge: {
          include: {
            user: true
          }
        },
        category: {
          include: {
            contest: {
              include: {
                event: true
              }
            }
          }
        }
      }
    })

    if (!assignment) {
      return res.status(404).json({ error: 'Assignment not found' })
    }

    // Validate status transition
    const validTransitions = {
      'PENDING': ['ACCEPTED', 'REJECTED'],
      'ACCEPTED': ['IN_PROGRESS', 'COMPLETED', 'CANCELLED'],
      'IN_PROGRESS': ['COMPLETED', 'CANCELLED'],
      'COMPLETED': [], // No transitions from completed
      'REJECTED': [], // No transitions from rejected
      'CANCELLED': [] // No transitions from cancelled
    }

    if (status && !validTransitions[assignment.status]?.includes(status)) {
      return res.status(400).json({ 
        error: `Invalid status transition from ${assignment.status} to ${status}`,
        validTransitions: validTransitions[assignment.status]
      })
    }

    // Validate user permissions for status changes
    const userRole = req.user.role
    const allowedStatusChanges = {
      'JUDGE': ['ACCEPTED', 'REJECTED', 'IN_PROGRESS', 'COMPLETED'],
      'ORGANIZER': ['ACCEPTED', 'REJECTED', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED'],
      'BOARD': ['ACCEPTED', 'REJECTED', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED'],
      'ADMIN': ['ACCEPTED', 'REJECTED', 'IN_PROGRESS', 'COMPLETED', 'CANCELLED']
    }

    if (status && !allowedStatusChanges[userRole]?.includes(status)) {
      return res.status(403).json({ 
        error: `User role ${userRole} is not authorized to change status to ${status}`,
        allowedChanges: allowedStatusChanges[userRole]
      })
    }

    // Special validation for judge accepting/rejecting their own assignment
    if (userRole === 'JUDGE' && assignment.judgeId !== req.user.id) {
      return res.status(403).json({ 
        error: 'Judges can only modify their own assignments' 
      })
    }

    // Validate completion requirements
    if (status === 'COMPLETED') {
      // Check if all required scores are submitted
      const requiredScores = await prisma.score.count({
        where: {
          categoryId: assignment.categoryId,
          judgeId: assignment.judgeId
        }
      })

      const totalContestants = await prisma.categoryContestant.count({
        where: {
          categoryId: assignment.categoryId
        }
      })

      if (requiredScores < totalContestants) {
        return res.status(400).json({ 
          error: 'Cannot complete assignment: not all scores have been submitted',
          submittedScores: requiredScores,
          requiredScores: totalContestants
        })
      }
    }

    // Add validation data to request
    req.validationData = {
      assignment,
      validTransitions: validTransitions[assignment.status],
      allowedChanges: allowedStatusChanges[userRole]
    }

    next()
  } catch (error) {
    console.error('Assignment update validation error:', error)
    res.status(500).json({ error: 'Internal server error during validation' })
  }
}

// Validate assignment deletion
const validateAssignmentDeletion = async (req, res, next) => {
  try {
    const { assignmentId } = req.params

    const assignment = await prisma.assignment.findUnique({
      where: { id: assignmentId },
      include: {
        judge: {
          include: {
            user: true
          }
        },
        category: {
          include: {
            contest: {
              include: {
                event: true
              }
            }
          }
        }
      }
    })

    if (!assignment) {
      return res.status(404).json({ error: 'Assignment not found' })
    }

    // Check if assignment can be deleted
    const deletableStatuses = ['PENDING', 'REJECTED', 'CANCELLED']
    if (!deletableStatuses.includes(assignment.status)) {
      return res.status(400).json({ 
        error: `Cannot delete assignment with status ${assignment.status}`,
        deletableStatuses
      })
    }

    // Check user permissions
    const userRole = req.user.role
    const canDelete = ['ORGANIZER', 'BOARD', 'ADMIN'].includes(userRole) || 
                     (userRole === 'JUDGE' && assignment.judgeId === req.user.id)

    if (!canDelete) {
      return res.status(403).json({ 
        error: 'Insufficient permissions to delete this assignment' 
      })
    }

    // Check for dependent data
    const dependentScores = await prisma.score.count({
      where: {
        categoryId: assignment.categoryId,
        judgeId: assignment.judgeId
      }
    })

    if (dependentScores > 0) {
      return res.status(400).json({ 
        error: 'Cannot delete assignment: scores have been submitted',
        dependentScores
      })
    }

    req.validationData = { assignment }
    next()
  } catch (error) {
    console.error('Assignment deletion validation error:', error)
    res.status(500).json({ error: 'Internal server error during validation' })
  }
}

// Validate bulk assignment operations
const validateBulkAssignmentOperation = async (req, res, next) => {
  try {
    const { operation, assignmentIds, data } = req.body

    if (!operation || !assignmentIds || !Array.isArray(assignmentIds)) {
      return res.status(400).json({ error: 'Invalid bulk operation parameters' })
    }

    // Check if all assignments exist
    const assignments = await prisma.assignment.findMany({
      where: {
        id: { in: assignmentIds }
      },
      include: {
        judge: {
          include: {
            user: true
          }
        },
        category: {
          include: {
            contest: {
              include: {
                event: true
              }
            }
          }
        }
      }
    })

    if (assignments.length !== assignmentIds.length) {
      return res.status(400).json({ 
        error: 'Some assignments not found',
        requested: assignmentIds.length,
        found: assignments.length
      })
    }

    // Validate operation-specific requirements
    switch (operation) {
      case 'updateStatus':
        if (!data.status) {
          return res.status(400).json({ error: 'Status is required for update operation' })
        }
        break
      case 'delete':
        // Check if all assignments can be deleted
        const nonDeletable = assignments.filter(a => 
          !['PENDING', 'REJECTED', 'CANCELLED'].includes(a.status)
        )
        if (nonDeletable.length > 0) {
          return res.status(400).json({ 
            error: 'Some assignments cannot be deleted due to their status',
            nonDeletable: nonDeletable.map(a => ({ id: a.id, status: a.status }))
          })
        }
        break
      default:
        return res.status(400).json({ error: 'Invalid bulk operation' })
    }

    req.validationData = { assignments }
    next()
  } catch (error) {
    console.error('Bulk assignment validation error:', error)
    res.status(500).json({ error: 'Internal server error during validation' })
  }
}

// Validate assignment query parameters
const validateAssignmentQuery = async (req, res, next) => {
  try {
    const { status, judgeId, categoryId, eventId, contestId, sortBy, sortOrder } = req.query

    // Validate status filter
    if (status && !['PENDING', 'ACCEPTED', 'IN_PROGRESS', 'COMPLETED', 'REJECTED', 'CANCELLED'].includes(status)) {
      return res.status(400).json({ 
        error: 'Invalid status filter',
        validStatuses: ['PENDING', 'ACCEPTED', 'IN_PROGRESS', 'COMPLETED', 'REJECTED', 'CANCELLED']
      })
    }

    // Validate sort parameters
    const validSortFields = ['createdAt', 'updatedAt', 'status', 'judgeId', 'categoryId']
    if (sortBy && !validSortFields.includes(sortBy)) {
      return res.status(400).json({ 
        error: 'Invalid sort field',
        validFields: validSortFields
      })
    }

    if (sortOrder && !['asc', 'desc'].includes(sortOrder.toLowerCase())) {
      return res.status(400).json({ 
        error: 'Invalid sort order',
        validOrders: ['asc', 'desc']
      })
    }

    // Validate ID parameters exist
    if (judgeId) {
      const judge = await prisma.user.findUnique({ where: { id: judgeId } })
      if (!judge) {
        return res.status(404).json({ error: 'Judge not found' })
      }
    }

    if (categoryId) {
      const category = await prisma.category.findUnique({ where: { id: categoryId } })
      if (!category) {
        return res.status(404).json({ error: 'Category not found' })
      }
    }

    if (eventId) {
      const event = await prisma.event.findUnique({ where: { id: eventId } })
      if (!event) {
        return res.status(404).json({ error: 'Event not found' })
      }
    }

    if (contestId) {
      const contest = await prisma.contest.findUnique({ where: { id: contestId } })
      if (!contest) {
        return res.status(404).json({ error: 'Contest not found' })
      }
    }

    next()
  } catch (error) {
    console.error('Assignment query validation error:', error)
    res.status(500).json({ error: 'Internal server error during validation' })
  }
}

module.exports = {
  validateAssignmentCreation,
  validateAssignmentUpdate,
  validateAssignmentDeletion,
  validateBulkAssignmentOperation,
  validateAssignmentQuery
}
EOF

    # Advanced Reporting Controller
    cat > "$APP_DIR/src/controllers/advancedReportingController.js" << 'EOF'
const { PrismaClient } = require('@prisma/client')
const fs = require('fs').promises
const path = require('path')
const XLSX = require('xlsx')
const csvWriter = require('csv-writer')
const xml2js = require('xml2js')
const PDFDocument = require('pdfkit')
const puppeteer = require('puppeteer')
const handlebars = require('handlebars')

const prisma = new PrismaClient()

// Advanced Reporting Controller Functions

// Generate comprehensive event report
const generateEventReport = async (req, res) => {
  try {
    const { eventId, format = 'pdf', includeDetails = true } = req.query

    if (!eventId) {
      return res.status(400).json({ error: 'Event ID is required' })
    }

    // Get event data with all related information
    const event = await prisma.event.findUnique({
      where: { id: eventId },
      include: {
        contests: {
          include: {
            categories: {
              include: {
                contestants: {
                  include: {
                    contestant: {
                      include: {
                        user: true
                      }
                    }
                  }
                },
                assignments: {
                  include: {
                    judge: {
                      include: {
                        user: true
                      }
                    }
                  }
                },
                scores: {
                  include: {
                    judge: {
                      include: {
                        user: true
                      }
                    },
                    contestant: {
                      include: {
                        user: true
                      }
                    }
                  }
                }
              }
            }
          }
        },
        organizer: {
          include: {
            user: true
          }
        }
      }
    })

    if (!event) {
      return res.status(404).json({ error: 'Event not found' })
    }

    // Calculate comprehensive statistics
    const stats = {
      totalContests: event.contests.length,
      totalCategories: event.contests.reduce((sum, contest) => sum + contest.categories.length, 0),
      totalContestants: event.contests.reduce((sum, contest) => 
        sum + contest.categories.reduce((catSum, category) => catSum + category.contestants.length, 0), 0),
      totalJudges: new Set(event.contests.flatMap(contest => 
        contest.categories.flatMap(category => 
          category.assignments.map(assignment => assignment.judgeId)
        )
      )).size,
      totalScores: event.contests.reduce((sum, contest) => 
        sum + contest.categories.reduce((catSum, category) => catSum + category.scores.length, 0), 0),
      averageScore: 0,
      completionRate: 0
    }

    // Calculate average score and completion rate
    if (stats.totalScores > 0) {
      const totalScoreValue = event.contests.reduce((sum, contest) => 
        sum + contest.categories.reduce((catSum, category) => 
          catSum + category.scores.reduce((scoreSum, score) => scoreSum + score.score, 0), 0), 0)
      stats.averageScore = totalScoreValue / stats.totalScores
    }

    const totalPossibleScores = stats.totalCategories * stats.totalJudges * stats.totalContestants
    if (totalPossibleScores > 0) {
      stats.completionRate = (stats.totalScores / totalPossibleScores) * 100
    }

    // Generate report based on format
    switch (format.toLowerCase()) {
      case 'pdf':
        return await generatePDFReport(res, event, stats, includeDetails)
      case 'excel':
        return await generateExcelReport(res, event, stats, includeDetails)
      case 'csv':
        return await generateCSVReport(res, event, stats, includeDetails)
      case 'xml':
        return await generateXMLReport(res, event, stats, includeDetails)
      case 'json':
        return await generateJSONReport(res, event, stats, includeDetails)
      default:
        return res.status(400).json({ error: 'Invalid format. Supported: pdf, excel, csv, xml, json' })
    }
  } catch (error) {
    console.error('Event report generation error:', error)
    res.status(500).json({ error: 'Failed to generate event report' })
  }
}

// Generate PDF report using Puppeteer
const generatePDFReport = async (res, event, stats, includeDetails) => {
  try {
    const browser = await puppeteer.launch({ headless: true })
    const page = await browser.newPage()

    // Create HTML template
    const htmlTemplate = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <title>Event Report - ' + event.name + '</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 20px; }
          .header { text-align: center; margin-bottom: 30px; }
          .stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; margin-bottom: 30px; }
          .stat-card { border: 1px solid #ddd; padding: 15px; text-align: center; }
          .stat-value { font-size: 24px; font-weight: bold; color: #2563eb; }
          .stat-label { color: #666; margin-top: 5px; }
          .section { margin-bottom: 30px; }
          .section h2 { color: #2563eb; border-bottom: 2px solid #2563eb; padding-bottom: 5px; }
          table { width: 100%; border-collapse: collapse; margin-top: 15px; }
          th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
          th { background-color: #f5f5f5; }
          .footer { margin-top: 50px; text-align: center; color: #666; }
        </style>
      </head>
      <body>
        <div class="header">
          <h1>Event Report</h1>
          <h2>' + event.name + '</h2>
          <p>Generated on: ' + new Date().toLocaleDateString() + '</p>
        </div>

        <div class="stats">
          <div class="stat-card">
            <div class="stat-value">' + stats.totalContests + '</div>
            <div class="stat-label">Total Contests</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">' + stats.totalCategories + '</div>
            <div class="stat-label">Total Categories</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">' + stats.totalContestants + '</div>
            <div class="stat-label">Total Contestants</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">' + stats.totalJudges + '</div>
            <div class="stat-label">Total Judges</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">' + stats.totalScores + '</div>
            <div class="stat-label">Scores Submitted</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">' + stats.averageScore.toFixed(2) + '</div>
            <div class="stat-label">Average Score</div>
          </div>
        </div>

        ' + (includeDetails ? `
        <div class="section">
          <h2>Event Details</h2>
          <p><strong>Description:</strong> ' + (event.description || 'N/A') + '</p>
          <p><strong>Start Date:</strong> ' + new Date(event.startDate).toLocaleDateString() + '</p>
          <p><strong>End Date:</strong> ' + new Date(event.endDate).toLocaleDateString() + '</p>
          <p><strong>Location:</strong> ' + (event.location || 'N/A') + '</p>
          <p><strong>Organizer:</strong> ' + (event.organizer?.user?.firstName || '') + ' ' + (event.organizer?.user?.lastName || '') + '</p>
        </div>

        <div class="section">
          <h2>Contest Summary</h2>
          <table>
            <thead>
              <tr>
                <th>Contest Name</th>
                <th>Categories</th>
                <th>Contestants</th>
                <th>Scores</th>
              </tr>
            </thead>
            <tbody>
              ' + event.contests.map(contest => `
                <tr>
                  <td>' + contest.name + '</td>
                  <td>' + contest.categories.length + '</td>
                  <td>' + contest.categories.reduce((sum, cat) => sum + cat.contestants.length, 0) + '</td>
                  <td>' + contest.categories.reduce((sum, cat) => sum + cat.scores.length, 0) + '</td>
                </tr>
              `).join('') + `
            </tbody>
          </table>
        </div>
        ` : '') + `

        <div class="footer">
          <p>Report generated by Event Manager System</p>
        </div>
      </body>
      </html>
    `

    await page.setContent(htmlTemplate)
    const pdf = await page.pdf({ 
      format: 'A4', 
      printBackground: true,
      margin: { top: '20px', right: '20px', bottom: '20px', left: '20px' }
    })

    await browser.close()

    res.setHeader('Content-Type', 'application/pdf')
    res.setHeader('Content-Disposition', 'attachment; filename="event-report-' + event.id + '.pdf"')
    res.send(pdf)
  } catch (error) {
    console.error('PDF generation error:', error)
    res.status(500).json({ error: 'Failed to generate PDF report' })
  }
}

// Generate Excel report
const generateExcelReport = async (res, event, stats, includeDetails) => {
  try {
    const workbook = XLSX.utils.book_new()

    // Summary sheet
    const summaryData = [
      ['Event Report Summary'],
      [''],
      ['Event Name', event.name],
      ['Start Date', new Date(event.startDate).toLocaleDateString()],
      ['End Date', new Date(event.endDate).toLocaleDateString()],
      ['Location', event.location || 'N/A'],
      ['Organizer', `${event.organizer?.user?.firstName} ${event.organizer?.user?.lastName}`],
      [''],
      ['Statistics'],
      ['Total Contests', stats.totalContests],
      ['Total Categories', stats.totalCategories],
      ['Total Contestants', stats.totalContestants],
      ['Total Judges', stats.totalJudges],
      ['Scores Submitted', stats.totalScores],
      ['Average Score', stats.averageScore.toFixed(2)],
      ['Completion Rate', stats.completionRate.toFixed(1) + '%']
    ]

    const summarySheet = XLSX.utils.aoa_to_sheet(summaryData)
    XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary')

    if (includeDetails) {
      // Contests sheet
      const contestsData = [
        ['Contest Name', 'Categories', 'Contestants', 'Scores Submitted', 'Average Score']
      ]

      event.contests.forEach(contest => {
        const totalContestants = contest.categories.reduce((sum, cat) => sum + cat.contestants.length, 0)
        const totalScores = contest.categories.reduce((sum, cat) => sum + cat.scores.length, 0)
        const avgScore = totalScores > 0 ? 
          contest.categories.reduce((sum, cat) => 
            sum + cat.scores.reduce((scoreSum, score) => scoreSum + score.score, 0), 0) / totalScores : 0

        contestsData.push([
          contest.name,
          contest.categories.length,
          totalContestants,
          totalScores,
          avgScore.toFixed(2)
        ])
      })

      const contestsSheet = XLSX.utils.aoa_to_sheet(contestsData)
      XLSX.utils.book_append_sheet(workbook, contestsSheet, 'Contests')

      // Categories sheet
      const categoriesData = [
        ['Contest', 'Category', 'Contestants', 'Judges', 'Scores', 'Average Score']
      ]

      event.contests.forEach(contest => {
        contest.categories.forEach(category => {
          const avgScore = category.scores.length > 0 ? 
            category.scores.reduce((sum, score) => sum + score.score, 0) / category.scores.length : 0

          categoriesData.push([
            contest.name,
            category.name,
            category.contestants.length,
            category.assignments.length,
            category.scores.length,
            avgScore.toFixed(2)
          ])
        })
      })

      const categoriesSheet = XLSX.utils.aoa_to_sheet(categoriesData)
      XLSX.utils.book_append_sheet(workbook, categoriesSheet, 'Categories')
    }

    const buffer = XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' })
    
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    res.setHeader('Content-Disposition', 'attachment; filename="event-report-' + event.id + '.xlsx"')
    res.send(buffer)
  } catch (error) {
    console.error('Excel generation error:', error)
    res.status(500).json({ error: 'Failed to generate Excel report' })
  }
}

// Generate CSV report
const generateCSVReport = async (res, event, stats, includeDetails) => {
  try {
    const csvData = []
    
    // Header
    csvData.push(['Event Report', event.name])
    csvData.push(['Generated', new Date().toISOString()])
    csvData.push([''])
    
    // Statistics
    csvData.push(['Statistics'])
    csvData.push(['Total Contests', stats.totalContests])
    csvData.push(['Total Categories', stats.totalCategories])
    csvData.push(['Total Contestants', stats.totalContestants])
    csvData.push(['Total Judges', stats.totalJudges])
    csvData.push(['Scores Submitted', stats.totalScores])
    csvData.push(['Average Score', stats.averageScore.toFixed(2)])
    csvData.push(['Completion Rate', stats.completionRate.toFixed(1) + '%'])
    csvData.push([''])

    if (includeDetails) {
      // Contest details
      csvData.push(['Contest Details'])
      csvData.push(['Contest Name', 'Categories', 'Contestants', 'Scores', 'Average Score'])
      
      event.contests.forEach(contest => {
        const totalContestants = contest.categories.reduce((sum, cat) => sum + cat.contestants.length, 0)
        const totalScores = contest.categories.reduce((sum, cat) => sum + cat.scores.length, 0)
        const avgScore = totalScores > 0 ? 
          contest.categories.reduce((sum, cat) => 
            sum + cat.scores.reduce((scoreSum, score) => scoreSum + score.score, 0), 0) / totalScores : 0

        csvData.push([
          contest.name,
          contest.categories.length,
          totalContestants,
          totalScores,
          avgScore.toFixed(2)
        ])
      })
    }

    const csvContent = csvData.map(row => row.map(cell => '"' + cell + '"').join(',')).join('\n')
    
    res.setHeader('Content-Type', 'text/csv')
    res.setHeader('Content-Disposition', 'attachment; filename="event-report-' + event.id + '.csv"')
    res.send(csvContent)
  } catch (error) {
    console.error('CSV generation error:', error)
    res.status(500).json({ error: 'Failed to generate CSV report' })
  }
}

// Generate XML report
const generateXMLReport = async (res, event, stats, includeDetails) => {
  try {
    const builder = new xml2js.Builder({
      rootName: 'EventReport',
      xmldec: { version: '1.0', encoding: 'UTF-8' }
    })

    const reportData = {
      $: {
        eventId: event.id,
        generatedAt: new Date().toISOString()
      },
      Event: {
        Name: event.name,
        Description: event.description || '',
        StartDate: event.startDate,
        EndDate: event.endDate,
        Location: event.location || '',
        Organizer: {
          FirstName: event.organizer?.user?.firstName || '',
          LastName: event.organizer?.user?.lastName || ''
        }
      },
      Statistics: {
        TotalContests: stats.totalContests,
        TotalCategories: stats.totalCategories,
        TotalContestants: stats.totalContestants,
        TotalJudges: stats.totalJudges,
        ScoresSubmitted: stats.totalScores,
        AverageScore: stats.averageScore.toFixed(2),
        CompletionRate: stats.completionRate.toFixed(1) + '%'
      }
    }

    if (includeDetails) {
      reportData.Contests = {
        Contest: event.contests.map(contest => ({
          $: { id: contest.id },
          Name: contest.name,
          Categories: contest.categories.length,
          Contestants: contest.categories.reduce((sum, cat) => sum + cat.contestants.length, 0),
          Scores: contest.categories.reduce((sum, cat) => sum + cat.scores.length, 0),
          Category: contest.categories.map(category => ({
            $: { id: category.id },
            Name: category.name,
            Contestants: category.contestants.length,
            Judges: category.assignments.length,
            Scores: category.scores.length,
            AverageScore: category.scores.length > 0 ? 
              (category.scores.reduce((sum, score) => sum + score.score, 0) / category.scores.length).toFixed(2) : '0.00'
          }))
        }))
      }
    }

    const xml = builder.buildObject(reportData)
    
    res.setHeader('Content-Type', 'application/xml')
    res.setHeader('Content-Disposition', 'attachment; filename="event-report-' + event.id + '.xml"')
    res.send(xml)
  } catch (error) {
    console.error('XML generation error:', error)
    res.status(500).json({ error: 'Failed to generate XML report' })
  }
}

// Generate JSON report
const generateJSONReport = async (res, event, stats, includeDetails) => {
  try {
    const reportData = {
      eventId: event.id,
      generatedAt: new Date().toISOString(),
      event: {
        name: event.name,
        description: event.description,
        startDate: event.startDate,
        endDate: event.endDate,
        location: event.location,
        organizer: {
          firstName: event.organizer?.user?.firstName,
          lastName: event.organizer?.user?.lastName
        }
      },
      statistics: stats
    }

    if (includeDetails) {
      reportData.contests = event.contests.map(contest => ({
        id: contest.id,
        name: contest.name,
        categories: contest.categories.length,
        contestants: contest.categories.reduce((sum, cat) => sum + cat.contestants.length, 0),
        scores: contest.categories.reduce((sum, cat) => sum + cat.scores.length, 0),
        categories: contest.categories.map(category => ({
          id: category.id,
          name: category.name,
          contestants: category.contestants.length,
          judges: category.assignments.length,
          scores: category.scores.length,
          averageScore: category.scores.length > 0 ? 
            category.scores.reduce((sum, score) => sum + score.score, 0) / category.scores.length : 0
        }))
      }))
    }

    res.setHeader('Content-Type', 'application/json')
    res.setHeader('Content-Disposition', 'attachment; filename="event-report-' + event.id + '.json"')
    res.json(reportData)
  } catch (error) {
    console.error('JSON generation error:', error)
    res.status(500).json({ error: 'Failed to generate JSON report' })
  }
}

// Generate judge performance report
const generateJudgePerformanceReport = async (req, res) => {
  try {
    const { judgeId, eventId, format = 'pdf' } = req.query

    if (!judgeId && !eventId) {
      return res.status(400).json({ error: 'Either judgeId or eventId is required' })
    }

    let whereClause = {}
    if (judgeId) whereClause.judgeId = judgeId
    if (eventId) {
      whereClause.category = {
        contest: {
          eventId: eventId
        }
      }
    }

    const scores = await prisma.score.findMany({
      where: whereClause,
      include: {
        judge: {
          include: {
            user: true
          }
        },
        contestant: {
          include: {
            user: true
          }
        },
        category: {
          include: {
            contest: {
              include: {
                event: true
              }
            }
          }
        }
      }
    })

    if (scores.length === 0) {
      return res.status(404).json({ error: 'No scores found for the specified criteria' })
    }

    // Calculate performance metrics
    const judgeStats = {}
    scores.forEach(score => {
      const judgeId = score.judgeId
      if (!judgeStats[judgeId]) {
        judgeStats[judgeId] = {
          judge: score.judge,
          totalScores: 0,
          totalScoreValue: 0,
          averageScore: 0,
          categories: new Set(),
          events: new Set(),
          scores: []
        }
      }
      
      judgeStats[judgeId].totalScores++
      judgeStats[judgeId].totalScoreValue += score.score
      judgeStats[judgeId].categories.add(score.categoryId)
      judgeStats[judgeId].events.add(score.category.contest.eventId)
      judgeStats[judgeId].scores.push(score)
    })

    // Calculate averages
    Object.values(judgeStats).forEach(stat => {
      stat.averageScore = stat.totalScoreValue / stat.totalScores
      stat.categoriesCount = stat.categories.size
      stat.eventsCount = stat.events.size
    })

    // Generate report based on format
    switch (format.toLowerCase()) {
      case 'pdf':
        return await generateJudgePDFReport(res, judgeStats)
      case 'excel':
        return await generateJudgeExcelReport(res, judgeStats)
      case 'csv':
        return await generateJudgeCSVReport(res, judgeStats)
      case 'json':
        return await generateJudgeJSONReport(res, judgeStats)
      default:
        return res.status(400).json({ error: 'Invalid format. Supported: pdf, excel, csv, json' })
    }
  } catch (error) {
    console.error('Judge performance report error:', error)
    res.status(500).json({ error: 'Failed to generate judge performance report' })
  }
}

// Generate judge PDF report
const generateJudgePDFReport = async (res, judgeStats) => {
  try {
    const browser = await puppeteer.launch({ headless: true })
    const page = await browser.newPage()

    const htmlTemplate = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <title>Judge Performance Report</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 20px; }
          .header { text-align: center; margin-bottom: 30px; }
          .judge-card { border: 1px solid #ddd; margin-bottom: 20px; padding: 15px; }
          .stats { display: grid; grid-template-columns: repeat(4, 1fr); gap: 15px; margin-bottom: 20px; }
          .stat-item { text-align: center; }
          .stat-value { font-size: 20px; font-weight: bold; color: #2563eb; }
          .stat-label { color: #666; }
          table { width: 100%; border-collapse: collapse; margin-top: 15px; }
          th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
          th { background-color: #f5f5f5; }
        </style>
      </head>
      <body>
        <div class="header">
          <h1>Judge Performance Report</h1>
          <p>Generated on: ' + new Date().toLocaleDateString() + '</p>
        </div>

        ' + Object.values(judgeStats).map(stat => `
          <div class="judge-card">
            <h2>' + stat.judge.user.firstName + ' ' + stat.judge.user.lastName + '</h2>
            <div class="stats">
              <div class="stat-item">
                <div class="stat-value">' + stat.totalScores + '</div>
                <div class="stat-label">Total Scores</div>
              </div>
              <div class="stat-item">
                <div class="stat-value">' + stat.averageScore.toFixed(2) + '</div>
                <div class="stat-label">Average Score</div>
              </div>
              <div class="stat-item">
                <div class="stat-value">' + stat.categoriesCount + '</div>
                <div class="stat-label">Categories</div>
              </div>
              <div class="stat-item">
                <div class="stat-value">' + stat.eventsCount + '</div>
                <div class="stat-label">Events</div>
              </div>
            </div>
          </div>
        `).join('') + `
      </body>
      </html>
    `

    await page.setContent(htmlTemplate)
    const pdf = await page.pdf({ format: 'A4', printBackground: true })
    await browser.close()

    res.setHeader('Content-Type', 'application/pdf')
    res.setHeader('Content-Disposition', 'attachment; filename="judge-performance-report.pdf"')
    res.send(pdf)
  } catch (error) {
    console.error('Judge PDF generation error:', error)
    res.status(500).json({ error: 'Failed to generate judge PDF report' })
  }
}

// Generate judge Excel report
const generateJudgeExcelReport = async (res, judgeStats) => {
  try {
    const workbook = XLSX.utils.book_new()

    const judgeData = [
      ['Judge Name', 'Total Scores', 'Average Score', 'Categories', 'Events']
    ]

    Object.values(judgeStats).forEach(stat => {
      judgeData.push([
        `${stat.judge.user.firstName} ${stat.judge.user.lastName}`,
        stat.totalScores,
        stat.averageScore.toFixed(2),
        stat.categoriesCount,
        stat.eventsCount
      ])
    })

    const judgeSheet = XLSX.utils.aoa_to_sheet(judgeData)
    XLSX.utils.book_append_sheet(workbook, judgeSheet, 'Judge Performance')

    const buffer = XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' })
    
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    res.setHeader('Content-Disposition', 'attachment; filename="judge-performance-report.xlsx"')
    res.send(buffer)
  } catch (error) {
    console.error('Judge Excel generation error:', error)
    res.status(500).json({ error: 'Failed to generate judge Excel report' })
  }
}

// Generate judge CSV report
const generateJudgeCSVReport = async (res, judgeStats) => {
  try {
    const csvData = [
      ['Judge Performance Report'],
      ['Generated', new Date().toISOString()],
      [''],
      ['Judge Name', 'Total Scores', 'Average Score', 'Categories', 'Events']
    ]

    Object.values(judgeStats).forEach(stat => {
      csvData.push([
        `"${stat.judge.user.firstName} ${stat.judge.user.lastName}"`,
        stat.totalScores,
        stat.averageScore.toFixed(2),
        stat.categoriesCount,
        stat.eventsCount
      ])
    })

    const csvContent = csvData.map(row => row.join(',')).join('\n')
    
    res.setHeader('Content-Type', 'text/csv')
    res.setHeader('Content-Disposition', 'attachment; filename="judge-performance-report.csv"')
    res.send(csvContent)
  } catch (error) {
    console.error('Judge CSV generation error:', error)
    res.status(500).json({ error: 'Failed to generate judge CSV report' })
  }
}

// Generate judge JSON report
const generateJudgeJSONReport = async (res, judgeStats) => {
  try {
    const reportData = {
      generatedAt: new Date().toISOString(),
      judges: Object.values(judgeStats).map(stat => ({
        judgeId: stat.judge.id,
        name: `${stat.judge.user.firstName} ${stat.judge.user.lastName}`,
        totalScores: stat.totalScores,
        averageScore: stat.averageScore,
        categoriesCount: stat.categoriesCount,
        eventsCount: stat.eventsCount,
        scores: stat.scores.map(score => ({
          score: score.score,
          category: score.category.name,
          contest: score.category.contest.name,
          event: score.category.contest.event.name,
          contestant: `${score.contestant.user.firstName} ${score.contestant.user.lastName}`
        }))
      }))
    }

    res.setHeader('Content-Type', 'application/json')
    res.setHeader('Content-Disposition', 'attachment; filename="judge-performance-report.json"')
    res.json(reportData)
  } catch (error) {
    console.error('Judge JSON generation error:', error)
    res.status(500).json({ error: 'Failed to generate judge JSON report' })
  }
}

// Generate system analytics report
const generateSystemAnalyticsReport = async (req, res) => {
  try {
    const { format = 'pdf', period = '30' } = req.query

    // Get system statistics
    const stats = {
      totalUsers: await prisma.user.count(),
      totalEvents: await prisma.event.count(),
      totalContests: await prisma.contest.count(),
      totalCategories: await prisma.category.count(),
      totalScores: await prisma.score.count(),
      totalAssignments: await prisma.assignment.count(),
      totalFiles: await prisma.file.count()
    }

    // Get recent activity (last 30 days by default)
    const startDate = new Date()
    startDate.setDate(startDate.getDate() - parseInt(period))

    const recentActivity = await prisma.activityLog.findMany({
      where: {
        createdAt: {
          gte: startDate
        }
      },
      include: {
        user: {
          include: {
            user: true
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      },
      take: 100
    })

    // Get user role distribution
    const userRoles = await prisma.user.groupBy({
      by: ['role'],
      _count: {
        role: true
      }
    })

    // Get event status distribution
    const eventStatuses = await prisma.event.groupBy({
      by: ['status'],
      _count: {
        status: true
      }
    })

    const analyticsData = {
      stats,
      recentActivity,
      userRoles,
      eventStatuses,
      period: parseInt(period)
    }

    // Generate report based on format
    switch (format.toLowerCase()) {
      case 'pdf':
        return await generateAnalyticsPDFReport(res, analyticsData)
      case 'excel':
        return await generateAnalyticsExcelReport(res, analyticsData)
      case 'json':
        return await generateAnalyticsJSONReport(res, analyticsData)
      default:
        return res.status(400).json({ error: 'Invalid format. Supported: pdf, excel, json' })
    }
  } catch (error) {
    console.error('System analytics report error:', error)
    res.status(500).json({ error: 'Failed to generate system analytics report' })
  }
}

// Generate analytics PDF report
const generateAnalyticsPDFReport = async (res, analyticsData) => {
  try {
    const browser = await puppeteer.launch({ headless: true })
    const page = await browser.newPage()

    const htmlTemplate = `
      <!DOCTYPE html>
      <html>
      <head>
        <meta charset="utf-8">
        <title>System Analytics Report</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 20px; }
          .header { text-align: center; margin-bottom: 30px; }
          .stats { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin-bottom: 30px; }
          .stat-card { border: 1px solid #ddd; padding: 15px; text-align: center; }
          .stat-value { font-size: 24px; font-weight: bold; color: #2563eb; }
          .stat-label { color: #666; margin-top: 5px; }
          .section { margin-bottom: 30px; }
          .section h2 { color: #2563eb; border-bottom: 2px solid #2563eb; padding-bottom: 5px; }
          table { width: 100%; border-collapse: collapse; margin-top: 15px; }
          th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
          th { background-color: #f5f5f5; }
        </style>
      </head>
      <body>
        <div class="header">
          <h1>System Analytics Report</h1>
          <p>Period: Last ' + analyticsData.period + ' days</p>
          <p>Generated on: ' + new Date().toLocaleDateString() + '</p>
        </div>

        <div class="stats">
          <div class="stat-card">
            <div class="stat-value">' + analyticsData.stats.totalUsers + '</div>
            <div class="stat-label">Total Users</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">' + analyticsData.stats.totalEvents + '</div>
            <div class="stat-label">Total Events</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">' + analyticsData.stats.totalContests + '</div>
            <div class="stat-label">Total Contests</div>
          </div>
          <div class="stat-card">
            <div class="stat-value">' + analyticsData.stats.totalScores + '</div>
            <div class="stat-label">Total Scores</div>
          </div>
        </div>

        <div class="section">
          <h2>User Role Distribution</h2>
          <table>
            <thead>
              <tr>
                <th>Role</th>
                <th>Count</th>
                <th>Percentage</th>
              </tr>
            </thead>
            <tbody>
              ' + analyticsData.userRoles.map(role => `
                <tr>
                  <td>' + role.role + '</td>
                  <td>' + role._count.role + '</td>
                  <td>' + ((role._count.role / analyticsData.stats.totalUsers) * 100).toFixed(1) + '%</td>
                </tr>
              `).join('') + `
            </tbody>
          </table>
        </div>

        <div class="section">
          <h2>Recent Activity (Last ' + analyticsData.period + ' days)</h2>
          <table>
            <thead>
              <tr>
                <th>Date</th>
                <th>User</th>
                <th>Action</th>
                <th>Entity</th>
              </tr>
            </thead>
            <tbody>
              ' + analyticsData.recentActivity.slice(0, 20).map(activity => `
                <tr>
                  <td>' + new Date(activity.createdAt).toLocaleDateString() + '</td>
                  <td>' + (activity.user?.user?.firstName || '') + ' ' + (activity.user?.user?.lastName || '') + '</td>
                  <td>' + activity.action + '</td>
                  <td>' + activity.entityType + '</td>
                </tr>
              `).join('') + `
            </tbody>
          </table>
        </div>
      </body>
      </html>
    `

    await page.setContent(htmlTemplate)
    const pdf = await page.pdf({ format: 'A4', printBackground: true })
    await browser.close()

    res.setHeader('Content-Type', 'application/pdf')
    res.setHeader('Content-Disposition', 'attachment; filename="system-analytics-report.pdf"')
    res.send(pdf)
  } catch (error) {
    console.error('Analytics PDF generation error:', error)
    res.status(500).json({ error: 'Failed to generate analytics PDF report' })
  }
}

// Generate analytics Excel report
const generateAnalyticsExcelReport = async (res, analyticsData) => {
  try {
    const workbook = XLSX.utils.book_new()

    // Summary sheet
    const summaryData = [
      ['System Analytics Report'],
      ['Generated', new Date().toISOString()],
      ['Period', `Last ${analyticsData.period} days`],
      [''],
      ['Statistics'],
      ['Total Users', analyticsData.stats.totalUsers],
      ['Total Events', analyticsData.stats.totalEvents],
      ['Total Contests', analyticsData.stats.totalContests],
      ['Total Categories', analyticsData.stats.totalCategories],
      ['Total Scores', analyticsData.stats.totalScores],
      ['Total Assignments', analyticsData.stats.totalAssignments],
      ['Total Files', analyticsData.stats.totalFiles]
    ]

    const summarySheet = XLSX.utils.aoa_to_sheet(summaryData)
    XLSX.utils.book_append_sheet(workbook, summarySheet, 'Summary')

    // User roles sheet
    const rolesData = [
      ['Role', 'Count', 'Percentage']
    ]

    analyticsData.userRoles.forEach(role => {
      rolesData.push([
        role.role,
        role._count.role,
        ((role._count.role / analyticsData.stats.totalUsers) * 100).toFixed(1) + '%'
      ])
    })

    const rolesSheet = XLSX.utils.aoa_to_sheet(rolesData)
    XLSX.utils.book_append_sheet(workbook, rolesSheet, 'User Roles')

    // Recent activity sheet
    const activityData = [
      ['Date', 'User', 'Action', 'Entity Type', 'Entity ID']
    ]

    analyticsData.recentActivity.forEach(activity => {
      activityData.push([
        new Date(activity.createdAt).toLocaleDateString(),
        `${activity.user?.user?.firstName} ${activity.user?.user?.lastName}`,
        activity.action,
        activity.entityType,
        activity.entityId
      ])
    })

    const activitySheet = XLSX.utils.aoa_to_sheet(activityData)
    XLSX.utils.book_append_sheet(workbook, activitySheet, 'Recent Activity')

    const buffer = XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' })
    
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')
    res.setHeader('Content-Disposition', 'attachment; filename="system-analytics-report.xlsx"')
    res.send(buffer)
  } catch (error) {
    console.error('Analytics Excel generation error:', error)
    res.status(500).json({ error: 'Failed to generate analytics Excel report' })
  }
}

// Generate analytics JSON report
const generateAnalyticsJSONReport = async (res, analyticsData) => {
  try {
    const reportData = {
      generatedAt: new Date().toISOString(),
      period: analyticsData.period,
      statistics: analyticsData.stats,
      userRoles: analyticsData.userRoles.map(role => ({
        role: role.role,
        count: role._count.role,
        percentage: ((role._count.role / analyticsData.stats.totalUsers) * 100).toFixed(1)
      })),
      eventStatuses: analyticsData.eventStatuses.map(status => ({
        status: status.status,
        count: status._count.status
      })),
      recentActivity: analyticsData.recentActivity.map(activity => ({
        date: activity.createdAt,
        user: `${activity.user?.user?.firstName} ${activity.user?.user?.lastName}`,
        action: activity.action,
        entityType: activity.entityType,
        entityId: activity.entityId
      }))
    }

    res.setHeader('Content-Type', 'application/json')
    res.setHeader('Content-Disposition', 'attachment; filename="system-analytics-report.json"')
    res.json(reportData)
  } catch (error) {
    console.error('Analytics JSON generation error:', error)
    res.status(500).json({ error: 'Failed to generate analytics JSON report' })
  }
}

// Generate contest results report with email integration
const generateContestResultsReport = async (req, res) => {
  try {
    const { contestId, format = 'pdf', emailTo = null, includeDetails = true } = req.query

    if (!contestId) {
      return res.status(400).json({ error: 'Contest ID is required' })
    }

    // Get contest data with all related information
    const contest = await prisma.contest.findUnique({
      where: { id: contestId },
      include: {
        event: true,
        categories: {
          include: {
            contestants: {
              include: {
                contestant: {
                  include: {
                    user: true
                  }
                }
              }
            },
            scores: {
              include: {
                judge: {
                  include: {
                    user: true
                  }
                },
                contestant: {
                  include: {
                    user: true
                  }
                }
              }
            }
          }
        }
      }
    })

    if (!contest) {
      return res.status(404).json({ error: 'Contest not found' })
    }

    // Generate report data
    const reportData = {
      contest: {
        id: contest.id,
        name: contest.name,
        description: contest.description,
        startDate: contest.startDate,
        endDate: contest.endDate,
        event: contest.event
      },
      categories: contest.categories.map(category => {
        const contestants = category.contestants.map(cc => {
          const scores = category.scores.filter(s => s.contestantId === cc.contestantId)
          const totalScore = scores.reduce((sum, score) => sum + score.score, 0)
          const averageScore = scores.length > 0 ? totalScore / scores.length : 0

          return {
            contestant: cc.contestant.user,
            totalScore,
            averageScore,
            scores: scores.map(s => ({
              judge: s.judge.user.name,
              score: s.score,
              comment: s.comment,
              createdAt: s.createdAt
            }))
          }
        }).sort((a, b) => b.totalScore - a.totalScore)

        return {
          id: category.id,
          name: category.name,
          description: category.description,
          maxScore: category.maxScore,
          contestants
        }
      }),
      generatedAt: new Date().toISOString(),
      generatedBy: req.user.name
    }

    // Generate file based on format
    let filename, contentType, fileData

    if (format === 'pdf') {
      filename = `contest-results-${contest.id}.pdf`
      contentType = 'application/pdf'
      fileData = await generatePDFReport(reportData, 'contest-results')
    } else if (format === 'excel') {
      filename = `contest-results-${contest.id}.xlsx`
      contentType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
      fileData = await generateExcelReport(reportData, 'contest-results')
    } else if (format === 'csv') {
      filename = `contest-results-${contest.id}.csv`
      contentType = 'text/csv'
      fileData = await generateCSVReport(reportData, 'contest-results')
    } else {
      filename = `contest-results-${contest.id}.json`
      contentType = 'application/json'
      fileData = JSON.stringify(reportData, null, 2)
    }

    // Send email if requested
    if (emailTo) {
      try {
        const emailService = require('./emailController')
        await emailService.sendReportEmail({
          to: emailTo,
          subject: `Contest Results Report - ${contest.name}`,
          reportData: fileData,
          filename,
          contentType
        })
        
        res.json({
          message: 'Report generated and sent via email',
          emailSent: true,
          recipient: emailTo,
          filename
        })
        return
      } catch (emailError) {
        console.error('Email sending error:', emailError)
        // Continue with file download if email fails
      }
    }

    // Send file as download
    res.setHeader('Content-Type', contentType)
    res.setHeader('Content-Disposition', 'attachment; filename="' + filename + '"')
    res.send(fileData)

  } catch (error) {
    console.error('Contest results report generation error:', error)
    res.status(500).json({ error: 'Failed to generate contest results report' })
  }
}

// Generate audit report with email integration
const generateAuditReport = async (req, res) => {
  try {
    const { eventId, startDate, endDate, format = 'pdf', emailTo = null } = req.query

    // Get audit logs
    const whereClause = {}
    if (eventId) whereClause.eventId = eventId
    if (startDate && endDate) {
      whereClause.createdAt = {
        gte: new Date(startDate),
        lte: new Date(endDate)
      }
    }

    const auditLogs = await prisma.activityLog.findMany({
      where: whereClause,
      include: {
        user: true
      },
      orderBy: { createdAt: 'desc' }
    })

    // Generate report data
    const reportData = {
      filters: {
        eventId,
        startDate,
        endDate
      },
      summary: {
        totalLogs: auditLogs.length,
        uniqueUsers: [...new Set(auditLogs.map(log => log.userId))].length,
        dateRange: {
          start: auditLogs.length > 0 ? auditLogs[auditLogs.length - 1].createdAt : null,
          end: auditLogs.length > 0 ? auditLogs[0].createdAt : null
        }
      },
      logs: auditLogs.map(log => ({
        id: log.id,
        action: log.action,
        resourceType: log.resourceType,
        resourceId: log.resourceId,
        userId: log.userId,
        userName: log.user.name,
        userRole: log.user.role,
        ipAddress: log.ipAddress,
        userAgent: log.userAgent,
        createdAt: log.createdAt,
        details: log.details
      })),
      generatedAt: new Date().toISOString(),
      generatedBy: req.user.name
    }

    // Generate file based on format
    let filename, contentType, fileData

    if (format === 'pdf') {
      filename = `audit-report-${Date.now()}.pdf`
      contentType = 'application/pdf'
      fileData = await generatePDFReport(reportData, 'audit')
    } else if (format === 'excel') {
      filename = `audit-report-${Date.now()}.xlsx`
      contentType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
      fileData = await generateExcelReport(reportData, 'audit')
    } else {
      filename = `audit-report-${Date.now()}.json`
      contentType = 'application/json'
      fileData = JSON.stringify(reportData, null, 2)
    }

    // Send email if requested
    if (emailTo) {
      try {
        const emailService = require('./emailController')
        await emailService.sendReportEmail({
          to: emailTo,
          subject: 'Audit Report',
          reportData: fileData,
          filename,
          contentType
        })
        
        res.json({
          message: 'Audit report generated and sent via email',
          emailSent: true,
          recipient: emailTo,
          filename
        })
        return
      } catch (emailError) {
        console.error('Email sending error:', emailError)
      }
    }

    // Send file as download
    res.setHeader('Content-Type', contentType)
    res.setHeader('Content-Disposition', 'attachment; filename="' + filename + '"')
    res.send(fileData)

  } catch (error) {
    console.error('Audit report generation error:', error)
    res.status(500).json({ error: 'Failed to generate audit report' })
  }
}

// Generate performance report with email integration
const generatePerformanceReport = async (req, res) => {
  try {
    const { judgeId, categoryId, format = 'pdf', emailTo = null } = req.query

    // Get performance data
    const whereClause = {}
    if (judgeId) whereClause.judgeId = judgeId
    if (categoryId) whereClause.categoryId = categoryId

    const scores = await prisma.score.findMany({
      where: whereClause,
      include: {
        judge: {
          include: {
            user: true
          }
        },
        contestant: {
          include: {
            user: true
          }
        },
        category: true
      },
      orderBy: { createdAt: 'desc' }
    })

    // Calculate performance metrics
    const performanceData = {
      filters: {
        judgeId,
        categoryId
      },
      summary: {
        totalScores: scores.length,
        averageScore: scores.length > 0 ? scores.reduce((sum, s) => sum + s.score, 0) / scores.length : 0,
        uniqueContestants: [...new Set(scores.map(s => s.contestantId))].length,
        uniqueCategories: [...new Set(scores.map(s => s.categoryId))].length
      },
      scores: scores.map(score => ({
        id: score.id,
        score: score.score,
        comment: score.comment,
        judge: score.judge.user.name,
        contestant: score.contestant.user.name,
        category: score.category.name,
        createdAt: score.createdAt
      })),
      generatedAt: new Date().toISOString(),
      generatedBy: req.user.name
    }

    // Generate file based on format
    let filename, contentType, fileData

    if (format === 'pdf') {
      filename = `performance-report-${Date.now()}.pdf`
      contentType = 'application/pdf'
      fileData = await generatePDFReport(performanceData, 'performance')
    } else if (format === 'excel') {
      filename = `performance-report-${Date.now()}.xlsx`
      contentType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
      fileData = await generateExcelReport(performanceData, 'performance')
    } else {
      filename = `performance-report-${Date.now()}.json`
      contentType = 'application/json'
      fileData = JSON.stringify(performanceData, null, 2)
    }

    // Send email if requested
    if (emailTo) {
      try {
        const emailService = require('./emailController')
        await emailService.sendReportEmail({
          to: emailTo,
          subject: 'Performance Report',
          reportData: fileData,
          filename,
          contentType
        })
        
        res.json({
          message: 'Performance report generated and sent via email',
          emailSent: true,
          recipient: emailTo,
          filename
        })
        return
      } catch (emailError) {
        console.error('Email sending error:', emailError)
      }
    }

    // Send file as download
    res.setHeader('Content-Type', contentType)
    res.setHeader('Content-Disposition', 'attachment; filename="' + filename + '"')
    res.send(fileData)

  } catch (error) {
    console.error('Performance report generation error:', error)
    res.status(500).json({ error: 'Failed to generate performance report' })
  }
}

// Helper function to generate PDF reports
const generatePDFReport = async (data, reportType) => {
  const browser = await puppeteer.launch({ headless: true })
  const page = await browser.newPage()
  
  // Generate HTML content based on report type
  let htmlContent = ''
  
  if (reportType === 'contest-results') {
    htmlContent = generateContestResultsHTML(data)
  } else if (reportType === 'audit') {
    htmlContent = generateAuditHTML(data)
  } else if (reportType === 'performance') {
    htmlContent = generatePerformanceHTML(data)
  }
  
  await page.setContent(htmlContent)
  const pdf = await page.pdf({ format: 'A4' })
  
  await browser.close()
  return pdf
}

// Helper function to generate Excel reports
const generateExcelReport = async (data, reportType) => {
  const workbook = XLSX.utils.book_new()
  
  if (reportType === 'contest-results') {
    const worksheet = XLSX.utils.json_to_sheet(data.categories.flatMap(cat => 
      cat.contestants.map(contestant => ({
        Category: cat.name,
        Contestant: contestant.contestant.name,
        TotalScore: contestant.totalScore,
        AverageScore: contestant.averageScore
      }))
    ))
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Contest Results')
  } else if (reportType === 'audit') {
    const worksheet = XLSX.utils.json_to_sheet(data.logs)
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Audit Logs')
  } else if (reportType === 'performance') {
    const worksheet = XLSX.utils.json_to_sheet(data.scores)
    XLSX.utils.book_append_sheet(workbook, worksheet, 'Performance Data')
  }
  
  return XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' })
}

// Helper function to generate CSV reports
const generateCSVReport = async (data, reportType) => {
  let csvData = []
  
  if (reportType === 'contest-results') {
    csvData = data.categories.flatMap(cat => 
      cat.contestants.map(contestant => ({
        Category: cat.name,
        Contestant: contestant.contestant.name,
        TotalScore: contestant.totalScore,
        AverageScore: contestant.averageScore
      }))
    )
  } else if (reportType === 'audit') {
    csvData = data.logs
  } else if (reportType === 'performance') {
    csvData = data.scores
  }
  
  const csv = XLSX.utils.sheet_to_csv(XLSX.utils.json_to_sheet(csvData))
  return csv
}

// Helper functions to generate HTML content
const generateContestResultsHTML = (data) => {
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <title>Contest Results Report</title>
      <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { text-align: center; margin-bottom: 30px; }
        .category { margin-bottom: 30px; }
        .contestant { margin-bottom: 10px; padding: 10px; border: 1px solid #ddd; }
        .score { font-weight: bold; color: #2c5aa0; }
      </style>
    </head>
    <body>
      <div class="header">
        <h1>Contest Results Report</h1>
        <h2>' + data.contest.name + '</h2>
        <p>Generated on: ' + new Date(data.generatedAt).toLocaleDateString() + '</p>
      </div>
      ' + data.categories.map(cat => `
        <div class="category">
          <h3>' + cat.name + '</h3>
          ' + cat.contestants.map(contestant => `
            <div class="contestant">
              <strong>' + contestant.contestant.name + '</strong>
              <span class="score">Total: ' + contestant.totalScore + ' | Average: ' + contestant.averageScore.toFixed(2) + '</span>
            </div>
          `).join('') + `
        </div>
      `).join('') + `
    </body>
    </html>
  `
}

const generateAuditHTML = (data) => {
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <title>Audit Report</title>
      <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { text-align: center; margin-bottom: 30px; }
        table { width: 100%; border-collapse: collapse; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
      </style>
    </head>
    <body>
      <div class="header">
        <h1>Audit Report</h1>
        <p>Generated on: ${new Date(data.generatedAt).toLocaleDateString()}</p>
        <p>Total Logs: ${data.summary.totalLogs}</p>
      </div>
      <table>
        <tr>
          <th>Date</th>
          <th>User</th>
          <th>Action</th>
          <th>Resource</th>
          <th>IP Address</th>
        </tr>
        ${data.logs.map(log => `
          <tr>
            <td>${new Date(log.createdAt).toLocaleString()}</td>
            <td>${log.userName} (${log.userRole})</td>
            <td>${log.action}</td>
            <td>${log.resourceType} - ${log.resourceId}</td>
            <td>${log.ipAddress}</td>
          </tr>
        `).join('')}
      </table>
    </body>
    </html>
  `
}

const generatePerformanceHTML = (data) => {
  return `
    <!DOCTYPE html>
    <html>
    <head>
      <title>Performance Report</title>
      <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .header { text-align: center; margin-bottom: 30px; }
        table { width: 100%; border-collapse: collapse; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
      </style>
    </head>
    <body>
      <div class="header">
        <h1>Performance Report</h1>
        <p>Generated on: ${new Date(data.generatedAt).toLocaleDateString()}</p>
        <p>Total Scores: ${data.summary.totalScores} | Average Score: ${data.summary.averageScore.toFixed(2)}</p>
      </div>
      <table>
        <tr>
          <th>Date</th>
          <th>Judge</th>
          <th>Contestant</th>
          <th>Category</th>
          <th>Score</th>
          <th>Comment</th>
        </tr>
        ${data.scores.map(score => `
          <tr>
            <td>${new Date(score.createdAt).toLocaleString()}</td>
            <td>${score.judge}</td>
            <td>${score.contestant}</td>
            <td>${score.category}</td>
            <td>${score.score}</td>
            <td>${score.comment || ''}</td>
          </tr>
        `).join('')}
      </table>
    </body>
    </html>
  `
}

module.exports = {
  generateEventReport,
  generateJudgePerformanceReport,
  generateSystemAnalyticsReport,
  generateContestResultsReport,
  generateAuditReport,
  generatePerformanceReport
}
EOF

    # Advanced Reporting Routes
    cat > "$APP_DIR/src/routes/advancedReportingRoutes.js" << 'EOF'
const express = require('express')
const { 
  generateEventReport,
  generateJudgePerformanceReport,
  generateSystemAnalyticsReport,
  generateContestResultsReport,
  generateAuditReport,
  generatePerformanceReport
} = require('../controllers/advancedReportingController')
const { authenticateToken, requireRole } = require('../middleware/auth')
const { logActivity } = require('../middleware/errorHandler')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)

// Advanced reporting endpoints
router.get('/event/:eventId', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), logActivity('GENERATE_EVENT_REPORT', 'REPORT'), generateEventReport)
router.get('/judge-performance', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), logActivity('GENERATE_JUDGE_REPORT', 'REPORT'), generateJudgePerformanceReport)
router.get('/system-analytics', requireRole(['ADMIN']), logActivity('GENERATE_SYSTEM_REPORT', 'REPORT'), generateSystemAnalyticsReport)
router.get('/contest-results', requireRole(['ADMIN', 'BOARD', 'EMCEE']), logActivity('GENERATE_CONTEST_RESULTS_REPORT', 'REPORT'), generateContestResultsReport)
router.get('/audit', requireRole(['ADMIN']), logActivity('GENERATE_AUDIT_REPORT', 'REPORT'), generateAuditReport)
router.get('/performance', requireRole(['ADMIN', 'BOARD']), logActivity('GENERATE_PERFORMANCE_REPORT', 'REPORT'), generatePerformanceReport)

module.exports = router
EOF

    # Error Handling Routes
    cat > "$APP_DIR/src/routes/errorHandlingRoutes.js" << 'EOF'
const express = require('express')
const { 
  getErrorStatistics,
  getErrorDetails,
  markErrorResolved,
  getErrorTrends,
  cleanupErrorLogs,
  exportErrorLogs
} = require('../controllers/errorHandlingController')
const { authenticateToken, requireRole } = require('../middleware/auth')
const { logActivity } = require('../middleware/errorHandler')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)

// Error handling and monitoring
router.get('/statistics', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), getErrorStatistics)
router.get('/trends', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), getErrorTrends)
router.get('/:errorId', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), getErrorDetails)
router.put('/:errorId/resolve', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), logActivity('RESOLVE_ERROR', 'ERROR'), markErrorResolved)
router.get('/export/logs', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), exportErrorLogs)
router.post('/cleanup', requireRole(['ORGANIZER', 'BOARD', 'ADMIN']), logActivity('CLEANUP_ERROR_LOGS', 'ERROR'), cleanupErrorLogs)

module.exports = router
EOF

    # Export Routes
    cat > "$APP_DIR/src/routes/exportRoutes.js" << 'EOF'
const express = require('express')
const { 
  exportEventToExcel,
  exportContestResultsToCSV,
  exportJudgePerformanceToXML,
  exportSystemAnalyticsToPDF,
  getExportHistory
} = require('../controllers/exportController')
const { authenticateToken, requireRole } = require('../middleware/auth')
const { logActivity } = require('../middleware/errorHandler')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)

// Export functionality
router.post('/event/excel', requireRole(['ORGANIZER', 'BOARD', 'AUDITOR']), logActivity('EXPORT_EVENT_EXCEL', 'EXPORT'), exportEventToExcel)
router.post('/contest-results/csv', requireRole(['ORGANIZER', 'BOARD', 'AUDITOR']), logActivity('EXPORT_CONTEST_RESULTS_CSV', 'EXPORT'), exportContestResultsToCSV)
router.post('/judge-performance/xml', requireRole(['ORGANIZER', 'BOARD', 'AUDITOR']), logActivity('EXPORT_JUDGE_PERFORMANCE_XML', 'EXPORT'), exportJudgePerformanceToXML)
router.post('/system-analytics/pdf', requireRole(['ORGANIZER', 'BOARD']), logActivity('EXPORT_SYSTEM_ANALYTICS_PDF', 'EXPORT'), exportSystemAnalyticsToPDF)

// Export history
router.get('/history', getExportHistory)

module.exports = router
EOF

    # Templates Routes
    cat > "$APP_DIR/src/routes/templatesRoutes.js" << 'EOF'
const express = require('express')
const { getAllTemplates, createTemplate, updateTemplate, deleteTemplate } = require('../controllers/templatesController')
const { authenticateToken, requireRole } = require('../middleware/auth')
const { logActivity } = require('../middleware/errorHandler')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)

// Templates endpoints
router.get('/', getAllTemplates)
router.post('/', requireRole(['ORGANIZER', 'BOARD']), logActivity('CREATE_TEMPLATE', 'TEMPLATE'), createTemplate)
router.put('/:id', requireRole(['ORGANIZER', 'BOARD']), logActivity('UPDATE_TEMPLATE', 'TEMPLATE'), updateTemplate)
router.delete('/:id', requireRole(['ORGANIZER', 'BOARD']), logActivity('DELETE_TEMPLATE', 'TEMPLATE'), deleteTemplate)

module.exports = router
EOF

    # Event Template Routes
    cat > "$APP_DIR/src/routes/eventTemplateRoutes.js" << 'EOF'
const express = require('express')
const { createTemplate, getTemplates, getTemplate, updateTemplate, deleteTemplate, createEventFromTemplate } = require('../controllers/eventTemplateController')
const { authenticateToken, requireRole } = require('../middleware/auth')
const { logActivity } = require('../middleware/errorHandler')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)

// Event template endpoints
router.get('/', getTemplates)
router.get('/:id', getTemplate)
router.post('/', requireRole(['ORGANIZER', 'BOARD']), logActivity('CREATE_EVENT_TEMPLATE', 'EVENT_TEMPLATE'), createTemplate)
router.put('/:id', requireRole(['ORGANIZER', 'BOARD']), logActivity('UPDATE_EVENT_TEMPLATE', 'EVENT_TEMPLATE'), updateTemplate)
router.delete('/:id', requireRole(['ORGANIZER', 'BOARD']), logActivity('DELETE_EVENT_TEMPLATE', 'EVENT_TEMPLATE'), deleteTemplate)
router.post('/:id/create-event', requireRole(['ORGANIZER', 'BOARD']), logActivity('CREATE_EVENT_FROM_TEMPLATE', 'EVENT'), createEventFromTemplate)

module.exports = router
EOF

    # Notifications Routes
    cat > "$APP_DIR/src/routes/notificationsRoutes.js" << 'EOF'
const express = require('express')
const { getAllNotifications, createNotification, updateNotification, deleteNotification } = require('../controllers/notificationsController')
const { authenticateToken, requireRole } = require('../middleware/auth')
const { logActivity } = require('../middleware/errorHandler')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)

// Notifications endpoints
router.get('/', getAllNotifications)
router.post('/', requireRole(['ORGANIZER', 'BOARD']), logActivity('CREATE_NOTIFICATION', 'NOTIFICATION'), createNotification)
router.put('/:id', requireRole(['ORGANIZER', 'BOARD']), logActivity('UPDATE_NOTIFICATION', 'NOTIFICATION'), updateNotification)
router.delete('/:id', requireRole(['ORGANIZER', 'BOARD']), logActivity('DELETE_NOTIFICATION', 'NOTIFICATION'), deleteNotification)

module.exports = router
EOF

    # Emcee Routes
    cat > "$APP_DIR/src/routes/emceeRoutes.js" << 'EOF'
const express = require('express')
const { 
  getStats,
  getScripts,
  getScript,
  getContestantBios,
  getJudgeBios,
  getEvents,
  getEvent,
  getContests,
  getContest,
  getEmceeHistory
} = require('../controllers/emceeController')
const { authenticateToken, requireRole } = require('../middleware/auth')
const { logActivity } = require('../middleware/errorHandler')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)
router.use(requireRole(['EMCEE', 'ORGANIZER', 'BOARD']))

// Emcee dashboard endpoints
router.get('/stats', getStats)
router.get('/history', getEmceeHistory)

// Script access
router.get('/scripts', getScripts)
router.get('/scripts/:scriptId', getScript)

// Contestant bios
router.get('/contestant-bios', getContestantBios)

// Judge bios
router.get('/judge-bios', getJudgeBios)

// Event management
router.get('/events', getEvents)
router.get('/events/:eventId', getEvent)

// Contest management
router.get('/contests', getContests)
router.get('/contests/:contestId', getContest)

module.exports = router
EOF

    # File Routes
    cat > "$APP_DIR/src/routes/fileRoutes.js" << 'EOF'
const express = require('express')
const { 
  getAllFiles,
  uploadFiles,
  getFileById,
  downloadFile,
  updateFile,
  deleteFile,
  getFileStats,
  upload
} = require('../controllers/fileController')
const { authenticateToken, requireRole } = require('../middleware/auth')
const { logActivity } = require('../middleware/errorHandler')
const { 
  checkFileAccess, 
  checkUploadPermission, 
  checkSharingPermission, 
  getUserFileAccess 
} = require('../middleware/fileAccessControl')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)

// File endpoints
router.get('/', getAllFiles)
router.get('/stats', getFileStats)
router.get('/access', getUserFileAccess)
router.get('/:id', checkFileAccess('READ'), getFileById)
router.get('/:id/download', checkFileAccess('READ'), downloadFile)
router.post('/upload', checkUploadPermission, upload.array('files', 5), logActivity('UPLOAD_FILE', 'FILE'), uploadFiles)
router.put('/:id', checkFileAccess('WRITE'), logActivity('UPDATE_FILE', 'FILE'), updateFile)
router.put('/:id/sharing', checkSharingPermission, logActivity('UPDATE_FILE_SHARING', 'FILE'), updateFile)
router.delete('/:id', checkFileAccess('DELETE'), logActivity('DELETE_FILE', 'FILE'), deleteFile)

module.exports = router
EOF

    # Certification Routes
    cat > "$APP_DIR/src/routes/certificationRoutes.js" << 'EOF'
const express = require('express')
const { 
  getAllCertifications,
  createCertification,
  updateCertification,
  deleteCertification,
  getCertificationById,
  certifyJudge,
  certifyTally,
  certifyAuditor,
  approveBoard,
  rejectCertification,
  getCertificationStats
} = require('../controllers/certificationController')
const { authenticateToken, requireRole } = require('../middleware/auth')
const { logActivity } = require('../middleware/errorHandler')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)

// Certification endpoints
router.get('/', getAllCertifications)
router.get('/stats', getCertificationStats)
router.get('/:id', getCertificationById)
router.post('/', requireRole(['ORGANIZER', 'BOARD']), logActivity('CREATE_CERTIFICATION', 'CERTIFICATION'), createCertification)
router.put('/:id', requireRole(['ORGANIZER', 'BOARD']), logActivity('UPDATE_CERTIFICATION', 'CERTIFICATION'), updateCertification)
router.delete('/:id', requireRole(['ORGANIZER', 'BOARD']), logActivity('DELETE_CERTIFICATION', 'CERTIFICATION'), deleteCertification)

// Workflow endpoints
router.post('/:id/certify-judge', requireRole(['JUDGE']), logActivity('CERTIFY_JUDGE', 'CERTIFICATION'), certifyJudge)
router.post('/:id/certify-tally', requireRole(['TALLY_MASTER']), logActivity('CERTIFY_TALLY', 'CERTIFICATION'), certifyTally)
router.post('/:id/certify-auditor', requireRole(['AUDITOR']), logActivity('CERTIFY_AUDITOR', 'CERTIFICATION'), certifyAuditor)
router.post('/:id/approve-board', requireRole(['BOARD']), logActivity('APPROVE_BOARD', 'CERTIFICATION'), approveBoard)
router.post('/:id/reject', requireRole(['BOARD', 'AUDITOR']), logActivity('REJECT_CERTIFICATION', 'CERTIFICATION'), rejectCertification)

module.exports = router
EOF

    # Winners Routes
    cat > "$APP_DIR/src/routes/winnersRoutes.js" << 'EOF'
const express = require('express')
const { 
  getWinnersByCategory, 
  getWinnersByContest, 
  signWinners, 
  getSignatureStatus,
  getCertificationProgress,
  getRoleCertificationStatus,
  certifyScores
} = require('../controllers/winnersController')
const { authenticateToken, requireRole } = require('../middleware/auth')
const { logActivity } = require('../middleware/errorHandler')

const router = express.Router()

// Apply authentication to all routes
router.use(authenticateToken)

// Winners endpoints
router.get('/category/:categoryId', requireRole(['ADMIN', 'BOARD', 'EMCEE']), getWinnersByCategory)
router.get('/contest/:contestId', requireRole(['ADMIN', 'BOARD', 'EMCEE']), getWinnersByContest)
router.post('/category/:categoryId/sign', requireRole(['JUDGE', 'TALLY_MASTER', 'AUDITOR', 'BOARD']), logActivity('SIGN_WINNERS', 'WINNER'), signWinners)
router.get('/category/:categoryId/signatures', requireRole(['ADMIN', 'BOARD', 'TALLY_MASTER', 'AUDITOR']), getSignatureStatus)

// Certification endpoints
router.get('/category/:categoryId/certification-progress', requireRole(['ADMIN', 'BOARD', 'TALLY_MASTER', 'AUDITOR', 'JUDGE']), getCertificationProgress)
router.get('/category/:categoryId/certification-status/:role', requireRole(['ADMIN', 'BOARD', 'TALLY_MASTER', 'AUDITOR', 'JUDGE']), getRoleCertificationStatus)
router.post('/category/:categoryId/certify', requireRole(['JUDGE', 'TALLY_MASTER', 'AUDITOR', 'BOARD']), logActivity('CERTIFY_SCORES', 'CERTIFICATION'), certifyScores)

module.exports = router
EOF

    print_success "Route files created successfully"
}

# Create modular server.js
create_modular_server() {
    print_status "Creating modular server.js..."
    
    cat > "$APP_DIR/src/server.js" << 'EOF'
const express = require('express')
const cors = require('cors')
const helmet = require('helmet')
const morgan = require('morgan')
const compression = require('compression')
const { Server } = require('socket.io')
const http = require('http')
const { PrismaClient } = require('@prisma/client')

// Load environment variables
require('dotenv').config()

// Import middleware
const { generalLimiter, authLimiter } = require('./middleware/rateLimiting')
const { errorHandler } = require('./middleware/errorHandler')

// Import routes
const authRoutes = require('./routes/authRoutes')
const eventsRoutes = require('./routes/eventsRoutes')
const contestsRoutes = require('./routes/contestsRoutes')
const categoriesRoutes = require('./routes/categoriesRoutes')
const usersRoutes = require('./routes/usersRoutes')
const scoringRoutes = require('./routes/scoringRoutes')
const resultsRoutes = require('./routes/resultsRoutes')
const adminRoutes = require('./routes/adminRoutes')
const uploadRoutes = require('./routes/uploadRoutes')
const settingsRoutes = require('./routes/settingsRoutes')
const smsRoutes = require('./routes/smsRoutes')
const archiveRoutes = require('./routes/archiveRoutes')
const backupRoutes = require('./routes/backupRoutes')
const assignmentsRoutes = require('./routes/assignmentsRoutes')
const fileRoutes = require('./routes/fileRoutes')
const performanceRoutes = require('./routes/performanceRoutes')
const certificationRoutes = require('./routes/certificationRoutes')
const auditorRoutes = require('./routes/auditorRoutes')
const boardRoutes = require('./routes/boardRoutes')
const tallyMasterRoutes = require('./routes/tallyMasterRoutes')
const judgeRoutes = require('./routes/judgeRoutes')
const emailRoutes = require('./routes/emailRoutes')
const reportsRoutes = require('./routes/reportsRoutes')
const printRoutes = require('./routes/printRoutes')
const exportRoutes = require('./routes/exportRoutes')
const fileManagementRoutes = require('./routes/fileManagementRoutes')
const fileBackupRoutes = require('./routes/fileBackupRoutes')
const errorHandlingRoutes = require('./routes/errorHandlingRoutes')
const templatesRoutes = require('./routes/templatesRoutes')
const eventTemplateRoutes = require('./routes/eventTemplateRoutes')
const notificationsRoutes = require('./routes/notificationsRoutes')
const emceeRoutes = require('./routes/emceeRoutes')
const navigationRoutes = require('./routes/navigationRoutes')
const advancedReportingRoutes = require('./routes/advancedReportingRoutes')
const winnersRoutes = require('./routes/winnersRoutes')

const app = express()
const server = http.createServer(app)
const prisma = new PrismaClient()
const PORT = process.env.PORT || 3000

// Socket.IO setup
const io = new Server(server, {
  cors: {
    origin: function (origin, callback) {
      if (!origin) return callback(null, true)
      if (origin.includes('localhost') || origin.includes('127.0.0.1')) {
        return callback(null, true)
      }
      if (origin.match(/^https?:\/\/\d+\.\d+\.\d+\.\d+/)) {
        return callback(null, true)
      }
      return callback(null, true)
    },
    methods: ["GET", "POST"],
    credentials: true
  }
})

// CORS configuration
const corsOptions = {
  origin: function (origin, callback) {
    if (!origin) return callback(null, true)
    if (origin.includes('localhost') || origin.includes('127.0.0.1')) {
      return callback(null, true)
    }
    if (origin.match(/^https?:\/\/\d+\.\d+\.\d+\.\d+/)) {
      return callback(null, true)
    }
    return callback(null, true)
  },
  credentials: true,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With']
}

// Trust proxy for rate limiting behind Nginx
app.set('trust proxy', 1)

// Middleware
app.use(helmet())
app.use(cors(corsOptions))
app.use(compression())
app.use(morgan('combined'))
app.use(express.json({ limit: '10mb' }))
app.use(express.urlencoded({ extended: true }))

// Rate limiting
app.use('/api/auth/', authLimiter)
app.use('/api/', generalLimiter)

// Performance monitoring middleware
const { logPerformance } = require('./controllers/performanceController')
app.use('/api/', logPerformance)

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'OK', timestamp: new Date().toISOString() })
})

// API Routes
app.use('/api/auth', authRoutes)
app.use('/api/events', eventsRoutes)
app.use('/api/contests', contestsRoutes)
app.use('/api/categories', categoriesRoutes)
app.use('/api/users', usersRoutes)
app.use('/api/scoring', scoringRoutes)
app.use('/api/results', resultsRoutes)
app.use('/api/admin', adminRoutes)
app.use('/api/upload', uploadRoutes)
app.use('/api/settings', settingsRoutes)
app.use('/api/sms', smsRoutes)
app.use('/api/archive', archiveRoutes)
app.use('/api/backup', backupRoutes)
app.use('/api/assignments', assignmentsRoutes)
app.use('/api/files', fileRoutes)
app.use('/api/performance', performanceRoutes)
app.use('/api/certifications', certificationRoutes)
app.use('/api/auditor', auditorRoutes)
app.use('/api/board', boardRoutes)
app.use('/api/tally-master', tallyMasterRoutes)
app.use('/api/judge', judgeRoutes)
app.use('/api/email', emailRoutes)
app.use('/api/reports', reportsRoutes)
app.use('/api/print', printRoutes)
app.use('/api/export', exportRoutes)
app.use('/api/file-management', fileManagementRoutes)
app.use('/api/file-backup', fileBackupRoutes)
app.use('/api/errors', errorHandlingRoutes)
app.use('/api/templates', templatesRoutes)
app.use('/api/event-templates', eventTemplateRoutes)
app.use('/api/notifications', notificationsRoutes)
app.use('/api/emcee', emceeRoutes)
app.use('/api/navigation', navigationRoutes)
app.use('/api/advanced-reports', advancedReportingRoutes)
app.use('/api/winners', winnersRoutes)

// Socket.IO connection handling
io.on('connection', (socket) => {
  console.log('User connected:', socket.id)
  
  socket.on('disconnect', () => {
    console.log('User disconnected:', socket.id)
  })
})

// Error handling middleware
app.use(errorHandler)

// Start server
server.listen(PORT, () => {
  console.log(` Event Manager API server running on port ${PORT}`)
})

// Graceful shutdown
process.on('SIGTERM', async () => {
  console.log('SIGTERM received, shutting down gracefully')
  await prisma.$disconnect()
  process.exit(0)
})

process.on('SIGINT', async () => {
  console.log('SIGINT received, shutting down gracefully')
  await prisma.$disconnect()
  process.exit(0)
})
EOF

    print_success "Modular server.js created successfully"
}

# Create essential backend files
create_backend_files() {
    print_status "Creating essential backend files..."
    
    # Create directories
    mkdir -p "$APP_DIR/src/database" "$APP_DIR/src/controllers" "$APP_DIR/src/middleware" "$APP_DIR/src/routes" "$APP_DIR/src/socket" "$APP_DIR/src/utils"
    
    # Create modular middleware files
    create_middleware_files
    
    # Create modular controller files
    create_controller_files
    
    # Create modular route files
    create_route_files
    
    # Create Prisma schema (overwrite if exists to ensure correct relations)
    print_status "Creating Prisma schema..."
    cat > "$APP_DIR/prisma/schema.prisma" << 'EOF'
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Event {
  id          String   @id @default(cuid())
  name        String
  description String?
  startDate   DateTime
  endDate     DateTime
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  contests         Contest[]
  archivedEvents   ArchivedEvent[]
  
  // New relations
  assignments     Assignment[]
  certifications  Certification[]
  files           File[] @relation("EventFiles")
  performanceLogs PerformanceLog[] @relation("EventPerformanceLogs")
  winnerSignatures WinnerSignature[]

  @@map("events")
}

model Contest {
  id          String   @id @default(cuid())
  eventId     String
  name        String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  event      Event      @relation(fields: [eventId], references: [id], onDelete: Cascade)
  categories Category[]
  contestants ContestContestant[]
  judges     ContestJudge[]
  
  // New relations
  assignments     Assignment[]
  certifications  Certification[]
  files           File[] @relation("ContestFiles")
  performanceLogs PerformanceLog[] @relation("ContestPerformanceLogs")
  winnerSignatures WinnerSignature[]

  @@map("contests")
}

model Category {
  id          String   @id @default(cuid())
  contestId   String
  name        String
  description String?
  scoreCap    Int?
  timeLimit   Int?
  contestantMin Int?
  contestantMax Int?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  contest      Contest      @relation(fields: [contestId], references: [id], onDelete: Cascade)
  contestants  CategoryContestant[]
  judges       CategoryJudge[]
  criteria     Criterion[]
  scores       Score[]
  comments     JudgeComment[]
  tallyMasterCertifications TallyMasterCertification[] @relation("TallyMasterCertifications")
  auditorCertifications AuditorCertification[]
  judgeCertifications JudgeCertification[] @relation("CategoryJudgeCertifications")
  
  // New relations
  assignments     Assignment[]
  certifications  Certification[]
  files           File[] @relation("CategoryFiles")
  performanceLogs PerformanceLog[] @relation("CategoryPerformanceLogs")
  winnerSignatures WinnerSignature[]
  scoreRemovalRequests ScoreRemovalRequest[]

  @@map("categories")
}

model Contestant {
  id               String   @id @default(cuid())
  name             String
  email            String?  @unique
  gender           String?
  pronouns         String?
  contestantNumber Int?
  bio              String?
  imagePath        String?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  users              User[]
  contestContestants ContestContestant[]
  categoryContestants CategoryContestant[]
  scores             Score[]
  comments           JudgeComment[]

  @@map("contestants")
}

model Judge {
  id         String   @id @default(cuid())
  name       String
  email      String?  @unique
  gender     String?
  pronouns   String?
  bio        String?
  imagePath  String?
  isHeadJudge Boolean @default(false)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  users            User[]
  contestJudges    ContestJudge[]
  categoryJudges   CategoryJudge[]
  scores           Score[]
  comments         JudgeComment[]
  certifications   JudgeCertification[] @relation("JudgeCertifications")

  @@map("judges")
}

model Criterion {
  id         String   @id @default(cuid())
  categoryId String
  name       String
  maxScore   Int
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  scores   Score[]

  @@map("criteria")
}

model Score {
  id           String   @id @default(cuid())
  categoryId   String
  contestantId String
  judgeId      String
  criterionId  String
  score        Int
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  category   Category   @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  contestant Contestant @relation(fields: [contestantId], references: [id], onDelete: Cascade)
  judge      Judge      @relation(fields: [judgeId], references: [id], onDelete: Cascade)
  criterion  Criterion  @relation(fields: [criterionId], references: [id], onDelete: Cascade)

  @@unique([categoryId, contestantId, judgeId, criterionId])
  @@map("scores")
}

model User {
  id             String   @id @default(cuid())
  name           String
  preferredName  String?
  email          String   @unique
  password       String
  role           UserRole
  gender         String?
  pronouns       String?
  judgeId        String?
  contestantId   String?
  sessionVersion Int      @default(1)
  isActive       Boolean  @default(true)
  lastLoginAt    DateTime?
  
  // Custom fields for Judges
  judgeBio           String?
  judgeSpecialties   String? // JSON array
  judgeCertifications String? // JSON array
  
  // Custom fields for Contestants
  contestantBio      String?
  contestantNumber   String?
  contestantAge      Int?
  contestantSchool   String?
  
  // Profile fields
  bio                String?
  phone              String?
  address            String?
  timezone           String?  @default("UTC")
  language           String?  @default("en")
  
  // Notification preferences
  notifications      String? // JSON object
  smsPhone           String?
  smsEnabled         Boolean  @default(false)
  
  // Privacy settings
  privacy            String? // JSON object
  
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  judge      Judge?      @relation(fields: [judgeId], references: [id])
  contestant Contestant? @relation(fields: [contestantId], references: [id])
  logs       ActivityLog[]
  updatedSettings SystemSetting[] @relation("UserUpdatedSettings")
  eventTemplates EventTemplate[]
  
  // New relations
  assignments     Assignment[]
  certifications  Certification[]
  files           File[]
  performanceLogs PerformanceLog[]
  reports         Report[]
  winnerSignatures WinnerSignature[]
  scoreRemovalRequests ScoreRemovalRequest[]

  @@map("users")
}

model JudgeComment {
  id           String   @id @default(cuid())
  categoryId   String
  contestantId String
  judgeId      String
  comment      String?
  createdAt    DateTime @default(now())

  category   Category   @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  contestant Contestant @relation(fields: [contestantId], references: [id], onDelete: Cascade)
  judge      Judge      @relation(fields: [judgeId], references: [id], onDelete: Cascade)

  @@unique([categoryId, contestantId, judgeId])
  @@map("judge_comments")
}

model JudgeCertification {
  id            String   @id @default(cuid())
  categoryId    String
  judgeId       String
  signatureName String
  certifiedAt   DateTime @default(now())

  category Category @relation("CategoryJudgeCertifications", fields: [categoryId], references: [id], onDelete: Cascade)
  judge    Judge    @relation("JudgeCertifications", fields: [judgeId], references: [id], onDelete: Cascade)

  @@unique([categoryId, judgeId])
  @@map("judge_certifications")
}

model TallyMasterCertification {
  id            String   @id @default(cuid())
  categoryId    String
  signatureName String
  certifiedAt   DateTime @default(now())

  category Category @relation("TallyMasterCertifications", fields: [categoryId], references: [id], onDelete: Cascade)

  @@unique([categoryId])
  @@map("tally_master_certifications")
}

model AuditorCertification {
  id            String   @id @default(cuid())
  categoryId    String
  signatureName String
  certifiedAt   DateTime @default(now())

  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@unique([categoryId])
  @@map("auditor_certifications")
}

model OverallDeduction {
  id           String   @id @default(cuid())
  categoryId   String
  contestantId String
  deduction    Float
  reason       String?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@unique([categoryId, contestantId])
  @@map("overall_deductions")
}

model ActivityLog {
  id           String   @id @default(cuid())
  userId       String?
  userName     String?
  userRole     String?
  action       String
  resourceType String?
  resourceId   String?
  details      String?
  ipAddress    String?
  userAgent    String?
  logLevel     LogLevel @default(INFO)
  createdAt    DateTime @default(now())

  user User? @relation(fields: [userId], references: [id])

  @@map("activity_logs")
}

model SystemSetting {
  id          String   @id @default(cuid())
  settingKey  String   @unique
  settingValue String
  description String?
  updatedAt   DateTime @updatedAt
  updatedById String?

  updatedBy User? @relation("UserUpdatedSettings", fields: [updatedById], references: [id])

  @@map("system_settings")
}

model PasswordPolicy {
  id                  String   @id @default(cuid())
  minLength           Int      @default(8)
  requireUppercase    Boolean  @default(true)
  requireLowercase    Boolean  @default(true)
  requireNumbers      Boolean  @default(true)
  requireSpecialChars Boolean  @default(true)
  isActive            Boolean  @default(true)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  
  @@map("password_policies")
}

model LoggingSetting {
  id          String   @id @default(cuid())
  level       LogLevel @default(INFO)
  enableAudit Boolean  @default(true)
  enableActivity Boolean @default(true)
  enableError Boolean  @default(true)
  maxLogAge   Int      @default(30) // days
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("logging_settings")
}

model SecuritySetting {
  id                    String   @id @default(cuid())
  passwordMinLength     Int      @default(8)
  passwordRequireUppercase Boolean @default(true)
  passwordRequireLowercase Boolean @default(true)
  passwordRequireNumbers Boolean @default(true)
  passwordRequireSymbols Boolean @default(false)
  passwordExpiryDays    Int      @default(90)
  maxLoginAttempts      Int      @default(5)
  lockoutDurationMinutes Int     @default(30)
  requireTwoFactor      Boolean  @default(false)
  sessionTimeoutMinutes Int      @default(480) // 8 hours
  enableIpWhitelist     Boolean  @default(false)
  allowedIps            String?  // JSON array
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  @@map("security_settings")
}

model BackupSetting {
  id              String   @id @default(cuid())
  enableAutoBackup Boolean  @default(false)
  backupFrequency String   @default("DAILY") // DAILY, WEEKLY, MONTHLY
  backupTime      String   @default("02:00") // HH:MM format
  retentionDays   Int      @default(30)
  backupLocation  String   @default("./backups")
  enableCompression Boolean @default(true)
  enableEncryption Boolean  @default(false)
  encryptionKey   String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@map("backup_settings")
}

model EmailSetting {
  id              String   @id @default(cuid())
  smtpHost        String?
  smtpPort        Int      @default(587)
  smtpSecure      Boolean  @default(false)
  smtpUser        String?
  smtpPassword    String?
  fromEmail       String?
  fromName        String?
  enableEmail     Boolean  @default(false)
  enableNotifications Boolean @default(true)
  enableReports   Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@map("email_settings")
}

model EventTemplate {
  id          String   @id @default(cuid())
  name        String
  description String?
  contests    Json
  categories  Json
  createdBy   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  creator     User     @relation(fields: [createdBy], references: [id])
  @@map("event_templates")
}

model EmceeScript {
  id          String   @id @default(cuid())
  eventId     String?
  contestId   String?
  categoryId  String?
  title       String
  content     String
  order       Int?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("emcee_scripts")
}

model ArchivedEvent {
  id          String   @id @default(cuid())
  eventId     String
  name        String
  description String?
  startDate   DateTime?
  endDate     DateTime?
  archivedAt  DateTime @default(now())
  archivedById String

  event Event @relation(fields: [eventId], references: [id])

  @@map("archived_events")
}

model CategoryTemplate {
  id          String   @id @default(cuid())
  name        String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  criteria TemplateCriterion[]

  @@map("category_templates")
}

model TemplateCriterion {
  id         String   @id @default(cuid())
  templateId String
  name       String
  maxScore   Int
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  template CategoryTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)

  @@map("template_criteria")
}

model JudgeScoreRemovalRequest {
  id           String        @id @default(cuid())
  categoryId   String
  contestantId String
  judgeId      String
  reason       String
  status       RequestStatus @default(PENDING)
  requestedAt  DateTime      @default(now())
  reviewedAt   DateTime?
  reviewedById String?

  @@map("judge_score_removal_requests")
}

model ContestContestant {
  contestId    String
  contestantId String

  contest    Contest    @relation(fields: [contestId], references: [id], onDelete: Cascade)
  contestant Contestant @relation(fields: [contestantId], references: [id], onDelete: Cascade)

  @@id([contestId, contestantId])
  @@map("contest_contestants")
}

model ContestJudge {
  contestId String
  judgeId   String

  contest Contest @relation(fields: [contestId], references: [id], onDelete: Cascade)
  judge   Judge   @relation(fields: [judgeId], references: [id], onDelete: Cascade)

  @@id([contestId, judgeId])
  @@map("contest_judges")
}

model CategoryContestant {
  categoryId   String
  contestantId String

  category   Category   @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  contestant Contestant @relation(fields: [contestantId], references: [id], onDelete: Cascade)

  @@id([categoryId, contestantId])
  @@map("category_contestants")
}

model CategoryJudge {
  categoryId String
  judgeId    String

  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  judge    Judge    @relation(fields: [judgeId], references: [id], onDelete: Cascade)

  @@id([categoryId, judgeId])
  @@map("category_judges")
}

// Assignment Management
model Assignment {
  id          String   @id @default(cuid())
  judgeId     String
  categoryId  String
  contestId   String
  eventId     String
  status      AssignmentStatus @default(PENDING)
  assignedAt  DateTime @default(now())
  assignedBy  String
  notes       String?
  priority    Int      @default(1)
  
  judge       User     @relation(fields: [judgeId], references: [id], onDelete: Cascade)
  category    Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  contest     Contest  @relation(fields: [contestId], references: [id], onDelete: Cascade)
  event       Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  
  @@unique([judgeId, categoryId])
  @@map("assignments")
}

// Certification Workflow
model Certification {
  id              String   @id @default(cuid())
  categoryId      String
  contestId       String
  eventId         String
  userId          String?
  status          CertificationStatus @default(PENDING)
  currentStep     Int      @default(1)
  totalSteps      Int      @default(4)
  judgeCertified  Boolean  @default(false)
  tallyCertified  Boolean  @default(false)
  auditorCertified Boolean @default(false)
  boardApproved   Boolean  @default(false)
  certifiedAt     DateTime?
  certifiedBy     String?
  rejectionReason String?
  comments        String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  category        Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  contest         Contest  @relation(fields: [contestId], references: [id], onDelete: Cascade)
  event           Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user            User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  @@unique([categoryId, contestId, eventId])
  @@map("certifications")
}

// File Management
model File {
  id          String   @id @default(cuid())
  filename    String
  originalName String
  mimeType    String
  size        Int
  path        String
  category    FileCategory
  uploadedBy  String
  uploadedAt  DateTime @default(now())
  isPublic    Boolean  @default(false)
  metadata    String?  // JSON
  checksum    String?
  
  // Relations
  user        User     @relation(fields: [uploadedBy], references: [id], onDelete: Cascade)
  event       Event?   @relation("EventFiles", fields: [eventId], references: [id], onDelete: Cascade)
  contest     Contest? @relation("ContestFiles", fields: [contestId], references: [id], onDelete: Cascade)
  categoryRef Category? @relation("CategoryFiles", fields: [categoryId], references: [id], onDelete: Cascade)
  
  // Foreign keys
  eventId     String?
  contestId   String?
  categoryId  String?
  
  @@map("files")
}

// Performance Monitoring
model PerformanceLog {
  id          String   @id @default(cuid())
  endpoint    String
  method      String
  responseTime Int
  statusCode  Int
  userId      String?
  ipAddress   String?
  userAgent   String?
  createdAt   DateTime @default(now())
  
  // Relations
  user        User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  event       Event?   @relation("EventPerformanceLogs", fields: [eventId], references: [id], onDelete: Cascade)
  contest     Contest? @relation("ContestPerformanceLogs", fields: [contestId], references: [id], onDelete: Cascade)
  category    Category? @relation("CategoryPerformanceLogs", fields: [categoryId], references: [id], onDelete: Cascade)
  
  // Foreign keys
  eventId     String?
  contestId   String?
  categoryId  String?
  
  @@map("performance_logs")
}

// Advanced Reporting
model Report {
  id          String   @id @default(cuid())
  name        String
  type        String
  parameters  String   // JSON
  format      String
  generatedBy String
  filePath    String?
  fileSize    Int?
  status      String   @default("GENERATED")
  createdAt   DateTime @default(now())
  
  user        User     @relation(fields: [generatedBy], references: [id], onDelete: Cascade)
  
  @@map("reports")
}

enum UserRole {
  ORGANIZER
  JUDGE
  CONTESTANT
  EMCEE
  TALLY_MASTER
  AUDITOR
  BOARD
}

enum LogLevel {
  ERROR
  WARN
  INFO
  DEBUG
}

enum RequestStatus {
  PENDING
  APPROVED
  REJECTED
}

model WinnerSignature {
  id          String   @id @default(cuid())
  categoryId  String
  contestId   String
  eventId     String
  userId      String
  userRole    String
  signature   String
  signedAt    DateTime @default(now())
  ipAddress   String?
  userAgent   String?
  
  category    Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  contest     Contest  @relation(fields: [contestId], references: [id], onDelete: Cascade)
  event       Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  @@unique([categoryId, userId])
  @@map("winner_signatures")
}

model ScoreRemovalRequest {
  id          String   @id @default(cuid())
  categoryId  String
  judgeId     String
  reason      String
  status      RequestStatus @default(PENDING)
  requestedBy String
  requestedAt DateTime @default(now())
  
  // Approval signatures
  tallySignature    String?
  tallySignedAt     DateTime?
  tallySignedBy     String?
  
  auditorSignature  String?
  auditorSignedAt   DateTime?
  auditorSignedBy   String?
  
  boardSignature    String?
  boardSignedAt     DateTime?
  boardSignedBy     String?
  
  category          Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  judge             User     @relation(fields: [judgeId], references: [id], onDelete: Cascade)
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
  
  @@map("score_removal_requests")
}

enum AssignmentStatus {
  PENDING
  ACTIVE
  COMPLETED
  CANCELLED
}

enum CertificationStatus {
  PENDING
  IN_PROGRESS
  CERTIFIED
  REJECTED
}

enum FileCategory {
  CONTESTANT_IMAGE
  JUDGE_IMAGE
  DOCUMENT
  TEMPLATE
  REPORT
  BACKUP
  OTHER
}
EOF
    
    # Create migration script (overwrite if exists to ensure correct operations)
    print_status "Creating database migration script..."
    cat > "$APP_DIR/src/database/migrate.js" << 'EOF'
const migrate = async () => {
  try {
    console.log(' Running database migrations...')
    
    // Generate Prisma client
    const { execSync } = require('child_process')
    console.log(' Generating Prisma client...')
    
    // Set environment to suppress npm warnings
    const env = { ...process.env }
    
    // Try different approaches for Prisma generation
    try {
      execSync('npx prisma generate', { stdio: 'inherit', env })
    } catch (error) {
      console.log('  npx prisma generate failed, trying alternative...')
      // Try using the full path to prisma
      const path = require('path')
      const prismaPath = path.join(process.cwd(), 'node_modules', '.bin', 'prisma')
      execSync(`node ${prismaPath} generate`, { stdio: 'inherit', env })
    }
    
    // Push schema to database
    console.log(' Pushing schema to database...')
    try {
      execSync('npx prisma db push', { stdio: 'inherit', env })
    } catch (error) {
      console.log('  npx prisma db push failed, trying alternative...')
      const path = require('path')
      const prismaPath = path.join(process.cwd(), 'node_modules', '.bin', 'prisma')
      execSync(`node ${prismaPath} db push`, { stdio: 'inherit', env })
    }
    
    console.log(' Database migrations completed successfully!')
  } catch (error) {
    console.error(' Migration failed:', error)
    console.error('Error details:', error.message)
    process.exit(1)
  }
}

const seed = async () => {
  try {
    // Import Prisma client after generation
    const { PrismaClient } = require('@prisma/client')
    const bcrypt = require('bcryptjs')
    
    const prisma = new PrismaClient()
    
    console.log(' Seeding database with initial data...')
    console.log(' Creating default users for all roles...')
    
    // Create default users for each role
    const hashedPassword = await bcrypt.hash('password123', 12)
    
    const defaultUsers = [
      {
        name: 'System Administrator',
        preferredName: 'Admin',
        email: 'admin@eventmanager.com',
        role: 'ORGANIZER',
        gender: 'Other',
        pronouns: 'they/them'
      },
      {
        name: 'John Judge',
        preferredName: 'John',
        email: 'judge@eventmanager.com',
        role: 'JUDGE',
        gender: 'Male',
        pronouns: 'he/him'
      },
      {
        name: 'Jane Contestant',
        preferredName: 'Jane',
        email: 'contestant@eventmanager.com',
        role: 'CONTESTANT',
        gender: 'Female',
        pronouns: 'she/her'
      },
      {
        name: 'Mike Emcee',
        preferredName: 'Mike',
        email: 'emcee@eventmanager.com',
        role: 'EMCEE',
        gender: 'Male',
        pronouns: 'he/him'
      },
      {
        name: 'Sarah Tally Master',
        preferredName: 'Sarah',
        email: 'tallymaster@eventmanager.com',
        role: 'TALLY_MASTER',
        gender: 'Female',
        pronouns: 'she/her'
      },
      {
        name: 'David Auditor',
        preferredName: 'David',
        email: 'auditor@eventmanager.com',
        role: 'AUDITOR',
        gender: 'Male',
        pronouns: 'he/him'
      },
      {
        name: 'Lisa Board Member',
        preferredName: 'Lisa',
        email: 'board@eventmanager.com',
        role: 'BOARD',
        gender: 'Female',
        pronouns: 'she/her'
      }
    ]
    
    // Create all default users
    for (const userData of defaultUsers) {
      const user = await prisma.user.upsert({
        where: { email: userData.email },
        update: {},
        create: {
          ...userData,
          password: hashedPassword
        }
      })
      console.log(` ${userData.role} user created:`, user.email)
    }
    
    console.log(` Successfully created ${defaultUsers.length} default users!`)
    
    // Create sample event
    const sampleEvent = await prisma.event.create({
      data: {
        name: 'Sample Event 2024',
        description: 'A sample event for testing the system',
        startDate: new Date('2024-01-01'),
        endDate: new Date('2024-01-02')
      }
    })
    
    console.log(' Sample event created:', sampleEvent.name)
    
    // Create sample contest
    const sampleContest = await prisma.contest.create({
      data: {
        eventId: sampleEvent.id,
        name: 'Sample Contest',
        description: 'A sample contest for testing'
      }
    })
    
    console.log(' Sample contest created:', sampleContest.name)
    
    // Create sample category
    const sampleCategory = await prisma.category.create({
      data: {
        contestId: sampleContest.id,
        name: 'Sample Category',
        description: 'A sample category for testing',
        scoreCap: 100
      }
    })
    
    console.log(' Sample category created:', sampleCategory.name)
    
    // Create sample contestants (use upsert to avoid duplicates)
    const contestants = await Promise.all([
      prisma.contestant.upsert({
        where: { email: 'john@example.com' },
        update: {},
        create: {
          name: 'John Doe',
          email: 'john@example.com',
          gender: 'Male',
          pronouns: 'he/him',
          contestantNumber: 1,
          bio: 'Sample contestant 1'
        }
      }),
      prisma.contestant.upsert({
        where: { email: 'jane@example.com' },
        update: {},
        create: {
          name: 'Jane Smith',
          email: 'jane@example.com',
          gender: 'Female',
          pronouns: 'she/her',
          contestantNumber: 2,
          bio: 'Sample contestant 2'
        }
      })
    ])
    
    console.log(' Sample contestants created:', contestants.length)
    
    // Create sample judges (use upsert to avoid duplicates)
    const judges = await Promise.all([
      prisma.judge.upsert({
        where: { email: 'judge1@example.com' },
        update: {},
        create: {
          name: 'Judge Johnson',
          email: 'judge1@example.com',
          gender: 'Male',
          pronouns: 'he/him',
          isHeadJudge: true,
          bio: 'Head judge'
        }
      }),
      prisma.judge.upsert({
        where: { email: 'judge2@example.com' },
        update: {},
        create: {
          name: 'Judge Williams',
          email: 'judge2@example.com',
          gender: 'Female',
          pronouns: 'she/her',
          isHeadJudge: false,
          bio: 'Assistant judge'
        }
      })
    ])
    
    console.log(' Sample judges created:', judges.length)
    
    // Create sample criteria
    const criteria = await Promise.all([
      prisma.criterion.create({
        data: {
          categoryId: sampleCategory.id,
          name: 'Technical Skill',
          maxScore: 40
        }
      }),
      prisma.criterion.create({
        data: {
          categoryId: sampleCategory.id,
          name: 'Presentation',
          maxScore: 30
        }
      }),
      prisma.criterion.create({
        data: {
          categoryId: sampleCategory.id,
          name: 'Creativity',
          maxScore: 30
        }
      })
    ])
    
    console.log(' Sample criteria created:', criteria.length)
    
    // Add contestants to category
    await Promise.all([
      prisma.categoryContestant.create({
        data: {
          categoryId: sampleCategory.id,
          contestantId: contestants[0].id
        }
      }),
      prisma.categoryContestant.create({
        data: {
          categoryId: sampleCategory.id,
          contestantId: contestants[1].id
        }
      })
    ])
    
    // Add judges to category
    await Promise.all([
      prisma.categoryJudge.create({
        data: {
          categoryId: sampleCategory.id,
          judgeId: judges[0].id
        }
      }),
      prisma.categoryJudge.create({
        data: {
          categoryId: sampleCategory.id,
          judgeId: judges[1].id
        }
      })
    ])
    
    // Create system settings (use upsert to avoid duplicates)
    const settings = await Promise.all([
      prisma.systemSetting.upsert({
        where: { settingKey: 'app_name' },
        update: {},
        create: {
          settingKey: 'app_name',
          settingValue: 'Event Manager',
          description: 'Application name'
        }
      }),
      prisma.systemSetting.upsert({
        where: { settingKey: 'app_version' },
        update: {},
        create: {
          settingKey: 'app_version',
          settingValue: '1.0.0',
          description: 'Application version'
        }
      }),
      prisma.systemSetting.upsert({
        where: { settingKey: 'max_file_size' },
        update: {},
        create: {
          settingKey: 'max_file_size',
          settingValue: '10485760',
          description: 'Maximum file upload size in bytes'
        }
      })
    ])
    
    console.log(' System settings created:', settings.length)
    
    console.log(' Database seeding completed successfully!')
    console.log('')
    console.log(' Default login credentials (all users have password: password123):')
    console.log('   ORGANIZER: admin@eventmanager.com')
    console.log('   JUDGE: judge@eventmanager.com')
    console.log('   CONTESTANT: contestant@eventmanager.com')
    console.log('   EMCEE: emcee@eventmanager.com')
    console.log('   TALLY_MASTER: tallymaster@eventmanager.com')
    console.log('   AUDITOR: auditor@eventmanager.com')
    console.log('   BOARD: board@eventmanager.com')
    
    await prisma.$disconnect()
    
  } catch (error) {
    console.error(' Seeding failed:', error)
    process.exit(1)
  }
}

const main = async () => {
  try {
    await migrate()
    await seed()
  } catch (error) {
    console.error(' Setup failed:', error)
    process.exit(1)
  }
}

if (require.main === module) {
  main()
}

module.exports = { migrate, seed }
EOF
    
    # Create seed script (overwrite if exists to ensure correct operations)
    print_status "Creating database seed script..."
    cat > "$APP_DIR/src/database/seed.js" << 'EOF'
const { seed } = require('./migrate')

const main = async () => {
  try {
    await seed()
  } catch (error) {
    console.error(' Seeding failed:', error)
    process.exit(1)
  }
}

if (require.main === module) {
  main()
}

module.exports = { seed }
EOF
    
    # Create modular server.js
    create_modular_server
    
    print_success "Essential backend files created!"
}

# Setup environment variables
setup_environment() {
    if [[ "$SKIP_ENV_CONFIG" == "true" ]]; then
        return
    fi
    
    print_status "Setting up environment variables..."
    
    # Generate secrets if not provided
    generate_secrets
    
    # Set default values if not provided
    if [[ -z "$APP_URL" ]]; then
        if [[ -n "$DOMAIN" ]]; then
            APP_URL="https://$DOMAIN"
        else
            APP_URL="http://localhost:3001"
        fi
    fi
    
    # Create backend .env file
    cat > "$APP_DIR/.env" << EOF
# Environment Configuration
NODE_ENV=$APP_ENV
PORT=3000

# Database Configuration
DATABASE_URL="postgresql://$DB_USER:$DB_PASSWORD@localhost:5432/$DB_NAME?schema=public"

# JWT Configuration
JWT_SECRET=$JWT_SECRET
JWT_EXPIRES_IN=24h

# Redis Configuration
REDIS_URL=redis://localhost:6379

# File Upload Configuration
UPLOAD_DIR=uploads
MAX_FILE_SIZE=10485760

# Security Configuration
BCRYPT_ROUNDS=12
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100

# Logging Configuration
LOG_LEVEL=info
LOG_FILE=logs/event-manager.log

# Email Configuration (optional)
SMTP_HOST=localhost
SMTP_PORT=587
SMTP_USER=
SMTP_PASS=
SMTP_FROM=noreply@eventmanager.com

# Session Configuration
SESSION_SECRET=$SESSION_SECRET
SESSION_TIMEOUT=1800000

# Application Configuration
APP_URL=$APP_URL
FRONTEND_URL=$APP_URL
EOF
    
    # Create frontend .env file
    # Use relative URLs for better domain/IP compatibility
    if [ -z "$API_URL" ]; then
        # Check if we have a domain configured
        if [ -n "$DOMAIN" ]; then
            # Use domain name for API URL
            API_URL="https://${DOMAIN}"
            WS_URL="wss://${DOMAIN}"
        else
            # Use relative URLs (empty strings) for better compatibility
            # This allows the frontend to use relative URLs that work with both IP and domain
            API_URL=""
            WS_URL=""
        fi
    else
        # Use provided API URL
        WS_URL="${API_URL/http:/ws:}"
        WS_URL="${WS_URL/https:/wss:}"
    fi
    
    print_status "Creating frontend environment with API_URL='$API_URL' and WS_URL='$WS_URL'"
    
    # Create frontend .env file with proper VITE variables
    cat > "$APP_DIR/frontend/.env" << EOF
# Frontend Environment Configuration
VITE_API_URL=$API_URL
VITE_WS_URL=$WS_URL
VITE_APP_NAME=Event Manager
VITE_APP_VERSION=1.0.0
VITE_APP_URL=$APP_URL
EOF
    
    # Verify frontend .env was created correctly
    if [ -f "$APP_DIR/frontend/.env" ]; then
        print_success "Frontend environment file created successfully"
        print_status "Frontend .env contents:"
        cat "$APP_DIR/frontend/.env" | sed 's/^/  /'
    else
        print_error "Failed to create frontend environment file"
        return 1
    fi
    
    # Secure environment files
    chmod 600 "$APP_DIR/.env" "$APP_DIR/frontend/.env"
    
    print_success "Environment variables configured"
}

# Setup database
setup_database() {
    # Create essential backend files first (always create these)
    create_backend_files
    
    if [[ "$AUTO_SETUP_DB" == "false" && "$NON_INTERACTIVE" == "false" ]]; then
        echo ""
        read -p "Setup database (create user, database, migrate, seed)? [y/N]: " -n 1 -r
        echo ""
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_status "Skipping database setup"
            return
        fi
    fi
    
    print_status "Setting up database..."
    
    # Create database user and database
    sudo -u postgres psql << EOF
-- Create user if it doesn't exist
DO \$\$
BEGIN
    IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = '$DB_USER') THEN
        CREATE ROLE $DB_USER WITH LOGIN PASSWORD '$DB_PASSWORD';
    END IF;
END
\$\$;

-- Create database if it doesn't exist
SELECT 'CREATE DATABASE $DB_NAME'
WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = '$DB_NAME')\gexec

-- Grant privileges
GRANT ALL PRIVILEGES ON DATABASE $DB_NAME TO $DB_USER;
GRANT ALL PRIVILEGES ON SCHEMA public TO $DB_USER;
GRANT ALL PRIVILEGES ON ALL TABLES IN SCHEMA public TO $DB_USER;
GRANT ALL PRIVILEGES ON ALL SEQUENCES IN SCHEMA public TO $DB_USER;

-- Set default privileges for future objects
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON TABLES TO $DB_USER;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT ALL ON SEQUENCES TO $DB_USER;
EOF
    
    # Create .npmrc to handle permission issues
    cat > "$APP_DIR/.npmrc" << EOF
legacy-peer-deps=true
audit-level=moderate
fund=false
EOF
    
    # Also create global .npmrc to suppress warnings
    cat > ~/.npmrc << EOF
legacy-peer-deps=true
audit-level=moderate
fund=false
EOF
    
    # Create package.json with updated dependencies
    print_status "Creating package.json with updated dependencies..."
    cat > "$APP_DIR/package.json" << 'EOF'
{
  "name": "event-manager-backend",
  "version": "1.0.0",
  "description": "Event Manager Backend API",
  "main": "src/server.js",
  "scripts": {
    "start": "node src/server.js",
    "dev": "nodemon src/server.js",
    "migrate": "node src/database/migrate.js",
    "seed": "node src/database/seed.js"
  },
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "helmet": "^7.1.0",
    "morgan": "^1.10.0",
    "dotenv": "^16.3.1",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.2",
    "multer": "^2.0.0",
    "nodemailer": "^6.9.7",
    "twilio": "^4.19.0",
    "socket.io": "^4.7.4",
    "prisma": "^5.22.0",
    "@prisma/client": "^5.22.0",
    "playwright": "^1.40.0",
    "supertest": "^7.1.3",
    "superagent": "^10.2.2",
    "compression": "^1.7.4",
    "express-rate-limit": "^8.1.0",
    "puppeteer": "^21.5.2",
    "handlebars": "^4.7.8",
    "xlsx": "^0.18.5",
    "csv-writer": "^1.6.0",
    "csv-parser": "^3.0.0",
    "xml2js": "^0.6.2",
    "pdfkit": "^0.14.0",
    "jspdf": "^2.5.1",
    "sharp": "^0.33.0"
  },
  "overrides": {
    "glob": "^10.3.10",
    "rimraf": "^5.0.5",
    "inflight": "npm:lru-cache@^10.0.0",
    "are-we-there-yet": "npm:@types/are-we-there-yet@^2.0.0",
    "lodash.pick": "npm:lodash@^4.17.21",
    "gauge": "npm:@types/gauge@^2.7.2",
    "npmlog": "npm:winston@^3.11.0",
    "supertest": "^7.1.3",
    "superagent": "^10.2.2",
    "@humanwhocodes/object-schema": "npm:@eslint/object-schema@^0.1.0",
    "@humanwhocodes/config-array": "npm:@eslint/config-array@^0.18.0",
    "eslint": "^9.0.0",
    "@npmcli/move-file": "npm:@npmcli/fs@^3.0.0",
    "glob@7.2.3": "npm:glob@^10.3.10",
    "rimraf@3.0.2": "npm:rimraf@^5.0.5",
    "inflight@1.0.6": "npm:lru-cache@^10.0.0",
    "@humanwhocodes/object-schema@2.0.3": "npm:@eslint/object-schema@^0.1.0",
    "@humanwhocodes/config-array@0.13.0": "npm:@eslint/config-array@^0.18.0",
    "eslint@8.57.1": "npm:eslint@^9.0.0"
  }
}
EOF

    # Install dependencies with proper error handling
    print_status "Installing Node.js dependencies..."
    cd "$APP_DIR"
    
    # Use the enhanced npm install function
    if ! safe_npm_install "$APP_DIR" "backend"; then
        print_error "Failed to install backend dependencies"
        exit 1
    fi
    
    # Make Node.js binaries executable before running migrations
    if [[ -d "$APP_DIR/node_modules/.bin" ]]; then
        chmod +x "$APP_DIR/node_modules/.bin"/*
        print_status "Fixed Node.js binary permissions for migration"
    fi
    
    # Clean up any existing Prisma client files
    print_status "Cleaning up existing Prisma client files..."
    rm -rf "$APP_DIR/node_modules/.prisma" 2>/dev/null || true
    rm -rf "$APP_DIR/node_modules/@prisma/client" 2>/dev/null || true
    
    # Make Prisma engine binaries executable
    print_status "Setting Prisma engine binary permissions..."
    if [[ -d "$APP_DIR/node_modules/@prisma/engines" ]]; then
        chmod +x "$APP_DIR/node_modules/@prisma/engines"/*
        print_status "Fixed Prisma engine binary permissions"
    fi
    
    # Generate Prisma Client
    print_status "Generating Prisma Client..."
    cd "$APP_DIR"
    if ! npx prisma generate; then
        print_error "Failed to generate Prisma Client"
        print_status "Trying alternative Prisma generation method..."
        if ! ./node_modules/.bin/prisma generate; then
            print_error "Alternative Prisma generation also failed"
            return 1
        fi
    fi
    print_success "Prisma Client generated successfully"
    
    # Validate Prisma schema
    print_status "Validating Prisma schema..."
    if ! npx prisma validate; then
        print_error "Prisma schema validation failed. Please check the schema file."
        return 1
    fi
    print_success "Prisma schema validation passed"
    
    # Verify Prisma Client is accessible
    print_status "Verifying Prisma Client accessibility..."
    if ! node -e "const { PrismaClient } = require('@prisma/client'); console.log('Prisma Client loaded successfully');"; then
        print_error "Prisma Client is not accessible"
        print_status "Attempting to regenerate Prisma Client..."
        rm -rf node_modules/@prisma/client
        if ! npx prisma generate; then
            print_error "Failed to regenerate Prisma Client"
            return 1
        fi
        print_success "Prisma Client regenerated successfully"
    else
        print_success "Prisma Client is accessible"
    fi
    
    # Test server startup with Prisma Client
    print_status "Testing server startup with Prisma Client..."
    if ! node -e "
        const express = require('express');
        const { PrismaClient } = require('@prisma/client');
        const app = express();
        const prisma = new PrismaClient();
        console.log('Server components loaded successfully');
        prisma.\$disconnect();
    "; then
        print_error "Server startup test failed"
        print_status "This may indicate Prisma Client issues"
        return 1
    fi
    print_success "Server startup test passed"
    
    # Run migrations
    print_status "Running database migrations..."
    npm run migrate
    
    print_success "Database setup complete"
}

# Setup web server permissions
setup_permissions() {
    if [[ "$SKIP_WEB_SERVER_PERMISSIONS" == "true" ]]; then
        return
    fi
    
    if [[ "$AUTO_SETUP_PERMISSIONS" == "false" && "$NON_INTERACTIVE" == "false" ]]; then
        echo ""
        read -p "Setup web server permissions? [y/N]: " -n 1 -r
        echo ""
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_status "Skipping web server permission setup"
            return
        fi
    fi
    
    print_status "Setting up web server permissions..."
    
    # Set ownership to web server user
    sudo chown -R "$WEB_SERVER_USER:$WEB_SERVER_USER" "$APP_DIR"
    
    # Set directory permissions (755)
    sudo find "$APP_DIR" -type d -exec chmod 755 {} \;
    
    # Set file permissions (644)
    sudo find "$APP_DIR" -type f -exec chmod 644 {} \;
    
    # Make Node.js binaries executable (fixes Prisma permission issues)
    if [[ -d "$APP_DIR/node_modules/.bin" ]]; then
        sudo chmod +x "$APP_DIR/node_modules/.bin"/*
        print_status "Fixed Node.js binary permissions"
    fi
    
    # Make Prisma engine binaries executable
    if [[ -d "$APP_DIR/node_modules/@prisma/engines" ]]; then
        sudo chmod +x "$APP_DIR/node_modules/@prisma/engines"/*
        print_status "Fixed Prisma engine binary permissions"
    fi
    
    # Make frontend binaries executable
    if [[ -d "$APP_DIR/frontend/node_modules/.bin" ]]; then
        sudo chmod +x "$APP_DIR/frontend/node_modules/.bin"/*
        print_status "Fixed frontend binary permissions"
    fi
    
    # Secure sensitive files (600)
    sudo chmod 600 "$APP_DIR/.env" "$APP_DIR/frontend/.env"
    
    # Make scripts executable
    sudo chmod 755 "$APP_DIR/setup.sh"
    if [[ -f "$APP_DIR/install.sh" ]]; then
        sudo chmod 755 "$APP_DIR/install.sh"
    fi
    
    # Create uploads and logs directories with proper permissions
    sudo mkdir -p "$APP_DIR/uploads" "$APP_DIR/logs"
    sudo chown -R "$WEB_SERVER_USER:$WEB_SERVER_USER" "$APP_DIR/uploads" "$APP_DIR/logs"
    sudo chmod 755 "$APP_DIR/uploads" "$APP_DIR/logs"
    
    print_success "Web server permissions configured"
}

# Check for PM2 and prompt user
check_pm2() {
    if command -v pm2 &> /dev/null; then
        if [[ "$NON_INTERACTIVE" == "false" ]]; then
            echo ""
            read -p "PM2 is installed. Use PM2 for process management? [y/N]: " -n 1 -r
            echo ""
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                USE_PM2=true
            fi
        fi
    fi
}

# Setup systemd service
setup_systemd_service() {
    if [[ "$USE_PM2" == "true" ]]; then
        print_status "Setting up PM2 process management..."
        
        # Create PM2 ecosystem file
        cat > "$APP_DIR/ecosystem.config.js" << EOF
module.exports = {
  apps: [{
    name: '$APP_NAME',
    script: 'src/server.js',
    cwd: '$APP_DIR',
    user: '$WEB_SERVER_USER',
    instances: 'max',
    exec_mode: 'cluster',
    env: {
      NODE_ENV: '$APP_ENV',
      PORT: 3000
    },
    error_file: './logs/err.log',
    out_file: './logs/out.log',
    log_file: './logs/combined.log',
    time: true
  }]
}
EOF
        
        # Start with PM2
        sudo -u "$WEB_SERVER_USER" pm2 start "$APP_DIR/ecosystem.config.js"
        sudo -u "$WEB_SERVER_USER" pm2 save
        sudo -u "$WEB_SERVER_USER" pm2 startup
        
    else
        print_status "Setting up systemd service..."
        
        # Create systemd service file
        sudo tee /etc/systemd/system/$APP_NAME.service > /dev/null << EOF
[Unit]
Description=$APP_NAME Node.js Application
After=network.target postgresql.service

[Service]
Type=simple
User=$WEB_SERVER_USER
Group=$WEB_SERVER_USER
WorkingDirectory=$APP_DIR
ExecStart=/usr/bin/node src/server.js
Restart=always
RestartSec=10
Environment=NODE_ENV=$APP_ENV
Environment=PORT=3000

[Install]
WantedBy=multi-user.target
EOF
        
        # Reload systemd and start service
        sudo systemctl daemon-reload
        sudo systemctl enable $APP_NAME
        sudo systemctl start $APP_NAME
        
        # Wait for service to start and check status
        sleep 5
        if sudo systemctl is-active --quiet $APP_NAME; then
            print_success "Systemd service configured and started successfully"
            
            # Test backend API endpoint
            print_status "Testing backend API endpoint..."
            if curl -f http://localhost:3000/health > /dev/null 2>&1; then
                print_success "Backend API is responding correctly"
            else
                print_warning "Backend API health check failed. Service may still be starting..."
                print_status "You can check service status with: sudo systemctl status $APP_NAME"
            fi
        else
            print_error "Failed to start $APP_NAME service"
            print_status "Check service status with: sudo systemctl status $APP_NAME"
            print_status "Check service logs with: sudo journalctl -u $APP_NAME -f"
        fi
    fi
}

# Configure Nginx
configure_nginx() {
    if [[ "$INSTALL_NGINX" == "false" ]]; then
        return
    fi
    
    print_status "Configuring Nginx..."
    
    # Create Nginx configuration
    sudo tee /etc/nginx/sites-available/$APP_NAME > /dev/null << EOF
server {
    listen 80;
    server_name ${DOMAIN:-localhost};
    
    # Backend API - Enhanced configuration
    location /api/ {
        proxy_pass http://127.0.0.1:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_cache_bypass \$http_upgrade;
        proxy_read_timeout 300s;
        proxy_connect_timeout 75s;
        
        # CORS headers for API
        add_header Access-Control-Allow-Origin * always;
        add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS" always;
        add_header Access-Control-Allow-Headers "Authorization, Content-Type" always;
        
        # Handle preflight requests
        if (\$request_method = 'OPTIONS') {
            add_header Access-Control-Allow-Origin * always;
            add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS" always;
            add_header Access-Control-Allow-Headers "Authorization, Content-Type" always;
            add_header Access-Control-Max-Age 1728000;
            add_header Content-Type 'text/plain charset=UTF-8';
            add_header Content-Length 0;
            return 204;
        }
    }
    
    # Socket.IO WebSocket proxy
    location /socket.io/ {
        proxy_pass http://127.0.0.1:3000;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_cache_bypass \$http_upgrade;
        proxy_buffering off;
        proxy_read_timeout 300s;
        proxy_connect_timeout 75s;
        
        # CORS headers for WebSocket
        add_header Access-Control-Allow-Origin * always;
        add_header Access-Control-Allow-Methods "GET, POST, OPTIONS" always;
        add_header Access-Control-Allow-Headers "Authorization, Content-Type" always;
    }
    
    # Health check endpoint
    location /health {
        proxy_pass http://127.0.0.1:3000/health;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
    }
    
    # Frontend static files
    location / {
        root $APP_DIR/frontend/dist;
        try_files \$uri \$uri/ /index.html;
        
        # Security headers
        add_header X-Frame-Options "SAMEORIGIN" always;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;
    }
    
    # Upload directory (no execution)
    location /uploads/ {
        root $APP_DIR;
        add_header X-Content-Type-Options "nosniff" always;
        location ~* \.(php|pl|py|jsp|asp|sh|cgi)$ {
            deny all;
        }
    }
}
EOF
    
    # Enable site
    sudo ln -sf /etc/nginx/sites-available/$APP_NAME /etc/nginx/sites-enabled/
    
    # Remove default site if it exists
    sudo rm -f /etc/nginx/sites-enabled/default
    
    # Test configuration
    sudo nginx -t
    
    # Reload Nginx
    sudo systemctl reload nginx
    
    print_success "Nginx configured"
}

# Setup SSL certificate
setup_ssl() {
    if [[ "$INSTALL_SSL" == "false" || -z "$DOMAIN" || -z "$EMAIL" ]]; then
        return
    fi
    
    print_status "Setting up SSL certificate..."
    
    # Obtain SSL certificate
    sudo certbot --nginx -d "$DOMAIN" --non-interactive --agree-tos -m "$EMAIL"
    
    # Setup automatic renewal
    echo "0 12 * * * root certbot renew --quiet" | sudo tee -a /etc/crontab
    
    print_success "SSL certificate configured"
}

# Fix Heroicons imports across all components
fix_heroicons_imports() {
    print_status "Fixing Heroicons imports across all components..."
    
    cd "$APP_DIR/frontend" || return 1
    
    # Clean up any malformed files first
    print_status "Cleaning up malformed files..."
    
    # Remove any stray ArrowDownTrayIcon, statements that may have been inserted incorrectly
    find src -name "*.tsx" -type f -exec sed -i '/^[[:space:]]*ArrowDownTrayIcon,[[:space:]]*$/d' {} \;
    find src -name "*.tsx" -type f -exec sed -i '/^[[:space:]]*PencilSquareIcon,[[:space:]]*$/d' {} \;
    find src -name "*.tsx" -type f -exec sed -i '/^[[:space:]]*CalculatorIcon,[[:space:]]*$/d' {} \;
    find src -name "*.tsx" -type f -exec sed -i '/^[[:space:]]*TrophyIcon,[[:space:]]*$/d' {} \;
    find src -name "*.tsx" -type f -exec sed -i '/^[[:space:]]*CircleStackIcon,[[:space:]]*$/d' {} \;
    
    print_status "Cleaned up malformed icon statements"
    
    # Fix Layout.tsx - Add missing icon imports (only if not already present) - Heroicons v2 compatible
    if [[ -f "src/components/Layout.tsx" ]]; then
        print_status "Checking Layout.tsx icon imports..."
        if ! grep -q "HomeIcon" "src/components/Layout.tsx"; then
            print_status "Adding missing icon imports to Layout.tsx..."
            sed -i '/import React, { useState } from '\''react'\''/a\
import {\
  HomeIcon,\
  CalendarIcon,\
  TrophyIcon,\
  ChartBarIcon,\
  UsersIcon,\
  CogIcon,\
  MicrophoneIcon,\
  DocumentTextIcon,\
  XMarkIcon,\
  PencilSquareIcon,\
  CalculatorIcon\
} from '\''@heroicons/react/24/outline'\''\
' "src/components/Layout.tsx"
        else
            print_status "Layout.tsx already has icon imports, skipping..."
        fi
    fi
    
    # Fix AdminPage.tsx
    if [[ -f "src/pages/AdminPage.tsx" ]]; then
        sed -i 's/DatabaseIcon/CircleStackIcon/g' "src/pages/AdminPage.tsx"
        sed -i 's/import {.*DatabaseIcon.*}/import { CircleStackIcon }/g' "src/pages/AdminPage.tsx"
    fi
    
    # Comprehensive fix for all reported TypeScript errors (Heroicons v2 compatible)
    print_status "Applying comprehensive TypeScript icon fixes for Heroicons v2..."
    
    # Fix AuditorPage.tsx - Add missing PencilSquareIcon and CalculatorIcon imports (Heroicons v2 names)
    if [[ -f "src/pages/AuditorPage.tsx" ]]; then
        # Replace PencilIcon with PencilSquareIcon (Heroicons v2 name)
        sed -i 's/PencilIcon/PencilSquareIcon/g' "src/pages/AuditorPage.tsx"
        
        # Fix API call signature
        sed -i 's/auditorAPI\.finalCertification(data)/auditorAPI.finalizeCertification(data)/g' "src/pages/AuditorPage.tsx"
        
        # No need to add imports - they're already included in the generated file
        print_status "Fixed AuditorPage.tsx PencilIcon -> PencilSquareIcon and API call"
    fi
    
    # Fix ReportsPage.tsx - Remove duplicate DocumentTextIcon and fix DownloadIcon
    if [[ -f "src/pages/ReportsPage.tsx" ]]; then
        # Remove duplicate DocumentTextIcon imports using a more reliable method
        awk '!seen[$0]++' "src/pages/ReportsPage.tsx" > "src/pages/ReportsPage.tsx.tmp" && mv "src/pages/ReportsPage.tsx.tmp" "src/pages/ReportsPage.tsx"
        
        # Replace DownloadIcon with ArrowDownTrayIcon (Heroicons v2 name)
        sed -i 's/DownloadIcon/ArrowDownTrayIcon/g' "src/pages/ReportsPage.tsx"
        
        # No need to add ArrowDownTrayIcon import - it's already included in the generated file
        print_status "Fixed ReportsPage.tsx duplicate imports and DownloadIcon"
    fi
    
    # Fix ResultsPage.tsx - Replace MedalIcon with TrophyIcon (Heroicons v2 name)
    if [[ -f "src/pages/ResultsPage.tsx" ]]; then
        sed -i 's/MedalIcon/TrophyIcon/g' "src/pages/ResultsPage.tsx"
        
        # No need to add TrophyIcon import - it's already included in the generated file
        print_status "Fixed ResultsPage.tsx MedalIcon -> TrophyIcon"
    fi
    
    # Fix SettingsPage.tsx - Replace DatabaseIcon with CircleStackIcon (Heroicons v2 name)
    if [[ -f "src/pages/SettingsPage.tsx" ]]; then
        sed -i 's/DatabaseIcon/CircleStackIcon/g' "src/pages/SettingsPage.tsx"
        
        # No need to add CircleStackIcon import - it's already included in the generated file
        print_status "Fixed SettingsPage.tsx DatabaseIcon -> CircleStackIcon"
    fi
    
    # Fix EmceePage.tsx
    if [[ -f "src/pages/EmceePage.tsx" ]]; then
        sed -i 's/VolumeUpIcon/SpeakerWaveIcon/g' "src/pages/EmceePage.tsx"
    fi
    
    # Fix PrintReports.tsx
    if [[ -f "src/components/PrintReports.tsx" ]]; then
        sed -i 's/DownloadIcon/ArrowDownTrayIcon/g' "src/components/PrintReports.tsx"
        sed -i 's/import { DocumentIcon, PrinterIcon, DownloadIcon }/import { DocumentIcon, PrinterIcon, ArrowDownTrayIcon }/g' "src/components/PrintReports.tsx"
    fi

    # Fix ResultsPage.tsx
    if [[ -f "src/pages/ResultsPage.tsx" ]]; then
        sed -i 's/MedalIcon/TrophyIcon/g' "src/pages/ResultsPage.tsx"
        sed -i 's/DownloadIcon/ArrowDownTrayIcon/g' "src/pages/ResultsPage.tsx"
        sed -i 's/import { TrophyIcon, MedalIcon, StarIcon, PrinterIcon, DownloadIcon }/import { TrophyIcon, StarIcon, PrinterIcon, ArrowDownTrayIcon }/g' "src/pages/ResultsPage.tsx"
        # Add missing MedalIcon if referenced
        if grep -q "MedalIcon" "src/pages/ResultsPage.tsx"; then
            sed -i 's/MedalIcon/TrophyIcon/g' "src/pages/ResultsPage.tsx"
        fi
    fi
    
    # Fix SettingsPage.tsx
    if [[ -f "src/pages/SettingsPage.tsx" ]]; then
        sed -i 's/DatabaseIcon/CircleStackIcon/g' "src/pages/SettingsPage.tsx"
        # Add missing DatabaseIcon if referenced
        if grep -q "DatabaseIcon" "src/pages/SettingsPage.tsx"; then
            sed -i 's/DatabaseIcon/CircleStackIcon/g' "src/pages/SettingsPage.tsx"
        fi
    fi
    
    # Fix TallyMasterPage.tsx
    if [[ -f "src/pages/TallyMasterPage.tsx" ]]; then
        sed -i 's/DocumentReportIcon/DocumentTextIcon/g' "src/pages/TallyMasterPage.tsx"
        sed -i 's/TrendingUpIcon/ArrowTrendingUpIcon/g' "src/pages/TallyMasterPage.tsx"
        sed -i 's/TrendingDownIcon/ArrowTrendingDownIcon/g' "src/pages/TallyMasterPage.tsx"
        # Fix API call signature
        sed -i 's/tallyMasterAPI\.certifyTotals(data)/tallyMasterAPI.certifyTotalsData(data)/g' "src/pages/TallyMasterPage.tsx"
        print_status "Fixed TallyMasterPage.tsx API calls"
    fi
    
    # Fix ArchiveManager.tsx API calls
    if [[ -f "src/components/ArchiveManager.tsx" ]]; then
        sed -i 's/archiveAPI\.archive(eventId, reason)/archiveAPI.archiveEvent(eventId, reason)/g' "src/components/ArchiveManager.tsx"
        sed -i 's/archiveAPI\.restore(eventId)/archiveAPI.restoreEvent(eventId)/g' "src/components/ArchiveManager.tsx"
        sed -i 's/archiveAPI\.delete(eventId)/archiveAPI.deleteEvent(eventId)/g' "src/components/ArchiveManager.tsx"
        print_status "Fixed ArchiveManager.tsx API calls"
    fi
    
    # Fix ProfilePage.tsx - Fix role type casting
    if [[ -f "src/pages/ProfilePage.tsx" ]]; then
        sed -i 's/role: user?.role || '\''JUDGE'\'',/role: (user?.role as any) || '\''JUDGE'\'',/g' src/pages/ProfilePage.tsx
    fi
    
    # Fix SettingsPage.tsx - Fix test method parameter type
    if [[ -f "src/pages/SettingsPage.tsx" ]]; then
        sed -i 's/settingsAPI.test(type)/settingsAPI.test(type as any)/g' src/pages/SettingsPage.tsx
    fi
    
    # Fix AdminPage.tsx - Fix getActivityLogs method call
    if [[ -f "src/pages/AdminPage.tsx" ]]; then
        sed -i 's/adminAPI.getActivityLogs({ searchTerm, dateFilter, actionFilter })/adminAPI.getActivityLogs()/g' src/pages/AdminPage.tsx
    fi
    
    # Add missing icon imports to components that need them
    print_status "Adding missing icon imports to components..."
    
    # Fix AuditLog.tsx
    if [[ -f "src/components/AuditLog.tsx" ]]; then
        if ! grep -q "TrophyIcon" "src/components/AuditLog.tsx"; then
            sed -i '/import {/,/} from/a\  TrophyIcon,' "src/components/AuditLog.tsx"
        fi
        if ! grep -q "ArrowDownTrayIcon" "src/components/AuditLog.tsx"; then
            sed -i '/import {/,/} from/a\  ArrowDownTrayIcon,' "src/components/AuditLog.tsx"
        fi
    fi
    
    # Fix BackupManager.tsx
    if [[ -f "src/components/BackupManager.tsx" ]]; then
        if ! grep -q "ArrowDownTrayIcon" "src/components/BackupManager.tsx"; then
            sed -i '/import {/,/} from/a\  ArrowDownTrayIcon,' "src/components/BackupManager.tsx"
        fi
    fi
    
    # Fix CategoryTemplates.tsx
    if [[ -f "src/components/CategoryTemplates.tsx" ]]; then
        if ! grep -q "TrophyIcon" "src/components/CategoryTemplates.tsx"; then
            sed -i '/import {/,/} from/a\  TrophyIcon,' "src/components/CategoryTemplates.tsx"
        fi
    fi
    
    # Fix CertificationWorkflow.tsx
    if [[ -f "src/components/CertificationWorkflow.tsx" ]]; then
        if ! grep -q "TrophyIcon" "src/components/CertificationWorkflow.tsx"; then
            sed -i '/import {/,/} from/a\  TrophyIcon,' "src/components/CertificationWorkflow.tsx"
        fi
    fi
    
    # Fix FileUpload.tsx
    if [[ -f "src/components/FileUpload.tsx" ]]; then
        if ! grep -q "TrophyIcon" "src/components/FileUpload.tsx"; then
            sed -i '/import {/,/} from/a\  TrophyIcon,' "src/components/FileUpload.tsx"
        fi
        if ! grep -q "ArrowDownTrayIcon" "src/components/FileUpload.tsx"; then
            sed -i '/import {/,/} from/a\  ArrowDownTrayIcon,' "src/components/FileUpload.tsx"
        fi
    fi
    
    # Fix Layout.tsx
    if [[ -f "src/components/Layout.tsx" ]]; then
        if ! grep -q "TrophyIcon" "src/components/Layout.tsx"; then
            sed -i '/import {/,/} from/a\  TrophyIcon,' "src/components/Layout.tsx"
        fi
    fi
    
    print_success "Heroicons imports fixed across all components"
}

# Fix TypeScript compilation errors automatically
fix_typescript_errors() {
    print_status "Resolving TypeScript compilation errors..."
    
    cd "$APP_DIR/frontend"
    
    # Clear TypeScript cache and node_modules cache
    print_status "Clearing TypeScript cache..."
    rm -rf node_modules/.cache
    rm -rf .tsbuildinfo
    rm -rf dist
    
    # 1. Fix API service - add missing methods and export api
    print_status "Updating API service with missing methods..."
    cat > "$APP_DIR/frontend/src/services/api.ts" << 'APIEOF'
import axios from 'axios'

const api = axios.create({
  baseURL: import.meta.env.VITE_API_URL || '/api',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
})

// Request interceptor to add auth token
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token')
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  },
  (error) => {
    return Promise.reject(error)
  }
)

// Response interceptor to handle errors
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      localStorage.removeItem('token')
      window.location.href = '/login'
    }
    return Promise.reject(error)
  }
)

export const eventsAPI = {
  getAll: () => api.get('/events'),
  getById: (id: string) => api.get(`/events/${id}`),
  create: (data: any) => api.post('/events', data),
  update: (id: string, data: any) => api.put(`/events/${id}`, data),
  delete: (id: string) => api.delete(`/events/${id}`),
}

export const contestsAPI = {
  getAll: async (): Promise<{ data: any[] }> => {
    const events = await api.get('/events')
    const allContests: any[] = []
    for (const event of events.data) {
      const contests = await api.get(`/contests/event/${event.id}`)
      allContests.push(...contests.data)
    }
    return { data: allContests }
  },
  getByEvent: (eventId: string) => api.get(`/contests/event/${eventId}`),
  getById: (id: string) => api.get(`/contests/${id}`),
  create: (eventId: string, data: any) => api.post(`/contests/event/${eventId}`, data),
  update: (id: string, data: any) => api.put(`/contests/${id}`, data),
  delete: (id: string) => api.delete(`/contests/${id}`),
}

export const categoriesAPI = {
  getAll: () => api.get('/categories'),
  getByContest: (contestId: string) => api.get(`/categories/contest/${contestId}`),
  getById: (id: string) => api.get(`/categories/${id}`),
  create: (contestId: string, data: any) => api.post(`/categories/contest/${contestId}`, data),
  update: (id: string, data: any) => api.put(`/categories/${id}`, data),
  delete: (id: string) => api.delete(`/categories/${id}`),
  getCategories: (params?: { contestId?: string; search?: string }) => api.get('/categories', { params }),
  createCategory: (data: any) => api.post('/categories', data),
  updateCategory: (id: string, data: any) => api.put(`/categories/${id}`, data),
  deleteCategory: (id: string) => api.delete(`/categories/${id}`),
  createCriterion: (data: any) => api.post('/categories/criteria', data),
  updateCriterion: (id: string, data: any) => api.put(`/categories/criteria/${id}`, data),
  deleteCriterion: (id: string) => api.delete(`/categories/criteria/${id}`),
}

export const scoringAPI = {
  getScores: (categoryId: string, contestantId: string) => api.get(`/scoring/category/${categoryId}/contestant/${contestantId}`),
  submitScore: (categoryId: string, contestantId: string, data: any) => api.post(`/scoring/category/${categoryId}/contestant/${contestantId}`, data),
  updateScore: (scoreId: string, data: any) => api.put(`/scoring/${scoreId}`, data),
  deleteScore: (scoreId: string) => api.delete(`/scoring/${scoreId}`),
  certifyScores: (categoryId: string) => api.post(`/scoring/category/${categoryId}/certify`),
  certifyTotals: (categoryId: string) => api.post(`/scoring/category/${categoryId}/certify-totals`),
  finalCertification: (categoryId: string) => api.post(`/scoring/category/${categoryId}/final-certification`),
  requestDeduction: (data: any) => api.post('/scoring/deductions', data),
  getDeductions: (categoryId?: string) => api.get(`/scoring/deductions${categoryId ? '?categoryId=' + categoryId : ''}`),
  approveDeduction: (deductionId: string, signature: string) => api.post(`/scoring/deductions/${deductionId}/approve`, { signature }),
  rejectDeduction: (deductionId: string, reason: string) => api.post(`/scoring/deductions/${deductionId}/reject`, { reason }),
}

export const resultsAPI = {
  getAll: () => api.get('/results'),
  getCategories: () => api.get('/results/categories'),
  getContestantResults: (contestantId: string) => api.get(`/results/contestant/${contestantId}`),
  getCategoryResults: (categoryId: string) => api.get(`/results/category/${categoryId}`),
  getContestResults: (contestId: string) => api.get(`/results/contest/${contestId}`),
  getEventResults: (eventId: string) => api.get(`/results/event/${eventId}`),
}

export const usersAPI = {
  getAll: () => api.get('/users'),
  getById: (id: string) => api.get(`/users/${id}`),
  create: (data: any) => api.post('/users', data),
  update: (id: string, data: any) => api.put(`/users/${id}`, data),
  updateProfile: (id: string, data: any) => api.put(`/users/profile/${id}`, data),
  delete: (id: string) => api.delete(`/users/${id}`),
  resetPassword: (id: string, data: any) => api.post(`/users/${id}/reset-password`, data),
  importCSV: (data: { csvData: any[], userType: string }) => api.post('/users/import-csv', data),
  getCSVTemplate: (userType: string) => api.get(`/users/csv-template?userType=${userType}`),
  getUsers: (params?: any) => api.get('/users', { params }),
  createUser: (data: any) => api.post('/users', data),
  updateUser: (id: string, data: any) => api.put(`/users/${id}`, data),
  deleteUser: (id: string) => api.delete(`/users/${id}`),
  bulkDeleteUsers: (ids: string[]) => api.post('/users/bulk-delete', { ids }),
}

export const adminAPI = {
  getStats: () => api.get('/admin/stats'),
  getLogs: (params?: any) => api.get('/admin/logs', { params }),
  getActiveUsers: () => api.get('/admin/active-users'),
  getSettings: () => api.get('/admin/settings'),
  updateSettings: (data: any) => api.put('/admin/settings', data),
  getUsers: () => api.get('/admin/users'),
  getEvents: () => api.get('/admin/events'),
  getContests: () => api.get('/admin/contests'),
  getCategories: () => api.get('/admin/categories'),
  getScores: () => api.get('/admin/scores'),
  getActivityLogs: () => api.get('/admin/activity-logs'),
  getAuditLogs: (params?: any) => api.get('/admin/audit-logs', { params }),
  exportAuditLogs: (params?: any) => api.post('/admin/export-audit-logs', params),
  testConnection: (type: string) => api.post(`/admin/test/${type}`),
  getPasswordPolicy: () => api.get('/admin/password-policy'),
  updatePasswordPolicy: (data: any) => api.put('/admin/password-policy', data),
}

export const uploadAPI = {
  uploadFile: (file: File, type: string = 'OTHER') => {
    const formData = new FormData()
    formData.append('file', file)
    formData.append('type', type)
    return api.post('/upload', formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
    })
  },
  uploadFileData: (fileData: FormData, type: string = 'OTHER') => {
    fileData.append('type', type)
    return api.post('/upload', fileData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
    })
  },
  deleteFile: (fileId: string) => api.delete(`/upload/${fileId}`),
  getFiles: (params?: any) => api.get('/upload/files', { params }),
}

export const archiveAPI = {
  getAll: () => api.get('/archive'),
  getActiveEvents: () => api.get('/events'),
  getArchivedEvents: () => api.get('/archive/events'),
  archive: (eventIdOrType: string, reasonOrId?: string, reason?: string) => {
    if (reason !== undefined) {
      // Called with (type, id, reason)
      return api.post(`/archive/${eventIdOrType}/${reasonOrId}`, { reason })
    } else {
      // Called with (eventId, reason) - treat as event archive
      return api.post(`/archive/event/${eventIdOrType}`, { reason: reasonOrId })
    }
  },
  restore: (eventIdOrType: string, id?: string) => {
    if (id !== undefined) {
      // Called with (type, id)
      return api.post(`/archive/${eventIdOrType}/${id}/restore`)
    } else {
      // Called with (eventId) - treat as event restore
      return api.post(`/archive/event/${eventIdOrType}/restore`)
    }
  },
  delete: (eventIdOrType: string, id?: string) => {
    if (id !== undefined) {
      // Called with (type, id)
      return api.delete(`/archive/${eventIdOrType}/${id}`)
    } else {
      // Called with (eventId) - treat as event delete
      return api.delete(`/archive/event/${eventIdOrType}`)
    }
  },
  archiveEvent: (eventId: string, reason: string) => api.post(`/archive/event/${eventId}`, { reason }),
  restoreEvent: (eventId: string) => api.post(`/archive/event/${eventId}/restore`),
  deleteEvent: (eventId: string) => api.delete(`/archive/event/${eventId}`),
  // Backward compatibility methods
  archiveSimple: (eventId: string, reason: string) => api.post(`/archive/event/${eventId}`, { reason }),
  restoreSimple: (eventId: string) => api.post(`/archive/event/${eventId}/restore`),
  deleteSimple: (eventId: string) => api.delete(`/archive/event/${eventId}`),
}

export const backupAPI = {
  getAll: () => api.get('/backup'),
  create: (type: 'FULL' | 'SCHEMA' | 'DATA') => api.post('/backup', { type }),
  list: () => api.get('/backup'),
  download: async (backupId: string) => {
    const response = await api.get(`/backup/${backupId}/download`, { responseType: 'blob' })
    return response.data
  },
  restore: (backupIdOrFile: string | File) => {
    if (typeof backupIdOrFile === 'string') {
      return api.post(`/backup/${backupIdOrFile}/restore`)
    } else {
      const formData = new FormData()
      formData.append('file', backupIdOrFile)
      return api.post('/backup/restore-from-file', formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      })
    }
  },
  restoreFromFile: (file: File) => {
    const formData = new FormData()
    formData.append('file', file)
    return api.post('/backup/restore-from-file', formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
    })
  },
  delete: (backupId: string) => api.delete(`/backup/${backupId}`),
}

export const settingsAPI = {
  getAll: () => api.get('/settings'),
  getSettings: () => api.get('/settings'),
  update: (data: any) => api.put('/settings', data),
  updateSettings: (data: any) => api.put('/settings', data),
  test: (type: 'email' | 'database' | 'backup') => api.post(`/settings/test/${type}`),
  getLoggingLevels: () => api.get('/settings/logging-levels'),
  updateLoggingLevel: (level: string) => api.put('/settings/logging-level', { level }),
  getSecuritySettings: () => api.get('/settings/security'),
  updateSecuritySettings: (settings: any) => api.put('/settings/security', settings),
  getBackupSettings: () => api.get('/settings/backup'),
  updateBackupSettings: (settings: any) => api.put('/settings/backup', settings),
  getEmailSettings: () => api.get('/settings/email'),
  updateEmailSettings: (settings: any) => api.put('/settings/email', settings),
}

export const assignmentsAPI = {
  getAll: () => api.get('/assignments'),
  getJudges: () => api.get('/assignments/judges'),
  getCategories: () => api.get('/assignments/categories'),
  assignJudge: (judgeId: string, categoryId: string) => api.post('/assignments/judge', { judgeId, categoryId }),
  removeAssignment: (assignmentId: string) => api.delete(`/assignments/${assignmentId}`),
  delete: (id: string) => api.delete(`/assignments/${id}`),
  create: (data: any) => api.post('/assignments', data),
  update: (id: string, data: any) => api.put(`/assignments/${id}`, data),
}

export const auditorAPI = {
  getStats: () => api.get('/auditor/stats'),
  getPendingAudits: () => api.get('/auditor/pending'),
  getCompletedAudits: () => api.get('/auditor/completed'),
  finalCertification: (categoryIdOrData: string | any, data?: any) => {
    if (typeof categoryIdOrData === 'string') {
      // Called with (categoryId, data)
      return api.post(`/auditor/category/${categoryIdOrData}/final-certification`, data)
    } else {
      // Called with (data) - extract categoryId from data
      const { categoryId, ...certificationData } = categoryIdOrData
      return api.post(`/auditor/category/${categoryId}/final-certification`, certificationData)
    }
  },
  rejectAudit: (categoryId: string, reason: string) => api.post(`/auditor/category/${categoryId}/reject`, { reason }),
  finalizeCertification: (data: any) => api.post('/auditor/finalize-certification', data),
  // Backward compatibility method
  finalCertificationSimple: (data: any) => api.post('/auditor/finalize-certification', data),
}

export const boardAPI = {
  getStats: () => api.get('/board/stats'),
  getCertifications: () => api.get('/board/certifications'),
  approveCertification: (id: string) => api.post(`/board/certifications/${id}/approve`),
  rejectCertification: (id: string, reason: string) => api.post(`/board/certifications/${id}/reject`, { reason }),
  getCertificationStatus: () => api.get('/board/certification-status'),
  getEmceeScripts: () => api.get('/board/emcee-scripts'),
}

export const tallyMasterAPI = {
  getStats: () => api.get('/tally-master/stats'),
  getCertifications: () => api.get('/tally-master/certifications'),
  getCertificationQueue: () => api.get('/tally-master/queue'),
  getPendingCertifications: () => api.get('/tally-master/pending'),
  certifyTotals: (categoryIdOrData: string | any, data?: any) => {
    if (typeof categoryIdOrData === 'string') {
      // Called with (categoryId, data)
      return api.post(`/tally-master/category/${categoryIdOrData}/certify-totals`, data)
    } else {
      // Called with (data) - extract categoryId from data
      const { categoryId, ...totalsData } = categoryIdOrData
      return api.post(`/tally-master/category/${categoryId}/certify-totals`, totalsData)
    }
  },
  certifyTotalsData: (data: any) => api.post('/tally-master/certify-totals', data),
  // Backward compatibility method
  certifyTotalsSimple: (data: any) => api.post('/tally-master/certify-totals', data),
}

export const emailAPI = {
  getTemplates: () => api.get('/email/templates'),
  createTemplate: (data: any) => api.post('/email/templates', data),
  updateTemplate: (id: string, data: any) => api.put(`/email/templates/${id}`, data),
  deleteTemplate: (id: string) => api.delete(`/email/templates/${id}`),
  getCampaigns: () => api.get('/email/campaigns'),
  createCampaign: (data: any) => api.post('/email/campaigns', data),
  sendCampaign: (id: string) => api.post(`/email/campaigns/${id}/send`),
  getLogs: () => api.get('/email/logs'),
  sendMultiple: (data: { recipients: string[], subject: string, content: string }) => api.post('/email/send-multiple', data),
  sendByRole: (data: { roles: string[], subject: string, content: string }) => api.post('/email/send-by-role', data),
}

export const bulkImportAPI = {
  importUsers: (formData: FormData) => api.post('/bulk-import/users', formData, {
    headers: {
      'Content-Type': 'multipart/form-data',
    },
  }),
  downloadSample: () => api.get('/bulk-import/sample', { responseType: 'blob' }),
}

export const databaseBrowserAPI = {
  getTables: () => api.get('/database/tables'),
  getTableData: (tableName: string, page = 1, limit = 50, search = '') =>
    api.get(`/database/tables/${tableName}`, { params: { page, limit, search } }),
  getTableSchema: (tableName: string) => api.get(`/database/tables/${tableName}/schema`),
  insertRecord: (tableName: string, data: any) => api.post(`/database/tables/${tableName}`, data),
  updateRecord: (tableName: string, id: string, data: any) =>
    api.put(`/database/tables/${tableName}/${id}`, data),
  deleteRecord: (tableName: string, id: string) =>
    api.delete(`/database/tables/${tableName}/${id}`),
  executeQuery: (query: string) => api.post('/database/query', { query }),
  getTableStats: (tableName: string) => api.get(`/database/tables/${tableName}/stats`),
}

export const eventTemplatesAPI = {
  getTemplates: (params?: { search?: string; isPublic?: boolean }) => 
    api.get('/event-templates', { params }),
  getTemplate: (id: string) => api.get(`/event-templates/${id}`),
  createTemplate: (data: any) => api.post('/event-templates', data),
  updateTemplate: (id: string, data: any) => api.put(`/event-templates/${id}`, data),
  deleteTemplate: (id: string) => api.delete(`/event-templates/${id}`),
  createEventFromTemplate: (templateId: string, eventData: any) => 
    api.post(`/event-templates/${templateId}/create-event`, eventData),
}

export const reportsAPI = {
  getReports: (params?: { search?: string; type?: string; status?: string }) => 
    api.get('/reports', { params }),
  getTemplates: () => api.get('/reports/templates'),
  createReport: (data: any) => api.post('/reports', data),
  generateReport: (id: string) => api.post(`/reports/${id}/generate`),
  deleteReport: (id: string) => api.delete(`/reports/${id}`),
  emailReport: (reportId: string, data: { recipients: string; subject: string; message: string }) => 
    api.post(`/reports/${reportId}/email`, data),
}

export const winnersAPI = {
  getWinners: (params?: { eventId?: string; contestId?: string; categoryId?: string }) => 
    api.get('/winners', { params }),
  certifyWinner: (winnerId: string, signature: string) => 
    api.post(`/winners/${winnerId}/certify`, { signature }),
}

// Export the api instance for direct use
export { api }
export default api

APIEOF

    # 2. Fix ArchiveManager component
    cat > src/components/ArchiveManager.tsx << 'ARCHIVEEOF'
import React, { useState } from 'react'
import { useQuery, useMutation, useQueryClient } from 'react-query'
import { archiveAPI } from '../services/api'
import { ArchiveBoxIcon, ArrowUturnLeftIcon, TrashIcon, EyeIcon } from '@heroicons/react/24/outline'

interface ArchivedEvent {
  id: string
  name: string
  description: string
  startDate: string
  endDate: string
  location: string
  archivedAt: string
  archivedBy: string
  reason: string
  originalEventId: string
  contests: number
  contestants: number
  totalScores: number
}

const ArchiveManager: React.FC = () => {
  const [selectedEvent, setSelectedEvent] = useState<ArchivedEvent | null>(null)
  const [showRestoreModal, setShowRestoreModal] = useState(false)
  const [showDeleteModal, setShowDeleteModal] = useState(false)
  const [showArchiveModal, setShowArchiveModal] = useState(false)
  const [archiveReason, setArchiveReason] = useState('')
  const queryClient = useQueryClient()

  // Fetch archived events
  const { data: archivedEvents, isLoading: archivedLoading } = useQuery(
    'archivedEvents',
    () => archiveAPI.getArchivedEvents().then((res: any) => res.data),
  )

  // Fetch active events for archiving
  const { data: activeEvents, isLoading: activeLoading } = useQuery(
    'activeEvents',
    () => archiveAPI.getActiveEvents().then((res: any) => res.data),
  )

  const archiveMutation = useMutation(
    ({ eventId, reason }: { eventId: string; reason: string }) => 
      archiveAPI.archiveEvent(eventId, reason),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('archivedEvents')
        queryClient.invalidateQueries('activeEvents')
        setShowArchiveModal(false)
        setArchiveReason('')
      }
    }
  )

  const restoreMutation = useMutation(
    (eventId: string) => archiveAPI.restoreEvent(eventId),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('archivedEvents')
        queryClient.invalidateQueries('activeEvents')
        setShowRestoreModal(false)
      }
    }
  )

  const deleteMutation = useMutation(
    (eventId: string) => archiveAPI.deleteEvent(eventId),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('archivedEvents')
        setShowDeleteModal(false)
      }
    }
  )

  const handleArchive = () => {
    if (selectedEvent && archiveReason.trim()) {
      archiveMutation.mutate({ eventId: selectedEvent.id, reason: archiveReason })
    }
  }

  const handleRestore = () => {
    if (selectedEvent) {
      restoreMutation.mutate(selectedEvent.id)
    }
  }

  const handleDelete = () => {
    if (selectedEvent) {
      deleteMutation.mutate(selectedEvent.id)
    }
  }

  return (
    <div className="space-y-6">
      <div className="card">
        <div className="card-header">
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Archive Manager</h1>
          <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
            Manage archived events and restore them when needed
          </p>
        </div>
        <div className="card-body">
          <div className="text-center py-12">
            <ArchiveBoxIcon className="h-12 w-12 text-gray-400 mx-auto mb-4" />
            <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">Archive Manager</h3>
            <p className="text-gray-600 dark:text-gray-400">Archive management functionality will be implemented here</p>
          </div>
        </div>
      </div>
    </div>
  )
}

export default ArchiveManager
ARCHIVEEOF

    # 2. Fix ProfilePage role type casting
    print_status "Fixing ProfilePage role type casting..."
    if [ -f "src/pages/ProfilePage.tsx" ]; then
        sed -i 's/role: user?.role || '\''JUDGE'\'',/role: (user?.role as any) || '\''JUDGE'\'',/g' src/pages/ProfilePage.tsx
    fi

    # 3. Fix SettingsPage test method parameter type
    print_status "Fixing SettingsPage test method parameter type..."
    if [ -f "src/pages/SettingsPage.tsx" ]; then
        sed -i 's/settingsAPI.test(type)/settingsAPI.test(type as any)/g' src/pages/SettingsPage.tsx
    fi

    # 4. Fix AdminPage getActivityLogs method call
    print_status "Fixing AdminPage getActivityLogs method call..."
    if [ -f "src/pages/AdminPage.tsx" ]; then
        sed -i 's/adminAPI.getActivityLogs({ searchTerm, dateFilter, actionFilter })/adminAPI.getActivityLogs()/g' src/pages/AdminPage.tsx
    fi

    # 5. Fix PrintReports component - replace DownloadIcon with ArrowDownTrayIcon
    print_status "Fixing PrintReports component icon import..."
    if [ -f "src/components/PrintReports.tsx" ]; then
        sed -i 's/DownloadIcon/ArrowDownTrayIcon/g' src/components/PrintReports.tsx
        sed -i 's/import { DocumentIcon, PrinterIcon, DownloadIcon }/import { DocumentIcon, PrinterIcon, ArrowDownTrayIcon }/g' src/components/PrintReports.tsx
    fi

    # 6. Fix all import statements to use correct import syntax
    print_status "Fixing API import statements..."
    # Remove any incorrect default imports and ensure named imports are used
    find src -name "*.tsx" -o -name "*.ts" | xargs sed -i 's/import api from/import { api } from/g' 2>/dev/null || true

    print_success "TypeScript errors resolved automatically"
    
    # Regenerate TypeScript types
    print_status "Regenerating TypeScript types..."
    npx tsc --noEmit --skipLibCheck
}

# Build frontend
build_frontend() {
    print_status "Building comprehensive frontend..."
    
    cd "$APP_DIR/frontend"
    
    # Generate API service first to ensure all components have access to updated APIs
    print_status "Generating API service with all required methods..."
    cat > "$APP_DIR/frontend/src/services/api.ts" << 'APIEOF'
import axios from 'axios'

const api = axios.create({
  baseURL: import.meta.env.VITE_API_URL || '/api',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
})

// Request interceptor to add auth token
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token')
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  },
  (error) => {
    return Promise.reject(error)
  }
)

// Response interceptor to handle errors
api.interceptors.response.use(
  (response) => {
    return response
  },
  (error) => {
    if (error.response?.status === 401) {
      localStorage.removeItem('token')
      window.location.href = '/login'
    }
    return Promise.reject(error)
  }
)

export const eventsAPI = {
  getAll: () => api.get('/events'),
  getById: (id: string) => api.get(`/events/${id}`),
  create: (data: any) => api.post('/events', data),
  update: (id: string, data: any) => api.put(`/events/${id}`, data),
  delete: (id: string) => api.delete(`/events/${id}`),
}

export const contestsAPI = {
  getAll: async (): Promise<{ data: any[] }> => {
    const events = await api.get('/events')
    const allContests: any[] = []
    for (const event of events.data) {
      const contests = await api.get(`/contests/event/${event.id}`)
      allContests.push(...contests.data.map((contest: any) => ({ ...contest, eventId: event.id })))
    }
    return { data: allContests }
  },
  getByEvent: (eventId: string) => api.get(`/contests/event/${eventId}`),
  getById: (id: string) => api.get(`/contests/${id}`),
  create: (eventId: string, data: any) => api.post(`/contests/event/${eventId}`, data),
  update: (id: string, data: any) => api.put(`/contests/${id}`, data),
  delete: (id: string) => api.delete(`/contests/${id}`),
}

export const categoriesAPI = {
  getAll: () => api.get('/categories'),
  getByContest: (contestId: string) => api.get(`/categories/contest/${contestId}`),
  getById: (id: string) => api.get(`/categories/${id}`),
  create: (contestId: string, data: any) => api.post(`/categories/contest/${contestId}`, data),
  update: (id: string, data: any) => api.put(`/categories/${id}`, data),
  delete: (id: string) => api.delete(`/categories/${id}`),
  getCategories: (params?: { contestId?: string; search?: string }) => api.get('/categories', { params }),
  createCategory: (data: any) => api.post('/categories', data),
  updateCategory: (id: string, data: any) => api.put(`/categories/${id}`, data),
  deleteCategory: (id: string) => api.delete(`/categories/${id}`),
  createCriterion: (data: any) => api.post('/categories/criteria', data),
  updateCriterion: (id: string, data: any) => api.put(`/categories/criteria/${id}`, data),
  deleteCriterion: (id: string) => api.delete(`/categories/criteria/${id}`),
}

export const scoringAPI = {
  getScores: (categoryId: string, contestantId: string) => api.get(`/scoring/category/${categoryId}/contestant/${contestantId}`),
  submitScore: (categoryId: string, contestantId: string, data: any) => api.post(`/scoring/category/${categoryId}/contestant/${contestantId}`, data),
  updateScore: (scoreId: string, data: any) => api.put(`/scoring/${scoreId}`, data),
  deleteScore: (scoreId: string) => api.delete(`/scoring/${scoreId}`),
  certifyScores: (categoryId: string) => api.post(`/scoring/category/${categoryId}/certify`),
  getCertificationStatus: (categoryId: string) => api.get(`/scoring/category/${categoryId}/certification-status`),
  getJudgeScores: (judgeId: string, categoryId: string) => api.get(`/scoring/judge/${judgeId}/category/${categoryId}`),
  getDeductions: (categoryId?: string) => api.get(`/scoring/deductions${categoryId ? '?categoryId=' + categoryId : ''}`),
  approveDeduction: (deductionId: string, signature: string) => api.post(`/scoring/deductions/${deductionId}/approve`, { signature }),
  rejectDeduction: (deductionId: string, reason: string) => api.post(`/scoring/deductions/${deductionId}/reject`, { reason }),
  getCategories: () => api.get('/scoring/categories'),
  submitScoreData: (scoreData: any) => api.post('/scoring/submit', scoreData),
}

export const resultsAPI = {
  getAll: () => api.get('/results'),
  getCategories: () => api.get('/results/categories'),
  getContestantResults: (contestantId: string) => api.get(`/results/contestant/${contestantId}`),
  getCategoryResults: (categoryId: string) => api.get(`/results/category/${categoryId}`),
  getContestResults: (contestId: string) => api.get(`/results/contest/${contestId}`),
  getEventResults: (eventId: string) => api.get(`/results/event/${eventId}`),
}

export const usersAPI = {
  getAll: () => api.get('/users'),
  getById: (id: string) => api.get(`/users/${id}`),
  create: (data: any) => api.post('/users', data),
  update: (id: string, data: any) => api.put(`/users/${id}`, data),
  updateProfile: (id: string, data: any) => api.put(`/users/profile/${id}`, data),
  delete: (id: string) => api.delete(`/users/${id}`),
  resetPassword: (id: string, data: any) => api.post(`/users/${id}/reset-password`, data),
  importCSV: (data: { csvData: any[], userType: string }) => api.post('/users/import-csv', data),
  getCSVTemplate: (userType: string) => api.get(`/users/csv-template?userType=${userType}`),
  getUsers: (params?: any) => api.get('/users', { params }),
  createUser: (data: any) => api.post('/users', data),
  updateUser: (id: string, data: any) => api.put(`/users/${id}`, data),
  deleteUser: (id: string) => api.delete(`/users/${id}`),
  bulkDeleteUsers: (ids: string[]) => api.post('/users/bulk-delete', { ids }),
}

export const adminAPI = {
  getStats: () => api.get('/admin/stats'),
  getLogs: (params?: any) => api.get('/admin/logs', { params }),
  getActiveUsers: () => api.get('/admin/active-users'),
  getSettings: () => api.get('/admin/settings'),
  updateSettings: (data: any) => api.put('/admin/settings', data),
  getUsers: () => api.get('/admin/users'),
  getEvents: () => api.get('/admin/events'),
  getContests: () => api.get('/admin/contests'),
  getCategories: () => api.get('/admin/categories'),
  getScores: () => api.get('/admin/scores'),
  getActivityLogs: () => api.get('/admin/activity-logs'),
  getAuditLogs: (params?: any) => api.get('/admin/audit-logs', { params }),
  exportAuditLogs: (params?: any) => api.post('/admin/export-audit-logs', params),
  testConnection: (type: string) => api.post(`/admin/test/${type}`),
  getPasswordPolicy: () => api.get('/admin/password-policy'),
  updatePasswordPolicy: (data: any) => api.put('/admin/password-policy', data),
}

export const uploadAPI = {
  uploadFile: (file: File, type: string = 'OTHER') => {
    const formData = new FormData()
    formData.append('file', file)
    formData.append('type', type)
    return api.post('/upload', formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
    })
  },
  uploadMultipleFiles: (files: File[], type: string = 'OTHER') => {
    const formData = new FormData()
    files.forEach((file, index) => {
      formData.append(`files`, file)
    })
    formData.append('type', type)
    return api.post('/upload/multiple', formData, {
      headers: {
        'Content-Type': 'multipart/form-data',
      },
    })
  },
  deleteFile: (fileId: string) => api.delete(`/upload/${fileId}`),
  getFiles: (params?: any) => api.get('/upload/files', { params }),
}

export const archiveAPI = {
  getAll: () => api.get('/archive'),
  getActiveEvents: () => api.get('/events'),
  getArchivedEvents: () => api.get('/archive/events'),
  archive: (eventIdOrType: string, reasonOrId?: string, reason?: string) => {
    if (reason !== undefined) {
      // Called with (type, id, reason)
      return api.post(`/archive/${eventIdOrType}/${reasonOrId}`, { reason })
    } else {
      // Called with (eventId, reason) - treat as event archive
      return api.post(`/archive/event/${eventIdOrType}`, { reason: reasonOrId })
    }
  },
  restore: (eventIdOrType: string, id?: string) => {
    if (id !== undefined) {
      // Called with (type, id)
      return api.post(`/archive/${eventIdOrType}/${id}/restore`)
    } else {
      // Called with (eventId) - treat as event restore
      return api.post(`/archive/event/${eventIdOrType}/restore`)
    }
  },
  delete: (eventIdOrType: string, id?: string) => {
    if (id !== undefined) {
      // Called with (type, id)
      return api.delete(`/archive/${eventIdOrType}/${id}`)
    } else {
      // Called with (eventId) - treat as event delete
      return api.delete(`/archive/event/${eventIdOrType}`)
    }
  },
  archiveEvent: (eventId: string, reason: string) => api.post(`/archive/event/${eventId}`, { reason }),
  restoreEvent: (eventId: string) => api.post(`/archive/event/${eventId}/restore`),
  deleteEvent: (eventId: string) => api.delete(`/archive/event/${eventId}`),
  // Backward compatibility methods
  archiveSimple: (eventId: string, reason: string) => api.post(`/archive/event/${eventId}`, { reason }),
  restoreSimple: (eventId: string) => api.post(`/archive/event/${eventId}/restore`),
  deleteSimple: (eventId: string) => api.delete(`/archive/event/${eventId}`),
}

export const backupAPI = {
  getAll: () => api.get('/backup'),
  create: (type: 'FULL' | 'SCHEMA' | 'DATA') => api.post('/backup', { type }),
  list: () => api.get('/backup'),
  download: async (backupId: string) => {
    const response = await api.get(`/backup/${backupId}/download`, { responseType: 'blob' })
    const blob = new Blob([response.data])
    const url = window.URL.createObjectURL(blob)
    const link = document.createElement('a')
    link.href = url
    link.download = `backup-${backupId}.sql`
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
    window.URL.revokeObjectURL(url)
  },
  restore: (backupId: string) => api.post(`/backup/${backupId}/restore`),
  delete: (backupId: string) => api.delete(`/backup/${backupId}`),
}

export const settingsAPI = {
  getAll: () => api.get('/settings'),
  getSettings: () => api.get('/settings'),
  update: (data: any) => api.put('/settings', data),
  updateSettings: (data: any) => api.put('/settings', data),
  test: (type: 'email' | 'database' | 'backup') => api.post(`/settings/test/${type}`),
  getLoggingSettings: () => api.get('/settings/logging'),
  updateLoggingSettings: (settings: any) => api.put('/settings/logging', settings),
  getSecuritySettings: () => api.get('/settings/security'),
  updateSecuritySettings: (settings: any) => api.put('/settings/security', settings),
  getBackupSettings: () => api.get('/settings/backup'),
  updateBackupSettings: (settings: any) => api.put('/settings/backup', settings),
  getEmailSettings: () => api.get('/settings/email'),
  updateEmailSettings: (settings: any) => api.put('/settings/email', settings),
  getLoggingLevels: () => api.get('/settings/logging-levels'),
  updateLoggingLevel: (level: string) => api.put('/settings/logging-level', { level }),
}

export const assignmentsAPI = {
  getAll: () => api.get('/assignments'),
  getJudges: () => api.get('/assignments/judges'),
  getCategories: () => api.get('/assignments/categories'),
  assignJudge: (judgeId: string, categoryId: string) => api.post('/assignments/judge', { judgeId, categoryId }),
  removeAssignment: (assignmentId: string) => api.delete(`/assignments/${assignmentId}`),
  delete: (id: string) => api.delete(`/assignments/${id}`),
  create: (data: any) => api.post('/assignments', data),
  update: (id: string, data: any) => api.put(`/assignments/${id}`, data),
}

export const auditorAPI = {
  getStats: () => api.get('/auditor/stats'),
  getPendingAudits: () => api.get('/auditor/pending'),
  getCompletedAudits: () => api.get('/auditor/completed'),
  finalCertification: (categoryIdOrData: string | any, data?: any) => {
    if (typeof categoryIdOrData === 'string') {
      // Called with (categoryId, data)
      return api.post(`/auditor/category/${categoryIdOrData}/final-certification`, data)
    } else {
      // Called with (data) - extract categoryId from data
      const { categoryId, ...certificationData } = categoryIdOrData
      return api.post(`/auditor/category/${categoryId}/final-certification`, certificationData)
    }
  },
  rejectAudit: (categoryId: string, reason: string) => api.post(`/auditor/category/${categoryId}/reject`, { reason }),
  finalizeCertification: (data: any) => api.post('/auditor/finalize-certification', data),
  // Backward compatibility method
  finalCertificationSimple: (data: any) => api.post('/auditor/finalize-certification', data),
}

export const boardAPI = {
  getStats: () => api.get('/board/stats'),
  getCertifications: () => api.get('/board/certifications'),
  approveCertification: (id: string) => api.post(`/board/certifications/${id}/approve`),
  rejectCertification: (id: string, reason: string) => api.post(`/board/certifications/${id}/reject`, { reason }),
  getCertificationStatus: () => api.get('/board/certification-status'),
  getEmceeScripts: () => api.get('/board/emcee-scripts'),
}

export const tallyMasterAPI = {
  getStats: () => api.get('/tally-master/stats'),
  getCertifications: () => api.get('/tally-master/certifications'),
  getCertificationQueue: () => api.get('/tally-master/queue'),
  getPendingCertifications: () => api.get('/tally-master/pending'),
  certifyTotals: (categoryIdOrData: string | any, data?: any) => {
    if (typeof categoryIdOrData === 'string') {
      // Called with (categoryId, data)
      return api.post(`/tally-master/category/${categoryIdOrData}/certify-totals`, data)
    } else {
      // Called with (data) - extract categoryId from data
      const { categoryId, ...totalsData } = categoryIdOrData
      return api.post(`/tally-master/category/${categoryId}/certify-totals`, totalsData)
    }
  },
  certifyTotalsData: (data: any) => api.post('/tally-master/certify-totals', data),
  // Backward compatibility method
  certifyTotalsSimple: (data: any) => api.post('/tally-master/certify-totals', data),
}

export const emailAPI = {
  getTemplates: () => api.get('/email/templates'),
  createTemplate: (data: any) => api.post('/email/templates', data),
  updateTemplate: (id: string, data: any) => api.put(`/email/templates/${id}`, data),
  deleteTemplate: (id: string) => api.delete(`/email/templates/${id}`),
  getCampaigns: () => api.get('/email/campaigns'),
  createCampaign: (data: any) => api.post('/email/campaigns', data),
  sendCampaign: (campaignId: string) => api.post(`/email/campaigns/${campaignId}/send`),
  getLogs: () => api.get('/email/logs'),
  sendMultiple: (data: { recipients: string[], subject: string, content: string }) => api.post('/email/send-multiple', data),
  sendByRole: (data: { roles: string[], subject: string, content: string }) => api.post('/email/send-by-role', data),
}

export const bulkImportAPI = {
  importUsers: (formData: FormData) => api.post('/bulk-import/users', formData, {
    headers: {
      'Content-Type': 'multipart/form-data',
    },
  }),
  downloadSample: () => api.get('/bulk-import/sample', { responseType: 'blob' }),
}

export const databaseBrowserAPI = {
  getTables: () => api.get('/database/tables'),
  getTableData: (tableName: string, page = 1, limit = 50, search = '') =>
    api.get(`/database/tables/${tableName}`, { params: { page, limit, search } }),
  getTableSchema: (tableName: string) => api.get(`/database/tables/${tableName}/schema`),
  insertRecord: (tableName: string, data: any) => api.post(`/database/tables/${tableName}`, data),
  updateRecord: (tableName: string, id: string, data: any) =>
    api.put(`/database/tables/${tableName}/${id}`, data),
  deleteRecord: (tableName: string, id: string) =>
    api.delete(`/database/tables/${tableName}/${id}`),
  executeQuery: (query: string) => api.post('/database/query', { query }),
  getTableStats: (tableName: string) => api.get(`/database/tables/${tableName}/stats`),
}

export const emceeScriptsAPI = {
  getAll: () => api.get('/emcee-scripts'),
  getById: (id: string) => api.get(`/emcee-scripts/${id}`),
  create: (data: any) => api.post('/emcee-scripts', data),
  update: (id: string, data: any) => api.put(`/emcee-scripts/${id}`, data),
  delete: (id: string) => api.delete(`/emcee-scripts/${id}`),
  getByEvent: (eventId: string) => api.get(`/emcee-scripts/event/${eventId}`),
  getByContest: (contestId: string) => api.get(`/emcee-scripts/contest/${contestId}`),
}

export const winnersAPI = {
  getWinners: (params?: { eventId?: string; contestId?: string; categoryId?: string }) =>
    api.get('/winners', { params }),
  getCertificationStatus: (categoryId: string) => api.get(`/winners/certification-status/${categoryId}`),
  certifyWinners: (categoryId: string, data: any) => api.post(`/winners/certify/${categoryId}`, data),
  getWinnerSignatures: (categoryId: string) => api.get(`/winners/signatures/${categoryId}`),
}

export const eventTemplatesAPI = {
  getAll: () => api.get('/event-templates'),
  getById: (id: string) => api.get(`/event-templates/${id}`),
  create: (data: any) => api.post('/event-templates', data),
  update: (id: string, data: any) => api.put(`/event-templates/${id}`, data),
  delete: (id: string) => api.delete(`/event-templates/${id}`),
  createEventFromTemplate: (templateId: string, eventData: any) => 
    api.post(`/event-templates/${templateId}/create-event`, eventData),
  getTemplates: (params?: any) => api.get('/event-templates', { params }),
  createTemplate: (data: any) => api.post('/event-templates', data),
  updateTemplate: (id: string, data: any) => api.put(`/event-templates/${id}`, data),
  deleteTemplate: (id: string) => api.delete(`/event-templates/${id}`),
}

export const reportsAPI = {
  getReports: (params?: { search?: string; type?: string; status?: string }) => 
    api.get('/reports', { params }),
  getTemplates: () => api.get('/reports/templates'),
  createReport: (data: any) => api.post('/reports', data),
  generateReport: (id: string) => api.post(`/reports/${id}/generate`),
  deleteReport: (id: string) => api.delete(`/reports/${id}`),
  emailReport: (reportId: string, data: { recipients: string; subject: string; message: string }) => 
    api.post(`/reports/${reportId}/email`, data),
  generatePDF: (data: any) => api.post('/reports/generate-pdf', data),
  generateImage: (data: any) => api.post('/reports/generate-image', data),
  generateCSV: (data: any) => api.post('/reports/generate-csv', data),
  generateXML: (data: any) => api.post('/reports/generate-xml', data),
  generateExcel: (data: any) => api.post('/reports/generate-excel', data),
  delete: (id: string) => api.delete(`/reports/${id}`),
}

// Export the api instance for direct use
export { api }
export default api
APIEOF
    
    # Verify frontend environment variables exist
    if [ ! -f ".env" ]; then
        print_error "Frontend .env file not found! Creating default environment..."
        cat > ".env" << EOF
# Frontend Environment Configuration
VITE_API_URL=
VITE_WS_URL=
VITE_APP_NAME=Event Manager
VITE_APP_VERSION=1.0.0
VITE_APP_URL=$APP_URL
EOF
    fi
    
    # Verify VITE variables are present
    if ! grep -q "VITE_API_URL" .env; then
        print_error "VITE_API_URL not found in frontend .env! Adding missing variables..."
        echo "VITE_API_URL=" >> .env
        echo "VITE_WS_URL=" >> .env
    fi
    
    print_status "Frontend environment variables:"
    cat .env | grep VITE_ | sed 's/^/  /'
    
    # Clean previous build to ensure fresh build with new environment
    print_status "Cleaning previous build artifacts..."
    rm -rf dist
    rm -rf node_modules/.vite
    rm -rf node_modules/.cache
    
    # Clear npm cache to ensure fresh dependencies
    print_status "Clearing npm cache..."
    npm cache clean --force
    
    # Create Vite environment types file
    print_status "Creating Vite environment types..."
    cat > "$APP_DIR/frontend/src/vite-env.d.ts" << 'EOF'
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_API_URL: string
  readonly VITE_WS_URL: string
  readonly VITE_APP_NAME: string
  readonly VITE_APP_VERSION: string
  readonly VITE_APP_URL: string
}

interface ImportMeta {
  readonly env: ImportMetaEnv
}
EOF
    
    # Create TypeScript configuration (force overwrite to ensure correct content)                                                                               
    print_status "Creating TypeScript configuration..."
    cat > "$APP_DIR/frontend/tsconfig.json" << 'EOF'
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "strict": false,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noFallthroughCasesInSwitch": true,
    "noImplicitAny": false,
    "noImplicitReturns": false,
    "noImplicitThis": false,
    "strictNullChecks": false,
    "strictFunctionTypes": false,
    "strictBindCallApply": false,
    "strictPropertyInitialization": false,
    "noImplicitOverride": false,
    "allowUnusedLabels": true,
    "allowUnreachableCode": true,
    "exactOptionalPropertyTypes": false,
    "noPropertyAccessFromIndexSignature": false,
    "noUncheckedIndexedAccess": false
  },
  "include": ["src"],
  "references": [{ "path": "./tsconfig.node.json" }]
}
EOF
    
    # Create TypeScript node configuration (force overwrite to ensure correct content)
    print_status "Creating TypeScript node configuration..."
    cat > "$APP_DIR/frontend/tsconfig.node.json" << 'EOF'
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true
  },
  "include": ["vite.config.ts"]
}
EOF
    
    # Create Vite configuration (force overwrite to ensure correct content)
    print_status "Creating Vite configuration..."
    cat > "$APP_DIR/frontend/vite.config.ts" << 'EOF'
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  server: {
    port: 3001,
    host: true
  },
  build: {
    outDir: 'dist',
    sourcemap: false
  }
})
EOF
    
    # Create complete React app structure with comprehensive functionality (force overwrite to ensure correct content)
    print_status "Creating comprehensive React app structure..."
    mkdir -p "$APP_DIR/frontend/src/components"
    mkdir -p "$APP_DIR/frontend/src/contexts"
    mkdir -p "$APP_DIR/frontend/src/pages"
    mkdir -p "$APP_DIR/frontend/src/services"
    mkdir -p "$APP_DIR/frontend/src/hooks"
    mkdir -p "$APP_DIR/frontend/src/utils"
    
    # Create frontend package.json with React 18 compatible dependencies
    print_status "Creating frontend package.json with React 18 compatible dependencies..."
    cat > "$APP_DIR/frontend/package.json" << 'EOF'
{
  "name": "event-manager-frontend",
  "private": true,
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-router-dom": "^6.8.1",
    "react-query": "^3.39.3",
    "axios": "^1.6.2",
    "socket.io-client": "^4.7.4",
    "@heroicons/react": "^2.1.1",
    "date-fns": "^2.30.0",
    "clsx": "^2.0.0",
    "tailwind-merge": "^2.0.0"
  },
  "devDependencies": {
    "@types/react": "^18.2.43",
    "@types/react-dom": "^18.2.17",
    "@typescript-eslint/eslint-plugin": "^6.14.0",
    "@typescript-eslint/parser": "^6.14.0",
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.16",
    "eslint": "^8.55.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.5",
    "postcss": "^8.4.32",
    "tailwindcss": "^3.3.6",
    "typescript": "^5.2.2",
    "vite": "^5.0.8"
  }
}
EOF
    
    # Create Tailwind CSS configuration
    print_status "Creating Tailwind CSS configuration..."
    cat > "$APP_DIR/frontend/tailwind.config.js" << 'EOF'
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
EOF
    
    # Create PostCSS configuration
    cat > "$APP_DIR/frontend/postcss.config.js" << 'EOF'
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
EOF
    
    cat > "$APP_DIR/frontend/src/main.tsx" << 'EOF'
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
)
EOF

    cat > "$APP_DIR/frontend/src/vite-env.d.ts" << 'EOF'
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_API_URL: string
  readonly VITE_WS_URL: string
}

interface ImportMeta {
  readonly env: ImportMetaEnv
}
EOF
    
    cat > "$APP_DIR/frontend/src/contexts/AuthContext.tsx" << 'EOF'
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react'
import { useNavigate } from 'react-router-dom'
import { api } from '../services/api'

interface User {
  id: string
  name: string
  preferredName?: string
  email: string
  role: string
  judge?: any
  contestant?: any
}

interface AuthContextType {
  user: User | null
  login: (email: string, password: string) => Promise<void>
  logout: () => void
  isLoading: boolean
  isAuthenticated: boolean
}

const AuthContext = createContext<AuthContextType | undefined>(undefined)

export const useAuth = () => {
  const context = useContext(AuthContext)
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider')
  }
  return context
}

interface AuthProviderProps {
  children: ReactNode
}

export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const navigate = useNavigate()

  const isAuthenticated = !!user

  useEffect(() => {
    const initAuth = async () => {
      const token = localStorage.getItem('token')
      if (token) {
        try {
          api.defaults.headers.common['Authorization'] = `Bearer ${token}`
          const response = await api.get('/auth/profile')
          setUser(response.data)
        } catch (error) {
          localStorage.removeItem('token')
          delete api.defaults.headers.common['Authorization']
        }
      }
      setIsLoading(false)
    }

    initAuth()
  }, [])

  // Handle redirects based on authentication state
  useEffect(() => {
    if (!isLoading) {
      if (isAuthenticated && window.location.pathname === '/login') {
        navigate('/dashboard')
      } else if (!isAuthenticated && window.location.pathname !== '/login') {
        navigate('/login')
      }
    }
  }, [isAuthenticated, isLoading, navigate])

  const login = async (email: string, password: string) => {
    try {
      const response = await api.post('/auth/login', { email, password })
      const { token, user: userData } = response.data
      
      localStorage.setItem('token', token)
      api.defaults.headers.common['Authorization'] = `Bearer ${token}`
      setUser(userData)
    } catch (error: any) {
      throw new Error(error.response?.data?.error || 'Login failed')
    }
  }

  const logout = () => {
    localStorage.removeItem('token')
    delete api.defaults.headers.common['Authorization']
    setUser(null)
  }

  const value = {
    user,
    login,
    logout,
    isLoading,
    isAuthenticated
  }

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  )
}
EOF

    cat > "$APP_DIR/frontend/src/contexts/SocketContext.tsx" << 'EOF'
import React, { createContext, useContext, useEffect, useState, ReactNode } from 'react'
import { io, Socket } from 'socket.io-client'
import { useAuth } from './AuthContext'

interface ActiveUser {
  id: string
  name: string
  role: string
  lastSeen: string
  isOnline: boolean
}

interface NotificationData {
  id: string
  type: 'SCORE_UPDATE' | 'CERTIFICATION' | 'SYSTEM' | 'EVENT'
  title: string
  message: string
  timestamp: string
  read: boolean
  userId: string
}

interface SocketContextType {
  socket: Socket | null
  isConnected: boolean
  activeUsers: ActiveUser[]
  notifications: NotificationData[]
  emit: (event: string, data?: any) => void
  on: (event: string, callback: (data: any) => void) => void
  off: (event: string, callback?: (data: any) => void) => void
  joinRoom: (room: string) => void
  leaveRoom: (room: string) => void
  markNotificationRead: (notificationId: string) => void
  clearNotifications: () => void
}

const SocketContext = createContext<SocketContextType | undefined>(undefined)

export const useSocket = () => {
  const context = useContext(SocketContext)
  if (context === undefined) {
    throw new Error('useSocket must be used within a SocketProvider')
  }
  return context
}

interface SocketProviderProps {
  children: ReactNode
}

export const SocketProvider: React.FC<SocketProviderProps> = ({ children }) => {
  const [socket, setSocket] = useState<Socket | null>(null)
  const [isConnected, setIsConnected] = useState(false)
  const [activeUsers, setActiveUsers] = useState<ActiveUser[]>([])
  const [notifications, setNotifications] = useState<NotificationData[]>([])
  const { user } = useAuth()

  useEffect(() => {
    if (user) {
      const newSocket = io(import.meta.env.VITE_WS_URL || window.location.origin, {
        auth: {
          token: localStorage.getItem('token')
        }
      })

      newSocket.on('connect', () => {
        setIsConnected(true)
      })

      newSocket.on('disconnect', () => {
        setIsConnected(false)
      })

      newSocket.on('activeUsers', (users: ActiveUser[]) => {
        setActiveUsers(users)
      })

      newSocket.on('notification', (notification: NotificationData) => {
        setNotifications(prev => [notification, ...prev])
      })

      setSocket(newSocket)

      return () => {
        newSocket.close()
      }
    }
  }, [user])

  const emit = (event: string, data?: any) => {
    if (socket) {
      socket.emit(event, data)
    }
  }

  const on = (event: string, callback: (data: any) => void) => {
    if (socket) {
      socket.on(event, callback)
    }
  }

  const off = (event: string, callback?: (data: any) => void) => {
    if (socket) {
      socket.off(event, callback)
    }
  }

  const joinRoom = (room: string) => {
    if (socket) {
      socket.emit('joinRoom', room)
    }
  }

  const leaveRoom = (room: string) => {
    if (socket) {
      socket.emit('leaveRoom', room)
    }
  }

  const markNotificationRead = (notificationId: string) => {
    setNotifications(prev => 
      prev.map(notification => 
        notification.id === notificationId 
          ? { ...notification, read: true }
          : notification
      )
    )
  }

  const clearNotifications = () => {
    setNotifications([])
  }

  const value = {
    socket,
    isConnected,
    activeUsers,
    notifications,
    emit,
    on,
    off,
    joinRoom,
    leaveRoom,
    markNotificationRead,
    clearNotifications
  }

  return (
    <SocketContext.Provider value={value}>
      {children}
    </SocketContext.Provider>
  )
}
EOF

    cat > "$APP_DIR/frontend/src/contexts/ThemeContext.tsx" << 'EOF'
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react'

export type Theme = 'light' | 'dark' | 'system'

interface ThemeContextType {
  theme: Theme
  actualTheme: 'light' | 'dark'
  setTheme: (theme: Theme) => void
}

const ThemeContext = createContext<ThemeContextType | undefined>(undefined)

export const useTheme = () => {
  const context = useContext(ThemeContext)
  if (context === undefined) {
    throw new Error('useTheme must be used within a ThemeProvider')
  }
  return context
}

interface ThemeProviderProps {
  children: ReactNode
}

export const ThemeProvider: React.FC<ThemeProviderProps> = ({ children }) => {
  const [theme, setTheme] = useState<Theme>(() => {
    const saved = localStorage.getItem('theme')
    return (saved as Theme) || 'system'
  })

  const [actualTheme, setActualTheme] = useState<'light' | 'dark'>('light')

  useEffect(() => {
    const updateActualTheme = () => {
      if (theme === 'system') {
        const systemPrefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches
        setActualTheme(systemPrefersDark ? 'dark' : 'light')
      } else {
        setActualTheme(theme)
      }
    }

    updateActualTheme()
    localStorage.setItem('theme', theme)

    if (theme === 'system') {
      const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)')
      mediaQuery.addEventListener('change', updateActualTheme)
      return () => mediaQuery.removeEventListener('change', updateActualTheme)
    }
  }, [theme])

  useEffect(() => {
    const root = document.documentElement
    if (actualTheme === 'dark') {
      root.classList.add('dark')
    } else {
      root.classList.remove('dark')
    }
  }, [actualTheme])

  const value = {
    theme,
    actualTheme,
    setTheme
  }

  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  )
}
EOF

    # Create utility functions file
    print_status "Creating utility functions..."
    cat > "$APP_DIR/frontend/src/utils/helpers.ts" << 'EOF'
// Utility functions for the application

export const getSeverityColor = (severity: string) => {
  switch (severity.toLowerCase()) {
    case 'error':
      return 'badge-destructive'
    case 'warning':
      return 'badge-warning'
    case 'info':
      return 'badge-info'
    case 'success':
      return 'badge-success'
    default:
      return 'badge-secondary'
  }
}

export const getStatusColor = (status: string) => {
  switch (status.toLowerCase()) {
    case 'pending':
      return 'badge-warning'
    case 'in_progress':
      return 'badge-info'
    case 'certified':
    case 'approved':
    case 'completed':
      return 'badge-success'
    case 'rejected':
    case 'failed':
      return 'badge-destructive'
    case 'active':
      return 'badge-success'
    case 'inactive':
      return 'badge-secondary'
    default:
      return 'badge-secondary'
  }
}

export const getStepIcon = (stepStatus: string) => {
  switch (stepStatus.toLowerCase()) {
    case 'pending':
      return ''
    case 'in_progress':
      return ''
    case 'completed':
      return ''
    case 'failed':
      return ''
    default:
      return ''
  }
}

export const getCategoryIcon = (type: string) => {
  switch (type.toLowerCase()) {
    case 'performance':
      return ''
    case 'talent':
      return ''
    case 'interview':
      return ''
    case 'presentation':
      return ''
    case 'creative':
      return ''
    default:
      return ''
  }
}

export const getCategoryColor = (type: string) => {
  switch (type.toLowerCase()) {
    case 'performance':
      return 'badge-purple'
    case 'talent':
      return 'badge-yellow'
    case 'interview':
      return 'badge-blue'
    case 'presentation':
      return 'badge-green'
    case 'creative':
      return 'badge-pink'
    default:
      return 'badge-secondary'
  }
}

export const getTypeIcon = (type: string) => {
  switch (type.toLowerCase()) {
    case 'announcement':
      return ''
    case 'introduction':
      return ''
    case 'transition':
      return ''
    case 'closing':
      return ''
    case 'award':
      return ''
    case 'break':
      return ''
    default:
      return ''
  }
}

export const getTypeColor = (type: string) => {
  switch (type.toLowerCase()) {
    case 'announcement':
      return 'badge-blue'
    case 'introduction':
      return 'badge-green'
    case 'transition':
      return 'badge-yellow'
    case 'closing':
      return 'badge-purple'
    case 'award':
      return 'badge-gold'
    case 'break':
      return 'badge-gray'
    default:
      return 'badge-secondary'
  }
}

export const getTypeText = (type: string) => {
  switch (type.toLowerCase()) {
    case 'announcement':
      return 'Announcement'
    case 'introduction':
      return 'Introduction'
    case 'transition':
      return 'Transition'
    case 'closing':
      return 'Closing'
    case 'award':
      return 'Award'
    case 'break':
      return 'Break'
    default:
      return 'General'
  }
}

export const getFileIcon = (mimeType: string) => {
  if (mimeType.startsWith('image/')) return ''
  if (mimeType.startsWith('video/')) return ''
  if (mimeType.startsWith('audio/')) return ''
  if (mimeType.includes('pdf')) return ''
  if (mimeType.includes('word')) return ''
  if (mimeType.includes('excel') || mimeType.includes('spreadsheet')) return ''
  if (mimeType.includes('powerpoint') || mimeType.includes('presentation')) return ''
  if (mimeType.includes('zip') || mimeType.includes('rar')) return ''
  return ''
}

export const formatFileSize = (bytes: number) => {
  if (bytes === 0) return '0 Bytes'
  const k = 1024
  const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i]
}

export const getStatusText = (status: string) => {
  switch (status.toLowerCase()) {
    case 'pending':
      return 'Pending'
    case 'in_progress':
      return 'In Progress'
    case 'sent':
      return 'Sent'
    case 'delivered':
      return 'Delivered'
    case 'failed':
      return 'Failed'
    case 'draft':
      return 'Draft'
    case 'scheduled':
      return 'Scheduled'
    default:
      return status.charAt(0).toUpperCase() + status.slice(1)
  }
}
EOF
    
    cat > "$APP_DIR/frontend/src/components/Layout.tsx" << 'EOF'
import React, { useState, useEffect, useRef } from 'react'
import { Link, useLocation } from 'react-router-dom'
import { useAuth } from '../contexts/AuthContext'
import { useSocket } from '../contexts/SocketContext'
import { useTheme } from '../contexts/ThemeContext'
import {
  HomeIcon,
  CalendarIcon,
  TrophyIcon,
  ChartBarIcon,
  UsersIcon,
  CogIcon,
  MicrophoneIcon,
  DocumentTextIcon,
  XMarkIcon,
  PencilSquareIcon,
  ArrowDownTrayIcon,
  CalculatorIcon
} from '@heroicons/react/24/outline'

interface LayoutProps {
  children: React.ReactNode
}

const Layout: React.FC<LayoutProps> = ({ children }) => {
  const [sidebarOpen, setSidebarOpen] = useState(false)
  const [profileMenuOpen, setProfileMenuOpen] = useState(false)
  const [userMenuOpen, setUserMenuOpen] = useState(false)
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false)
  const { user, logout } = useAuth()
  const { theme, setTheme, actualTheme } = useTheme()
  const { isConnected } = useSocket()
  const location = useLocation()
  const userMenuRef = useRef<HTMLDivElement>(null)

  // Close user menu when clicking outside
  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (userMenuRef.current && !userMenuRef.current.contains(event.target as Node)) {
        setUserMenuOpen(false)
      }
    }

    if (userMenuOpen) {
      document.addEventListener('mousedown', handleClickOutside)
    }

    return () => {
      document.removeEventListener('mousedown', handleClickOutside)
    }
  }, [userMenuOpen])

  const navigation = [
    { name: 'Dashboard', href: '/dashboard', icon: HomeIcon, roles: ['ORGANIZER', 'JUDGE', 'CONTESTANT', 'EMCEE', 'TALLY_MASTER', 'AUDITOR', 'BOARD'] },
    { name: 'Events', href: '/events', icon: CalendarIcon, roles: ['ORGANIZER', 'BOARD'] },
    { name: 'Scoring', href: '/scoring', icon: TrophyIcon, roles: ['JUDGE'] },
    { name: 'Results', href: '/results', icon: ChartBarIcon, roles: ['ORGANIZER', 'JUDGE', 'CONTESTANT', 'TALLY_MASTER', 'AUDITOR', 'BOARD'] },
    { name: 'Users', href: '/users', icon: UsersIcon, roles: ['ORGANIZER', 'BOARD'] },
    { name: 'Admin', href: '/admin', icon: CogIcon, roles: ['ORGANIZER', 'BOARD'] },
    { name: 'Emcee', href: '/emcee', icon: MicrophoneIcon, roles: ['EMCEE'] },
    { name: 'Templates', href: '/templates', icon: DocumentTextIcon, roles: ['ORGANIZER', 'BOARD'] },
    { name: 'Reports', href: '/reports', icon: ChartBarIcon, roles: ['ORGANIZER', 'BOARD'] },
    { name: 'Winners', href: '/winners', icon: TrophyIcon, roles: ['ADMIN', 'BOARD', 'EMCEE'] },
  ]

  const filteredNavigation = navigation.filter(item => 
    item.roles.includes(user?.role || '')
  )

  const getRoleColor = (role: string) => {
    const colors = {
      ORGANIZER: 'role-organizer',
      JUDGE: 'role-judge',
      CONTESTANT: 'role-contestant',
      EMCEE: 'role-emcee',
      TALLY_MASTER: 'role-tally-master',
      AUDITOR: 'role-auditor',
      BOARD: 'role-board',
    }
    return colors[role as keyof typeof colors] || 'role-board'
  }

  const getRoleDisplayName = (role: string) => {
    const names = {
      ORGANIZER: 'Organizer',
      JUDGE: 'Judge',
      CONTESTANT: 'Contestant',
      EMCEE: 'Emcee',
      TALLY_MASTER: 'Tally Master',
      AUDITOR: 'Auditor',
      BOARD: 'Board',
    }
    return names[role] || role
  }

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-900 flex">
      {/* Mobile sidebar */}
      <div className={`mobile-menu ${sidebarOpen ? 'block' : 'hidden'}`}>
        <div className="mobile-menu-overlay" onClick={() => setSidebarOpen(false)} />
        <div className="mobile-menu-content">
          <div className="flex items-center justify-between p-4 border-b">
            <h2 className="text-lg font-semibold">Event Manager</h2>
            <button
              onClick={() => setSidebarOpen(false)}
              className="btn btn-ghost btn-sm"
            >
              <XMarkIcon className="h-5 w-5" />
            </button>
          </div>
          <nav className="p-4 space-y-2">
            {filteredNavigation.map((item) => {
              const isActive = location.pathname === item.href
              return (
                <Link
                  key={item.name}
                  to={item.href}
                  className={`sidebar-nav-item ${isActive ? 'sidebar-nav-item-active' : ''}`}
                  onClick={() => setSidebarOpen(false)}
                >
                  <item.icon className="h-5 w-5 mr-3" />
                  {item.name}
                </Link>
              )
            })}
          </nav>
        </div>
      </div>

      {/* Desktop sidebar */}
      <div className="hidden lg:flex lg:flex-shrink-0">
        <div className="flex flex-col w-64">
          <div className="flex flex-col h-0 flex-1 bg-white dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700">
            <div className="flex-1 flex flex-col pt-5 pb-4 overflow-y-auto">
              <div className="flex items-center flex-shrink-0 px-4">
                <h1 className="text-xl font-bold text-gray-900 dark:text-white">Event Manager</h1>
              </div>
              <nav className="mt-5 flex-1 px-2 space-y-1">
                {filteredNavigation.map((item) => {
                  const isActive = location.pathname === item.href
                  return (
                    <Link
                      key={item.name}
                      to={item.href}
                      className={`${
                        isActive
                          ? 'bg-gray-100 dark:bg-gray-700 text-gray-900 dark:text-white'
                          : 'text-gray-600 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700 hover:text-gray-900 dark:hover:text-white'
                      } group flex items-center px-2 py-2 text-sm font-medium rounded-md`}
                    >
                      <item.icon className="h-5 w-5 mr-3" />
                      {item.name}
                    </Link>
                  )
                })}
              </nav>
            </div>
          </div>
        </div>
      </div>

      {/* Main content */}
      <div className="flex flex-col flex-1 min-w-0">
        {/* Top navigation */}
        <div className="sticky top-0 z-10 flex-shrink-0 flex h-16 bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700">
          <button
            type="button"
            className="px-4 border-r border-gray-200 dark:border-gray-700 text-gray-500 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-indigo-500 lg:hidden"
            onClick={() => setSidebarOpen(true)}
          >
            <span className="sr-only">Open sidebar</span>
            <svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6h16M4 12h16M4 18h7" />
            </svg>
          </button>
          <div className="flex-1 px-4 flex justify-between">
            <div className="flex-1 flex">
              <div className="w-full flex md:ml-0">
                <div className="relative w-full text-gray-400 focus-within:text-gray-600 dark:focus-within:text-gray-300">
                  <div className="absolute inset-y-0 left-0 flex items-center pointer-events-none">
                    <svg className="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                    </svg>
                  </div>
                  <input
                    className="block w-full h-full pl-8 pr-3 py-2 border-transparent text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:outline-none focus:placeholder-gray-400 dark:focus:placeholder-gray-500 focus:ring-0 focus:border-transparent sm:text-sm bg-transparent"
                    placeholder="Search..."
                    type="search"
                  />
                </div>
              </div>
            </div>
            <div className="ml-4 flex items-center md:ml-6">
              {/* Theme toggle */}
              <div className="relative">
                <button
                  onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}
                  className="p-2 text-gray-400 hover:text-gray-500 dark:hover:text-gray-300"
                >
                  {theme === 'light' ? '' : ''}
                </button>
              </div>

              {/* Notifications */}
              <button className="p-2 text-gray-400 hover:text-gray-500 dark:hover:text-gray-300">
                <span className="sr-only">View notifications</span>
                <svg className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 17h5l-5 5v-5zM9 7H4l5-5v5z" />
                </svg>
              </button>

              {/* Socket status */}
              <div className="flex items-center ml-2">
                <div className={`w-2 h-2 rounded-full ${isConnected ? 'bg-green-400' : 'bg-red-400'}`} />
                <span className="ml-1 text-xs text-gray-500 dark:text-gray-400">
                  {isConnected ? 'Connected' : 'Disconnected'}
                </span>
              </div>

              {/* Profile dropdown */}
              <div className="ml-3 relative" ref={userMenuRef}>
                <div>
                  <button
                    type="button"
                    className="max-w-xs bg-white dark:bg-gray-800 flex items-center text-sm rounded-full focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                    onClick={() => setUserMenuOpen(!userMenuOpen)}
                  >
                    <span className="sr-only">Open user menu</span>
                    <div className={`h-8 w-8 rounded-full flex items-center justify-center text-white text-sm font-medium ${getRoleColor(user?.role || '')}`}>
                      {user?.name?.charAt(0).toUpperCase()}
                    </div>
                  </button>
                </div>
                {userMenuOpen && (
                  <div className="origin-top-right absolute right-0 mt-2 w-48 rounded-md shadow-lg py-1 bg-white dark:bg-gray-800 ring-1 ring-black ring-opacity-5 focus:outline-none">
                    <div className="px-4 py-2 text-sm text-gray-700 dark:text-gray-300 border-b border-gray-200 dark:border-gray-700">
                      <div className="font-medium">{user?.name}</div>
                      <div className="text-xs text-gray-500 dark:text-gray-400">{getRoleDisplayName(user?.role || '')}</div>
                    </div>
                    <Link
                      to="/profile"
                      onClick={() => setUserMenuOpen(false)}
                      className="block px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700"
                    >
                      Your Profile
                    </Link>
                    <button
                      onClick={() => {
                        setUserMenuOpen(false)
                        logout()
                      }}
                      className="block w-full text-left px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700"
                    >
                      Sign out
                    </button>
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>

        {/* Page content */}
        <main className="flex-1">
          <div className="py-6">
            <div className="max-w-7xl mx-auto px-4 sm:px-6 md:px-8">
              {children}
            </div>
          </div>
        </main>
      </div>
    </div>
  )
}

export default Layout
EOF

    cat > "$APP_DIR/frontend/src/components/ProtectedRoute.tsx" << 'EOF'
import React from 'react'
import { Navigate } from 'react-router-dom'
import { useAuth } from '../contexts/AuthContext'

interface ProtectedRouteProps {
  children: React.ReactNode
}

const ProtectedRoute: React.FC<ProtectedRouteProps> = ({ children }) => {
  const { isAuthenticated, isLoading } = useAuth()

  if (isLoading) {
    return (
      <div className="min-h-screen bg-gray-50 dark:bg-gray-900 flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin rounded-full h-32 w-32 border-b-2 border-indigo-600 mx-auto"></div>
          <p className="mt-4 text-gray-600 dark:text-gray-400">Loading...</p>
        </div>
      </div>
    )
  }

  return isAuthenticated ? <>{children}</> : <Navigate to="/login" replace />
}

export default ProtectedRoute
EOF

    cat > "$APP_DIR/frontend/src/components/ErrorBoundary.tsx" << 'EOF'
import React, { Component, ErrorInfo, ReactNode } from 'react'

interface Props {
  children: ReactNode
}

interface State {
  hasError: boolean
  error?: Error
}

class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false
  }

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error }
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Uncaught error:', error, errorInfo)
  }

  public render() {
    if (this.state.hasError) {
      return (
        <div className="min-h-screen bg-gray-50 dark:bg-gray-900 flex items-center justify-center">
          <div className="max-w-md w-full bg-white dark:bg-gray-800 shadow-lg rounded-lg p-6">
            <div className="flex items-center justify-center w-12 h-12 mx-auto bg-red-100 dark:bg-red-900 rounded-full">
              <svg className="w-6 h-6 text-red-600 dark:text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L3.732 16.5c-.77.833.192 2.5 1.732 2.5z" />
              </svg>
            </div>
            <div className="mt-4 text-center">
              <h3 className="text-lg font-medium text-gray-900 dark:text-white">
                Something went wrong
              </h3>
              <div className="mt-2">
                <p className="text-sm text-gray-500 dark:text-gray-400">
                  We're sorry, but something unexpected happened. Please try refreshing the page.
                </p>
              </div>
              {process.env.NODE_ENV === 'development' && this.state.error && (
                <div className="mt-4 p-4 bg-gray-100 dark:bg-gray-700 rounded-md">
                  <p className="text-xs text-gray-600 dark:text-gray-300 font-mono">
                    {this.state.error.message}
                  </p>
                </div>
              )}
              <div className="mt-6 flex space-x-3 justify-center">
                <button
                  onClick={() => window.location.reload()}
                  className="inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                >
                  Refresh Page
                </button>
                <button
                  onClick={() => window.location.href = '/'}
                  className="inline-flex items-center px-4 py-2 border border-gray-300 dark:border-gray-600 text-sm font-medium rounded-md text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-800 hover:bg-gray-50 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500"
                >
                  Go Home
                </button>
              </div>
            </div>
          </div>
        </div>
      )
    }

    return this.props.children
  }
}

export default ErrorBoundary
EOF

    # Clear TypeScript build cache to ensure fresh compilation
    print_status "Clearing TypeScript build cache..."
    rm -f "$APP_DIR/frontend/tsconfig.tsbuildinfo"
    rm -rf "$APP_DIR/frontend/node_modules/.cache"
    
    # Force overwrite API service to ensure getAll() method is available
    print_status "Force overwriting API service with getAll() method..."
    
    # Fix Heroicons imports first
    print_status "Fixing Heroicons imports..."
    # Components are now generated with correct imports - no fixes needed
    
    # Force overwrite components that were causing TypeScript errors
    print_status "Force overwriting components with correct API usage..."
    
    cat > "$APP_DIR/frontend/src/components/EmailManager.tsx" << 'EOF'
import React, { useState } from 'react'
import { useQuery, useMutation, useQueryClient } from 'react-query'
import { eventsAPI, contestsAPI } from '../services/api'
import { EnvelopeIcon, PlusIcon, PencilIcon, TrashIcon } from '@heroicons/react/24/outline'

const EmailManager: React.FC = () => {
  const [activeTab, setActiveTab] = useState('compose')
  const queryClient = useQueryClient()

  // Get events and contests for email composition
  const { data: events } = useQuery('events', () => eventsAPI.getAll().then((res: any) => res.data))
  const { data: contests } = useQuery('contests', () => contestsAPI.getAll().then((res: any) => res.data))

  const tabs = [
    { id: 'compose', name: 'Compose', icon: EnvelopeIcon },
    { id: 'templates', name: 'Templates', icon: PlusIcon },
    { id: 'campaigns', name: 'Campaigns', icon: PencilIcon },
    { id: 'logs', name: 'Logs', icon: TrashIcon },
  ]

  return (
    <div className="space-y-6">
      <div className="card">
        <div className="card-header">
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Email Manager</h1>
          <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
            Manage email communications and campaigns
          </p>
        </div>
        <div className="card-body">
          <div className="border-b border-gray-200 dark:border-gray-700">
            <nav className="-mb-px flex space-x-8">
              {tabs.map((tab) => (
                <button
                  key={tab.id}
                  onClick={() => setActiveTab(tab.id)}
                  className={`${
                    activeTab === tab.id
                      ? 'border-blue-500 text-blue-600'
                      : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                  } whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm flex items-center`}
                >
                  <tab.icon className="h-5 w-5 mr-2" />
                  {tab.name}
                </button>
              ))}
            </nav>
          </div>

          <div className="mt-6">
            {activeTab === 'compose' && (
              <div className="text-center py-12">
                <EnvelopeIcon className="h-12 w-12 text-gray-400 mx-auto mb-4" />
                <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">Compose Email</h3>
                <p className="text-gray-600 dark:text-gray-400">Email composition functionality will be implemented here</p>
              </div>
            )}
            {activeTab === 'templates' && (
              <div className="text-center py-12">
                <PlusIcon className="h-12 w-12 text-gray-400 mx-auto mb-4" />
                <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">Email Templates</h3>
                <p className="text-gray-600 dark:text-gray-400">Template management functionality will be implemented here</p>
              </div>
            )}
            {activeTab === 'campaigns' && (
              <div className="text-center py-12">
                <PencilIcon className="h-12 w-12 text-gray-400 mx-auto mb-4" />
                <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">Email Campaigns</h3>
                <p className="text-gray-600 dark:text-gray-400">Campaign management functionality will be implemented here</p>
              </div>
            )}
            {activeTab === 'logs' && (
              <div className="text-center py-12">
                <TrashIcon className="h-12 w-12 text-gray-400 mx-auto mb-4" />
                <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">Email Logs</h3>
                <p className="text-gray-600 dark:text-gray-400">Email logging functionality will be implemented here</p>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  )
}

export default EmailManager
EOF

    cat > "$APP_DIR/frontend/src/components/EmceeScripts.tsx" << 'EOF'
import React, { useState } from 'react'
import { useQuery, useMutation, useQueryClient } from 'react-query'
import { eventsAPI, contestsAPI } from '../services/api'
import { DocumentTextIcon, PlusIcon, PencilIcon, TrashIcon } from '@heroicons/react/24/outline'

const EmceeScripts: React.FC = () => {
  const [activeTab, setActiveTab] = useState('browse')
  const queryClient = useQueryClient()

  // Get events and contests for script management
  const { data: events } = useQuery('events', () => eventsAPI.getAll().then((res: any) => res.data))
  const { data: contests } = useQuery('contests', () => contestsAPI.getAll().then((res: any) => res.data))

  const tabs = [
    { id: 'browse', name: 'Browse Scripts', icon: DocumentTextIcon },
    { id: 'create', name: 'Create Script', icon: PlusIcon },
    { id: 'manage', name: 'Manage Scripts', icon: PencilIcon },
    { id: 'practice', name: 'Practice Mode', icon: TrashIcon },
  ]

  return (
    <div className="space-y-6">
      <div className="card">
        <div className="card-header">
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Emcee Scripts</h1>
          <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
            Manage scripts for event announcements and presentations
          </p>
        </div>
        <div className="card-body">
          <div className="border-b border-gray-200 dark:border-gray-700">
            <nav className="-mb-px flex space-x-8">
              {tabs.map((tab) => (
                <button
                  key={tab.id}
                  onClick={() => setActiveTab(tab.id)}
                  className={`${
                    activeTab === tab.id
                      ? 'border-blue-500 text-blue-600'
                      : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                  } whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm flex items-center`}
                >
                  <tab.icon className="h-5 w-5 mr-2" />
                  {tab.name}
                </button>
              ))}
            </nav>
          </div>

          <div className="mt-6">
            {activeTab === 'browse' && (
              <div className="text-center py-12">
                <DocumentTextIcon className="h-12 w-12 text-gray-400 mx-auto mb-4" />
                <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">Browse Scripts</h3>
                <p className="text-gray-600 dark:text-gray-400">Script browsing functionality will be implemented here</p>
              </div>
            )}
            {activeTab === 'create' && (
              <div className="text-center py-12">
                <PlusIcon className="h-12 w-12 text-gray-400 mx-auto mb-4" />
                <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">Create Script</h3>
                <p className="text-gray-600 dark:text-gray-400">Script creation functionality will be implemented here</p>
              </div>
            )}
            {activeTab === 'manage' && (
              <div className="text-center py-12">
                <PencilIcon className="h-12 w-12 text-gray-400 mx-auto mb-4" />
                <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">Manage Scripts</h3>
                <p className="text-gray-600 dark:text-gray-400">Script management functionality will be implemented here</p>
              </div>
            )}
            {activeTab === 'practice' && (
              <div className="text-center py-12">
                <TrashIcon className="h-12 w-12 text-gray-400 mx-auto mb-4" />
                <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">Practice Mode</h3>
                <p className="text-gray-600 dark:text-gray-400">Practice mode functionality will be implemented here</p>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  )
}

export default EmceeScripts
EOF

    cat > "$APP_DIR/frontend/src/components/PrintReports.tsx" << 'EOF'
import React, { useState } from 'react'
import { useQuery } from 'react-query'
import { eventsAPI, contestsAPI } from '../services/api'
import { DocumentIcon, PrinterIcon, ArrowDownTrayIcon } from '@heroicons/react/24/outline'

const PrintReports: React.FC = () => {
  const [activeTab, setActiveTab] = useState('generate')

  // Get events and contests for report generation
  const { data: events } = useQuery('events', () => eventsAPI.getAll().then((res: any) => res.data))
  const { data: contests } = useQuery('contests', () => contestsAPI.getAll().then((res: any) => res.data))

  const tabs = [
    { id: 'generate', name: 'Generate Report', icon: DocumentIcon },
    { id: 'templates', name: 'Templates', icon: PrinterIcon },
    { id: 'history', name: 'History', icon: ArrowDownTrayIcon },
  ]

  return (
    <div className="space-y-6">
      <div className="card">
        <div className="card-header">
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Print Reports</h1>
          <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
            Generate and manage printable reports for events and contests
          </p>
        </div>
        <div className="card-body">
          <div className="border-b border-gray-200 dark:border-gray-700">
            <nav className="-mb-px flex space-x-8">
              {tabs.map((tab) => (
                <button
                  key={tab.id}
                  onClick={() => setActiveTab(tab.id)}
                  className={`${
                    activeTab === tab.id
                      ? 'border-blue-500 text-blue-600'
                      : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                  } whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm flex items-center`}
                >
                  <tab.icon className="h-5 w-5 mr-2" />
                  {tab.name}
                </button>
              ))}
            </nav>
          </div>

          <div className="mt-6">
            {activeTab === 'generate' && (
              <div className="text-center py-12">
                <DocumentIcon className="h-12 w-12 text-gray-400 mx-auto mb-4" />
                <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">Generate Report</h3>
                <p className="text-gray-600 dark:text-gray-400">Report generation functionality will be implemented here</p>
              </div>
            )}
            {activeTab === 'templates' && (
              <div className="text-center py-12">
                <PrinterIcon className="h-12 w-12 text-gray-400 mx-auto mb-4" />
                <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">Report Templates</h3>
                <p className="text-gray-600 dark:text-gray-400">Template management functionality will be implemented here</p>
              </div>
            )}
            {activeTab === 'history' && (
              <div className="text-center py-12">
                <ArrowDownTrayIcon className="h-12 w-12 text-gray-400 mx-auto mb-4" />
                <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">Report History</h3>
                <p className="text-gray-600 dark:text-gray-400">Report history functionality will be implemented here</p>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  )
}

export default PrintReports
EOF

    # Add missing components that are causing TypeScript errors
    print_status "Adding missing components with correct imports..."
    
    cat > "$APP_DIR/frontend/src/components/AuditLog.tsx" << 'EOF'
import React, { useState } from 'react'
import { useQuery } from 'react-query'
import { adminAPI, usersAPI, api } from '../services/api'
import { useAuth } from '../contexts/AuthContext'
import { getSeverityColor } from '../utils/helpers'
import {
  ClockIcon,
  UserIcon,
  DocumentTextIcon,
  EyeIcon,
  MagnifyingGlassIcon,
  FunnelIcon,
  CalendarIcon,
  ArrowDownTrayIcon,
  ExclamationTriangleIcon,
  CheckCircleIcon,
  InformationCircleIcon,
  XCircleIcon,
  PlusIcon,
  PencilIcon,
  TrashIcon,
  TrophyIcon,
  StarIcon,
  CogIcon,
  XMarkIcon,
} from '@heroicons/react/24/outline'
import { format } from 'date-fns'

interface AuditLogEntry {
  id: string
  userId: string
  userName: string
  userRole: string
  action: string
  entityType: 'USER' | 'EVENT' | 'CONTEST' | 'CATEGORY' | 'SCORE' | 'CERTIFICATION' | 'SYSTEM'
  entityId: string
  entityName: string
  oldValues?: Record<string, any>
  newValues?: Record<string, any>
  ipAddress: string
  userAgent: string
  timestamp: string
  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL'
  description: string
}

const AuditLog: React.FC = () => {
  const { user } = useAuth()
  const [searchTerm, setSearchTerm] = useState('')
  const [severityFilter, setSeverityFilter] = useState<string>('ALL')
  const [entityFilter, setEntityFilter] = useState<string>('ALL')
  const [dateFilter, setDateFilter] = useState<string>('ALL')
  const [selectedLog, setSelectedLog] = useState<AuditLogEntry | null>(null)
  const [showDetails, setShowDetails] = useState(false)

  const { data: auditLogs, isLoading } = useQuery(
    'auditLogs',
    () => adminAPI.getAuditLogs().then((res: any) => res.data),
    {
      enabled: user?.role === 'ORGANIZER' || user?.role === 'BOARD' || user?.role === 'AUDITOR',
    }
  )

  const getSeverityIcon = (severity: string) => {
    switch (severity) {
      case 'LOW':
        return <InformationCircleIcon className="h-4 w-4 text-blue-500" />
      case 'MEDIUM':
        return <ExclamationTriangleIcon className="h-4 w-4 text-yellow-500" />
      case 'HIGH':
        return <ExclamationTriangleIcon className="h-4 w-4 text-orange-500" />
      case 'CRITICAL':
        return <XCircleIcon className="h-4 w-4 text-red-500" />
      default:
        return <InformationCircleIcon className="h-4 w-4 text-gray-500" />
    }
  }

  const getEntityIcon = (entityType: string) => {
    switch (entityType) {
      case 'USER': return <UserIcon className="h-4 w-4" />
      case 'EVENT': return <CalendarIcon className="h-4 w-4" />
      case 'CONTEST': return <TrophyIcon className="h-4 w-4" />
      case 'CATEGORY': return <DocumentTextIcon className="h-4 w-4" />
      case 'SCORE': return <StarIcon className="h-4 w-4" />
      case 'CERTIFICATION': return <CheckCircleIcon className="h-4 w-4" />
      case 'SYSTEM': return <CogIcon className="h-4 w-4" />
      default: return <DocumentTextIcon className="h-4 w-4" />
    }
  }

  const filteredLogs = auditLogs?.filter((log: AuditLogEntry) => {
    const matchesSearch = log.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
                         log.userName.toLowerCase().includes(searchTerm.toLowerCase()) ||
                         log.action.toLowerCase().includes(searchTerm.toLowerCase())
    const matchesSeverity = severityFilter === 'ALL' || log.severity === severityFilter
    const matchesEntity = entityFilter === 'ALL' || log.entityType === entityFilter
    const matchesDate = dateFilter === 'ALL' || 
                       (dateFilter === 'TODAY' && new Date(log.timestamp).toDateString() === new Date().toDateString()) ||
                       (dateFilter === 'WEEK' && new Date(log.timestamp) > new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)) ||
                       (dateFilter === 'MONTH' && new Date(log.timestamp) > new Date(Date.now() - 30 * 24 * 60 * 60 * 1000))

    return matchesSearch && matchesSeverity && matchesEntity && matchesDate
  }) || []

  const handleViewDetails = (log: AuditLogEntry) => {
    setSelectedLog(log)
    setShowDetails(true)
  }

  const handleExport = () => {
    adminAPI.exportAuditLogs({
      searchTerm,
      severityFilter,
      entityFilter,
      dateFilter
    }).then((res: any) => {
      const blob = new Blob([res.data], { type: 'text/csv' })
      const url = window.URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = `audit-logs-${new Date().toISOString().split('T')[0]}.csv`
      a.click()
      window.URL.revokeObjectURL(url)
    })
  }

  return (
    <div className="space-y-6">
      <div className="card">
        <div className="card-header">
          <div className="flex items-center justify-between">
            <div>
              <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Audit Log</h1>
              <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
                Monitor system activity and user actions
              </p>
            </div>
            <button
              onClick={handleExport}
              className="btn-primary"
            >
              <ArrowDownTrayIcon className="h-5 w-5 mr-2" />
              Export Logs
            </button>
          </div>
        </div>
        <div className="card-body">
          <div className="flex flex-col sm:flex-row gap-4 mb-6">
            <div className="flex-1">
              <div className="relative">
                <MagnifyingGlassIcon className="h-5 w-5 absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" />
                <input
                  type="text"
                  placeholder="Search logs..."
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                  className="input pl-10"
                />
              </div>
            </div>
            <select
              value={severityFilter}
              onChange={(e) => setSeverityFilter(e.target.value)}
              className="input"
            >
              <option value="ALL">All Severities</option>
              <option value="LOW">Low</option>
              <option value="MEDIUM">Medium</option>
              <option value="HIGH">High</option>
              <option value="CRITICAL">Critical</option>
            </select>
            <select
              value={entityFilter}
              onChange={(e) => setEntityFilter(e.target.value)}
              className="input"
            >
              <option value="ALL">All Entities</option>
              <option value="USER">User</option>
              <option value="EVENT">Event</option>
              <option value="CONTEST">Contest</option>
              <option value="CATEGORY">Category</option>
              <option value="SCORE">Score</option>
              <option value="CERTIFICATION">Certification</option>
              <option value="SYSTEM">System</option>
            </select>
            <select
              value={dateFilter}
              onChange={(e) => setDateFilter(e.target.value)}
              className="input"
            >
              <option value="ALL">All Time</option>
              <option value="TODAY">Today</option>
              <option value="WEEK">This Week</option>
              <option value="MONTH">This Month</option>
            </select>
          </div>

          <div className="overflow-x-auto">
            <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
              <thead className="bg-gray-50 dark:bg-gray-800">
                <tr>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    Action
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    User
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    Entity
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    Severity
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    Timestamp
                  </th>
                  <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                    Actions
                  </th>
                </tr>
              </thead>
              <tbody className="bg-white dark:bg-gray-900 divide-y divide-gray-200 dark:divide-gray-700">
                {isLoading ? (
                  <tr>
                    <td colSpan={6} className="px-6 py-4 text-center text-gray-500 dark:text-gray-400">
                      Loading audit logs...
                    </td>
                  </tr>
                ) : filteredLogs.length === 0 ? (
                  <tr>
                    <td colSpan={6} className="px-6 py-4 text-center text-gray-500 dark:text-gray-400">
                      No audit logs found
                    </td>
                  </tr>
                ) : (
                  filteredLogs.map((log: AuditLogEntry) => (
                    <tr key={log.id} className="hover:bg-gray-50 dark:hover:bg-gray-800">
                      <td className="px-6 py-4 whitespace-nowrap">
                        <div className="flex items-center">
                          {getEntityIcon(log.entityType)}
                          <div className="ml-3">
                            <div className="text-sm font-medium text-gray-900 dark:text-white">
                              {log.action}
                            </div>
                            <div className="text-sm text-gray-500 dark:text-gray-400">
                              {log.description}
                            </div>
                          </div>
                        </div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <div className="text-sm text-gray-900 dark:text-white">{log.userName}</div>
                        <div className="text-sm text-gray-500 dark:text-gray-400">{log.userRole}</div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <div className="text-sm text-gray-900 dark:text-white">{log.entityName}</div>
                        <div className="text-sm text-gray-500 dark:text-gray-400">{log.entityType}</div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap">
                        <div className="flex items-center">
                          {getSeverityIcon(log.severity)}
                          <span className={`ml-2 px-2 py-1 text-xs font-medium rounded-full ${getSeverityColor(log.severity)}`}>
                            {log.severity}
                          </span>
                        </div>
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
                        {format(new Date(log.timestamp), 'MMM dd, yyyy HH:mm')}
                      </td>
                      <td className="px-6 py-4 whitespace-nowrap text-sm font-medium">
                        <button
                          onClick={() => handleViewDetails(log)}
                          className="text-blue-600 hover:text-blue-900 dark:text-blue-400 dark:hover:text-blue-300"
                        >
                          <EyeIcon className="h-4 w-4" />
                        </button>
                      </td>
                    </tr>
                  ))
                )}
              </tbody>
            </table>
          </div>
        </div>
      </div>

      {/* Details Modal */}
      {showDetails && selectedLog && (
        <div className="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
          <div className="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white dark:bg-gray-800">
            <div className="mt-3">
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-lg font-medium text-gray-900 dark:text-white">
                  Audit Log Details
                </h3>
                <button
                  onClick={() => setShowDetails(false)}
                  className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
                >
                  <XMarkIcon className="h-6 w-6" />
                </button>
              </div>
              
              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Action</label>
                  <p className="text-sm text-gray-900 dark:text-white">{selectedLog.action}</p>
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Description</label>
                  <p className="text-sm text-gray-900 dark:text-white">{selectedLog.description}</p>
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">User</label>
                  <p className="text-sm text-gray-900 dark:text-white">{selectedLog.userName} ({selectedLog.userRole})</p>
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Entity</label>
                  <p className="text-sm text-gray-900 dark:text-white">{selectedLog.entityName} ({selectedLog.entityType})</p>
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Severity</label>
                  <span className={`px-2 py-1 text-xs font-medium rounded-full ${getSeverityColor(selectedLog.severity)}`}>
                    {selectedLog.severity}
                  </span>
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Timestamp</label>
                  <p className="text-sm text-gray-900 dark:text-white">
                    {format(new Date(selectedLog.timestamp), 'MMM dd, yyyy HH:mm:ss')}
                  </p>
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">IP Address</label>
                  <p className="text-sm text-gray-900 dark:text-white">{selectedLog.ipAddress}</p>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}

export default AuditLog
EOF

    cat > "$APP_DIR/frontend/src/components/BackupManager.tsx" << 'EOF'
import React, { useState } from 'react'
import { useQuery, useMutation, useQueryClient } from 'react-query'
import { backupAPI } from '../services/api'
import {
  ArrowDownTrayIcon,
  ArrowUpTrayIcon,
  TrashIcon,
  ClockIcon,
  CheckCircleIcon,
  ExclamationTriangleIcon,
  DocumentIcon,
  CalendarIcon,
} from '@heroicons/react/24/outline'

interface Backup {
  id: string
  filename: string
  type: 'FULL' | 'SCHEMA' | 'DATA'
  size: number
  createdAt: string
  createdBy: string
  status: 'COMPLETED' | 'FAILED' | 'IN_PROGRESS'
  description?: string
}

const BackupManager: React.FC = () => {
  const [activeTab, setActiveTab] = useState('backups')
  const [selectedFile, setSelectedFile] = useState<File | null>(null)
  const [restoreBackupId, setRestoreBackupId] = useState<string | null>(null)
  const [showRestoreModal, setShowRestoreModal] = useState(false)

  const { data: backups, isLoading } = useQuery('backups', () => backupAPI.getAll().then((res: any) => res.data))
  const queryClient = useQueryClient()

  const createBackupMutation = useMutation(
    (data: { type: 'FULL' | 'SCHEMA' | 'DATA' }) => backupAPI.create(data.type),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('backups')
      }
    }
  )

  const deleteBackupMutation = useMutation(backupAPI.delete, {
    onSuccess: () => {
      queryClient.invalidateQueries('backups')
    }
  })

  const restoreBackupMutation = useMutation(backupAPI.restore, {
    onSuccess: () => {
      queryClient.invalidateQueries('backups')
      setShowRestoreModal(false)
      setRestoreBackupId(null)
    }
  })

  const handleFileSelect = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0]
    if (file) {
      setSelectedFile(file)
    }
  }

  const handleRestore = () => {
    if (restoreBackupId) {
      restoreBackupMutation.mutate(restoreBackupId)
    }
  }

  const formatFileSize = (bytes: number) => {
    const sizes = ['Bytes', 'KB', 'MB', 'GB']
    if (bytes === 0) return '0 Bytes'
    const i = Math.floor(Math.log(bytes) / Math.log(1024))
    return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i]
  }

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'COMPLETED':
        return <CheckCircleIcon className="h-5 w-5 text-green-500" />
      case 'FAILED':
        return <ExclamationTriangleIcon className="h-5 w-5 text-red-500" />
      case 'IN_PROGRESS':
        return <ClockIcon className="h-5 w-5 text-yellow-500" />
      default:
        return <ClockIcon className="h-5 w-5 text-gray-500" />
    }
  }

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'COMPLETED':
        return 'text-green-600 bg-green-100 dark:text-green-400 dark:bg-green-900'
      case 'FAILED':
        return 'text-red-600 bg-red-100 dark:text-red-400 dark:bg-red-900'
      case 'IN_PROGRESS':
        return 'text-yellow-600 bg-yellow-100 dark:text-yellow-400 dark:bg-yellow-900'
      default:
        return 'text-gray-600 bg-gray-100 dark:text-gray-400 dark:bg-gray-900'
    }
  }

  const getTypeIcon = (type: string) => {
    switch (type) {
      case 'FULL':
        return <DocumentIcon className="h-5 w-5 text-blue-500" />
      case 'SCHEMA':
        return <DocumentIcon className="h-5 w-5 text-green-500" />
      case 'DATA':
        return <DocumentIcon className="h-5 w-5 text-purple-500" />
      default:
        return <DocumentIcon className="h-5 w-5 text-gray-500" />
    }
  }

  const tabs = [
    { id: 'backups', name: 'Backups', icon: DocumentIcon },
    { id: 'restore', name: 'Restore', icon: ArrowUpTrayIcon },
  ]

  return (
    <div className="space-y-6">
      <div className="card">
        <div className="card-header">
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Backup Manager</h1>
          <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
            Manage database backups and restorations
          </p>
        </div>
        <div className="card-body">
          <div className="border-b border-gray-200 dark:border-gray-700">
            <nav className="-mb-px flex space-x-8">
              {tabs.map((tab) => (
                <button
                  key={tab.id}
                  onClick={() => setActiveTab(tab.id)}
                  className={`${
                    activeTab === tab.id
                      ? 'border-blue-500 text-blue-600'
                      : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                  } whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm flex items-center`}
                >
                  <tab.icon className="h-5 w-5 mr-2" />
                  {tab.name}
                </button>
              ))}
            </nav>
          </div>

          {activeTab === 'backups' && (
            <div className="mt-6">
              <div className="flex justify-between items-center mb-6">
                <h2 className="text-lg font-semibold text-gray-900 dark:text-white">Database Backups</h2>
                <button
                  onClick={() => createBackupMutation.mutate({ type: 'FULL' as const })}
                  disabled={createBackupMutation.isLoading}
                  className="btn-primary"
                >
                  <ArrowDownTrayIcon className="h-4 w-4 mr-2" />
                  Create Backup
                </button>
              </div>

              <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                  <thead className="bg-gray-50 dark:bg-gray-800">
                    <tr>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                        Backup
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                        Type
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                        Size
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                        Status
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                        Created
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                        Actions
                      </th>
                    </tr>
                  </thead>
                  <tbody className="bg-white dark:bg-gray-900 divide-y divide-gray-200 dark:divide-gray-700">
                    {isLoading ? (
                      <tr>
                        <td colSpan={6} className="px-6 py-4 text-center text-gray-500 dark:text-gray-400">
                          Loading backups...
                        </td>
                      </tr>
                    ) : backups?.length === 0 ? (
                      <tr>
                        <td colSpan={6} className="px-6 py-4 text-center text-gray-500 dark:text-gray-400">
                          No backups found
                        </td>
                      </tr>
                    ) : (
                      backups?.map((backup: Backup) => (
                        <tr key={backup.id} className="hover:bg-gray-50 dark:hover:bg-gray-800">
                          <td className="px-6 py-4 whitespace-nowrap">
                            <div className="flex items-center">
                              {getTypeIcon(backup.type)}
                              <div className="ml-3">
                                <div className="text-sm font-medium text-gray-900 dark:text-white">
                                  {backup.filename}
                                </div>
                                <div className="text-sm text-gray-500 dark:text-gray-400">
                                  {backup.createdBy}
                                </div>
                              </div>
                            </div>
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap">
                            <span className="px-2 py-1 text-xs font-medium rounded-full bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200">
                              {backup.type}
                            </span>
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-900 dark:text-white">
                            {formatFileSize(backup.size)}
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap">
                            <div className="flex items-center">
                              {getStatusIcon(backup.status)}
                              <span className={`ml-2 px-2 py-1 text-xs font-medium rounded-full ${getStatusColor(backup.status)}`}>
                                {backup.status}
                              </span>
                            </div>
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
                            {new Date(backup.createdAt).toLocaleDateString()}
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm font-medium">
                            <div className="flex space-x-2">
                              <button
                                onClick={() => backupAPI.download(backup.id)}
                                className="text-blue-600 hover:text-blue-900 dark:text-blue-400 dark:hover:text-blue-300"
                              >
                                <ArrowDownTrayIcon className="h-4 w-4" />
                              </button>
                              <button
                                onClick={() => {
                                  setRestoreBackupId(backup.id)
                                  setShowRestoreModal(true)
                                }}
                                className="text-green-600 hover:text-green-900 dark:text-green-400 dark:hover:text-green-300"
                              >
                                <ArrowUpTrayIcon className="h-4 w-4" />
                              </button>
                              <button
                                onClick={() => deleteBackupMutation.mutate(backup.id)}
                                className="text-red-600 hover:text-red-900 dark:text-red-400 dark:hover:text-red-300"
                              >
                                <TrashIcon className="h-4 w-4" />
                              </button>
                            </div>
                          </td>
                        </tr>
                      ))
                    )}
                  </tbody>
                </table>
              </div>
            </div>
          )}

          {activeTab === 'restore' && (
            <div className="mt-6">
              <h2 className="text-lg font-semibold text-gray-900 dark:text-white mb-6">Restore from File</h2>
              <div className="border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg p-6">
                <div className="text-center">
                  <ArrowUpTrayIcon className="mx-auto h-12 w-12 text-gray-400" />
                  <div className="mt-4">
                    <label htmlFor="backup-file" className="cursor-pointer">
                      <span className="mt-2 block text-sm font-medium text-gray-900 dark:text-white">
                        Upload backup file
                      </span>
                      <input
                        id="backup-file"
                        type="file"
                        accept=".sql,.db,.backup"
                        onChange={handleFileSelect}
                        className="sr-only"
                      />
                    </label>
                    <p className="mt-1 text-xs text-gray-500 dark:text-gray-400">
                      SQL, DB, or backup files
                    </p>
                  </div>
                  {selectedFile && (
                    <div className="mt-4">
                      <p className="text-sm text-gray-900 dark:text-white">
                        Selected: {selectedFile.name}
                      </p>
                      <button
                        onClick={() => restoreBackupMutation.mutate(selectedFile.name)}
                        disabled={restoreBackupMutation.isLoading}
                        className="mt-2 btn-primary"
                      >
                        Restore Backup
                      </button>
                    </div>
                  )}
                </div>
              </div>
            </div>
          )}
        </div>
      </div>

      {/* Restore Confirmation Modal */}
      {showRestoreModal && (
        <div className="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
          <div className="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white dark:bg-gray-800">
            <div className="mt-3">
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-lg font-medium text-gray-900 dark:text-white">
                  Confirm Restore
                </h3>
                <button
                  onClick={() => setShowRestoreModal(false)}
                  className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
                >
                  
                </button>
              </div>
              
              <div className="space-y-4">
                <p className="text-sm text-gray-600 dark:text-gray-400">
                  Are you sure you want to restore this backup? This action will replace all current data.
                </p>
                <div className="flex justify-end space-x-3">
                  <button
                    onClick={() => setShowRestoreModal(false)}
                    className="btn-secondary"
                  >
                    Cancel
                  </button>
                  <button
                    onClick={handleRestore}
                    disabled={restoreBackupMutation.isLoading}
                    className="btn-primary"
                  >
                    {restoreBackupMutation.isLoading ? 'Restoring...' : 'Restore'}
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}

export default BackupManager
EOF

    cat > "$APP_DIR/frontend/src/components/CategoryTemplates.tsx" << 'EOF'
import React, { useState } from 'react'
import { useQuery, useMutation, useQueryClient } from 'react-query'
import { contestsAPI, categoriesAPI, api } from '../services/api'
import { useAuth } from '../contexts/AuthContext'
import { getCategoryIcon, getCategoryColor } from '../utils/helpers'
import {
  DocumentTextIcon,
  PlusIcon,
  PencilIcon,
  TrashIcon,
  EyeIcon,
  DocumentDuplicateIcon,
  MagnifyingGlassIcon,
  FunnelIcon,
  CheckCircleIcon,
  ClockIcon,
  StarIcon,
  TrophyIcon,
  UserGroupIcon,
  CalendarIcon,
  XMarkIcon,
} from '@heroicons/react/24/outline'

interface CategoryTemplate {
  id: string
  name: string
  description: string
  categoryType: 'PERFORMANCE' | 'TECHNICAL' | 'CREATIVE' | 'SCHOLARSHIP' | 'CUSTOM'
  criteria: Array<{
    id: string
    name: string
    description: string
    maxScore: number
    weight: number
  }>
  tags: string[]
  isActive: boolean
  createdAt: string
  updatedAt: string
  createdBy: string
  usageCount: number
}

const CategoryTemplates: React.FC = () => {
  const { user } = useAuth()
  const [activeTab, setActiveTab] = useState('templates')
  const [searchTerm, setSearchTerm] = useState('')
  const [typeFilter, setTypeFilter] = useState<string>('ALL')
  const [selectedTemplate, setSelectedTemplate] = useState<CategoryTemplate | null>(null)
  const [showModal, setShowModal] = useState(false)
  const [isEditing, setIsEditing] = useState(false)
  const [formData, setFormData] = useState({
    name: '',
    description: '',
    categoryType: 'PERFORMANCE' as 'PERFORMANCE' | 'TECHNICAL' | 'CREATIVE' | 'SCHOLARSHIP' | 'CUSTOM',
    criteria: [] as Array<{ id: string; name: string; description: string; maxScore: number; weight: number }>,
    tags: [] as string[],
  })

  const queryClient = useQueryClient()

  const { data: templates, isLoading } = useQuery(
    'categoryTemplates',
    () => api.get('/category-templates').then((res: any) => res.data),
    {
      enabled: user?.role === 'ORGANIZER' || user?.role === 'BOARD',
    }
  )

  const createTemplateMutation = useMutation(
    (data: Partial<CategoryTemplate>) => api.post('/category-templates', data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('categoryTemplates')
        setShowModal(false)
        resetForm()
      }
    }
  )

  const updateTemplateMutation = useMutation(
    ({ id, data }: { id: string; data: Partial<CategoryTemplate> }) => 
      api.put(`/category-templates/${id}`, data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('categoryTemplates')
        setShowModal(false)
        resetForm()
      }
    }
  )

  const deleteTemplateMutation = useMutation(
    (id: string) => api.delete(`/category-templates/${id}`),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('categoryTemplates')
      }
    }
  )

  const duplicateTemplateMutation = useMutation(
    (id: string) => api.post(`/category-templates/${id}/duplicate`),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('categoryTemplates')
      }
    }
  )

  const resetForm = () => {
    setFormData({
      name: '',
      description: '',
      categoryType: 'PERFORMANCE',
      criteria: [],
      tags: [],
    })
    setIsEditing(false)
    setSelectedTemplate(null)
  }

  const handleCreate = () => {
    resetForm()
    setShowModal(true)
  }

  const handleEdit = (template: CategoryTemplate) => {
    setFormData({
      name: template.name,
      description: template.description,
      categoryType: template.categoryType,
      criteria: template.criteria.map(c => ({ 
        id: c.id, 
        name: c.name, 
        description: c.description, 
        maxScore: c.maxScore, 
        weight: c.weight 
      })),
      tags: template.tags,
    })
    setSelectedTemplate(template)
    setIsEditing(true)
    setShowModal(true)
  }

  const handleSave = () => {
    if (isEditing && selectedTemplate) {
      updateTemplateMutation.mutate({ id: selectedTemplate.id, data: formData })
    } else {
      createTemplateMutation.mutate(formData)
    }
  }

  const handleDelete = (id: string) => {
    if (confirm('Are you sure you want to delete this template?')) {
      deleteTemplateMutation.mutate(id)
    }
  }

  const handleDuplicate = (id: string) => {
    duplicateTemplateMutation.mutate(id)
  }

  const addCriterion = () => {
    setFormData(prev => ({
      ...prev,
      criteria: [...prev.criteria, { id: `temp-${Date.now()}`, name: '', description: '', maxScore: 10, weight: 1 }]
    }))
  }

  const removeCriterion = (index: number) => {
    setFormData(prev => ({
      ...prev,
      criteria: prev.criteria.filter((_, i) => i !== index)
    }))
  }

  const updateCriterion = (index: number, field: string, value: any) => {
    setFormData(prev => ({
      ...prev,
      criteria: prev.criteria.map((c, i) => 
        i === index ? { ...c, [field]: value } : c
      )
    }))
  }

  const addTag = (tag: string) => {
    if (tag && !formData.tags.includes(tag)) {
      setFormData(prev => ({
        ...prev,
        tags: [...prev.tags, tag]
      }))
    }
  }

  const removeTag = (tag: string) => {
    setFormData(prev => ({
      ...prev,
      tags: prev.tags.filter(t => t !== tag)
    }))
  }

  const getCategoryTypeIcon = (type: string) => {
    switch (type) {
      case 'PERFORMANCE': return <TrophyIcon className="h-5 w-5 text-yellow-500" />
      case 'TECHNICAL': return <DocumentTextIcon className="h-5 w-5 text-blue-500" />
      case 'CREATIVE': return <StarIcon className="h-5 w-5 text-purple-500" />
      case 'SCHOLARSHIP': return <UserGroupIcon className="h-5 w-5 text-green-500" />
      default: return <DocumentTextIcon className="h-5 w-5 text-gray-500" />
    }
  }

  const filteredTemplates = templates?.filter((template: CategoryTemplate) => {
    const matchesSearch = template.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                         template.description.toLowerCase().includes(searchTerm.toLowerCase())
    const matchesType = typeFilter === 'ALL' || template.categoryType === typeFilter
    return matchesSearch && matchesType
  }) || []

  const tabs = [
    { id: 'templates', name: 'Templates', icon: DocumentTextIcon },
    { id: 'analytics', name: 'Analytics', icon: StarIcon },
  ]

  return (
    <div className="space-y-6">
      <div className="card">
        <div className="card-header">
          <div className="flex items-center justify-between">
            <div>
              <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Category Templates</h1>
              <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
                Manage reusable category templates with predefined criteria
              </p>
            </div>
            <button
              onClick={handleCreate}
              className="btn-primary"
            >
              <PlusIcon className="h-5 w-5 mr-2" />
              New Template
            </button>
          </div>
        </div>
        <div className="card-body">
          <div className="border-b border-gray-200 dark:border-gray-700">
            <nav className="-mb-px flex space-x-8">
              {tabs.map((tab) => (
                <button
                  key={tab.id}
                  onClick={() => setActiveTab(tab.id)}
                  className={`${
                    activeTab === tab.id
                      ? 'border-blue-500 text-blue-600'
                      : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                  } whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm flex items-center`}
                >
                  <tab.icon className="h-5 w-5 mr-2" />
                  {tab.name}
                </button>
              ))}
            </nav>
          </div>

          {activeTab === 'templates' && (
            <div className="mt-6">
              <div className="flex flex-col sm:flex-row gap-4 mb-6">
                <div className="flex-1">
                  <div className="relative">
                    <MagnifyingGlassIcon className="h-5 w-5 absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" />
                    <input
                      type="text"
                      placeholder="Search templates..."
                      value={searchTerm}
                      onChange={(e) => setSearchTerm(e.target.value)}
                      className="input pl-10"
                    />
                  </div>
                </div>
                <select
                  value={typeFilter}
                  onChange={(e) => setTypeFilter(e.target.value)}
                  className="input"
                >
                  <option value="ALL">All Types</option>
                  <option value="PERFORMANCE">Performance</option>
                  <option value="TECHNICAL">Technical</option>
                  <option value="CREATIVE">Creative</option>
                  <option value="SCHOLARSHIP">Scholarship</option>
                  <option value="CUSTOM">Custom</option>
                </select>
              </div>

              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                {isLoading ? (
                  <div className="col-span-full text-center py-8 text-gray-500 dark:text-gray-400">
                    Loading templates...
                  </div>
                ) : filteredTemplates.length === 0 ? (
                  <div className="col-span-full text-center py-8 text-gray-500 dark:text-gray-400">
                    No templates found
                  </div>
                ) : (
                  filteredTemplates.map((template: CategoryTemplate) => (
                    <div key={template.id} className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-6 hover:shadow-md transition-shadow">
                      <div className="flex items-start justify-between">
                        <div className="flex items-center">
                          {getCategoryTypeIcon(template.categoryType)}
                          <div className="ml-3">
                            <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                              {template.name}
                            </h3>
                            <p className="text-sm text-gray-600 dark:text-gray-400">
                              {template.categoryType}
                            </p>
                          </div>
                        </div>
                        <div className="flex space-x-1">
                          <button
                            onClick={() => handleEdit(template)}
                            className="text-blue-600 hover:text-blue-900 dark:text-blue-400 dark:hover:text-blue-300"
                          >
                            <PencilIcon className="h-4 w-4" />
                          </button>
                          <button
                            onClick={() => handleDuplicate(template.id)}
                            className="text-green-600 hover:text-green-900 dark:text-green-400 dark:hover:text-green-300"
                          >
                            <DocumentDuplicateIcon className="h-4 w-4" />
                          </button>
                          <button
                            onClick={() => handleDelete(template.id)}
                            className="text-red-600 hover:text-red-900 dark:text-red-400 dark:hover:text-red-300"
                          >
                            <TrashIcon className="h-4 w-4" />
                          </button>
                        </div>
                      </div>
                      
                      <p className="mt-3 text-sm text-gray-600 dark:text-gray-400">
                        {template.description}
                      </p>
                      
                      <div className="mt-4 flex items-center justify-between">
                        <div className="flex items-center text-sm text-gray-500 dark:text-gray-400">
                          <CheckCircleIcon className="h-4 w-4 mr-1" />
                          {template.criteria.length} criteria
                        </div>
                        <div className="flex items-center text-sm text-gray-500 dark:text-gray-400">
                          <CalendarIcon className="h-4 w-4 mr-1" />
                          Used {template.usageCount} times
                        </div>
                      </div>
                      
                      {template.tags.length > 0 && (
                        <div className="mt-3 flex flex-wrap gap-1">
                          {template.tags.map((tag, index) => (
                            <span
                              key={index}
                              className="px-2 py-1 text-xs font-medium rounded-full bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200"
                            >
                              {tag}
                            </span>
                          ))}
                        </div>
                      )}
                    </div>
                  ))
                )}
              </div>
            </div>
          )}

          {activeTab === 'analytics' && (
            <div className="mt-6">
              <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-6">
                  <div className="flex items-center">
                    <DocumentTextIcon className="h-8 w-8 text-blue-500" />
                    <div className="ml-3">
                      <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Total Templates</p>
                      <p className="text-2xl font-semibold text-gray-900 dark:text-white">
                        {templates?.length || 0}
                      </p>
                    </div>
                  </div>
                </div>
                
                <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-6">
                  <div className="flex items-center">
                    <TrophyIcon className="h-8 w-8 text-yellow-500" />
                    <div className="ml-3">
                      <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Most Used</p>
                      <p className="text-2xl font-semibold text-gray-900 dark:text-white">
                        {templates?.reduce((max: number, template: CategoryTemplate) => 
                          Math.max(max, template.usageCount), 0) || 0}
                      </p>
                    </div>
                  </div>
                </div>
                
                <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-6">
                  <div className="flex items-center">
                    <StarIcon className="h-8 w-8 text-purple-500" />
                    <div className="ml-3">
                      <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Active Templates</p>
                      <p className="text-2xl font-semibold text-gray-900 dark:text-white">
                        {templates?.filter((t: CategoryTemplate) => t.isActive).length || 0}
                      </p>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          )}
        </div>
      </div>

      {/* Template Modal */}
      {showModal && (
        <div className="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
          <div className="relative top-20 mx-auto p-5 border w-full max-w-2xl shadow-lg rounded-md bg-white dark:bg-gray-800">
            <div className="mt-3">
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-lg font-medium text-gray-900 dark:text-white">
                  {isEditing ? 'Edit Template' : 'Create Template'}
                </h3>
                <button
                  onClick={() => setShowModal(false)}
                  className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
                >
                  <XMarkIcon className="h-6 w-6" />
                </button>
              </div>
              
              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Name</label>
                  <input
                    type="text"
                    value={formData.name}
                    onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))}
                    className="input mt-1"
                    placeholder="Template name"
                  />
                </div>
                
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Description</label>
                  <textarea
                    value={formData.description}
                    onChange={(e) => setFormData(prev => ({ ...prev, description: e.target.value }))}
                    className="input mt-1"
                    rows={3}
                    placeholder="Template description"
                  />
                </div>
                
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Category Type</label>
                  <select
                    value={formData.categoryType}
                    onChange={(e) => setFormData(prev => ({ ...prev, categoryType: e.target.value as any }))}
                    className="input mt-1"
                  >
                    <option value="PERFORMANCE">Performance</option>
                    <option value="TECHNICAL">Technical</option>
                    <option value="CREATIVE">Creative</option>
                    <option value="SCHOLARSHIP">Scholarship</option>
                    <option value="CUSTOM">Custom</option>
                  </select>
                </div>
                
                <div>
                  <div className="flex items-center justify-between">
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Criteria</label>
                    <button
                      onClick={addCriterion}
                      className="btn-secondary text-sm"
                    >
                      <PlusIcon className="h-4 w-4 mr-1" />
                      Add Criterion
                    </button>
                  </div>
                  
                  <div className="mt-2 space-y-3">
                    {formData.criteria.map((criterion, index) => (
                      <div key={index} className="flex items-center space-x-2 p-3 border border-gray-200 dark:border-gray-700 rounded-lg">
                        <div className="flex-1 grid grid-cols-2 gap-2">
                          <input
                            type="text"
                            value={criterion.name}
                            onChange={(e) => updateCriterion(index, 'name', e.target.value)}
                            className="input text-sm"
                            placeholder="Criterion name"
                          />
                          <input
                            type="number"
                            value={criterion.maxScore}
                            onChange={(e) => updateCriterion(index, 'maxScore', parseInt(e.target.value))}
                            className="input text-sm"
                            placeholder="Max score"
                            min="1"
                            max="100"
                          />
                        </div>
                        <button
                          onClick={() => removeCriterion(index)}
                          className="text-red-600 hover:text-red-900 dark:text-red-400 dark:hover:text-red-300"
                        >
                          <TrashIcon className="h-4 w-4" />
                        </button>
                      </div>
                    ))}
                  </div>
                </div>
                
                <div className="flex justify-end space-x-3">
                  <button
                    onClick={() => setShowModal(false)}
                    className="btn-secondary"
                  >
                    Cancel
                  </button>
                  <button
                    onClick={handleSave}
                    disabled={createTemplateMutation.isLoading || updateTemplateMutation.isLoading}
                    className="btn-primary"
                  >
                    {isEditing ? 'Update' : 'Create'}
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}

export default CategoryTemplates
EOF

    cat > "$APP_DIR/frontend/src/components/CertificationWorkflow.tsx" << 'EOF'
import React, { useState } from 'react'
import { useQuery, useMutation, useQueryClient } from 'react-query'
import { scoringAPI, contestsAPI, categoriesAPI, api } from '../services/api'
import { useAuth } from '../contexts/AuthContext'
import { getStatusColor, getStepIcon } from '../utils/helpers'
import {
  CheckCircleIcon,
  ClockIcon,
  ExclamationTriangleIcon,
  XCircleIcon,
  EyeIcon,
  PencilIcon,
  MagnifyingGlassIcon,
  FunnelIcon,
  UserIcon,
  TrophyIcon,
  DocumentTextIcon,
  ArrowRightIcon,
  ArrowDownIcon,
  ShieldCheckIcon,
  CalendarIcon,
  XMarkIcon,
} from '@heroicons/react/24/outline'

interface CertificationStep {
  id: string
  name: string
  description: string
  order: number
  isRequired: boolean
  status: 'PENDING' | 'IN_PROGRESS' | 'COMPLETED' | 'REJECTED'
  completedAt?: string
  completedBy?: string
  notes?: string
}

interface CertificationWorkflow {
  id: string
  contestantId: string
  contestantName: string
  categoryId: string
  categoryName: string
  currentStep: number
  status: 'PENDING' | 'IN_PROGRESS' | 'COMPLETED' | 'REJECTED'
  steps: CertificationStep[]
  createdAt: string
  updatedAt: string
}

const CertificationWorkflow: React.FC = () => {
  const { user } = useAuth()
  const [activeTab, setActiveTab] = useState('workflows')
  const [searchTerm, setSearchTerm] = useState('')
  const [statusFilter, setStatusFilter] = useState<string>('ALL')
  const [selectedWorkflow, setSelectedWorkflow] = useState<CertificationWorkflow | null>(null)
  const [showModal, setShowModal] = useState(false)
  const [selectedStep, setSelectedStep] = useState<CertificationStep | null>(null)
  const [stepNotes, setStepNotes] = useState('')

  const queryClient = useQueryClient()

  const { data: workflows, isLoading } = useQuery(
    'certificationWorkflows',
    () => api.get('/certification-workflows').then((res: any) => res.data),
    {
      enabled: user?.role === 'ORGANIZER' || user?.role === 'BOARD' || user?.role === 'AUDITOR',
    }
  )

  const updateStepMutation = useMutation(
    ({ workflowId, stepId, status, notes }: { workflowId: string; stepId: string; status: string; notes?: string }) =>
      api.put(`/certification-workflows/${workflowId}/steps/${stepId}`, { status, notes }),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('certificationWorkflows')
        setShowModal(false)
        setSelectedStep(null)
        setStepNotes('')
      }
    }
  )

  const handleStepUpdate = (workflowId: string, stepId: string, status: string) => {
    updateStepMutation.mutate({ workflowId, stepId, status, notes: stepNotes })
  }

  const handleViewWorkflow = (workflow: CertificationWorkflow) => {
    setSelectedWorkflow(workflow)
    setShowModal(true)
  }

  const handleStepClick = (step: CertificationStep) => {
    setSelectedStep(step)
    setStepNotes(step.notes || '')
  }

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'PENDING':
        return <ClockIcon className="h-5 w-5 text-gray-500" />
      case 'IN_PROGRESS':
        return <ClockIcon className="h-5 w-5 text-yellow-500" />
      case 'COMPLETED':
        return <CheckCircleIcon className="h-5 w-5 text-green-500" />
      case 'REJECTED':
        return <XCircleIcon className="h-5 w-5 text-red-500" />
      default:
        return <ClockIcon className="h-5 w-5 text-gray-500" />
    }
  }

  const getStepIcon = (step: CertificationStep) => {
    switch (step.status) {
      case 'PENDING':
        return <ClockIcon className="h-4 w-4 text-gray-400" />
      case 'IN_PROGRESS':
        return <ClockIcon className="h-4 w-4 text-yellow-500" />
      case 'COMPLETED':
        return <CheckCircleIcon className="h-4 w-4 text-green-500" />
      case 'REJECTED':
        return <XCircleIcon className="h-4 w-4 text-red-500" />
      default:
        return <ClockIcon className="h-4 w-4 text-gray-400" />
    }
  }

  const filteredWorkflows = workflows?.filter((workflow: CertificationWorkflow) => {
    const matchesSearch = workflow.contestantName.toLowerCase().includes(searchTerm.toLowerCase()) ||
                         workflow.categoryName.toLowerCase().includes(searchTerm.toLowerCase())
    const matchesStatus = statusFilter === 'ALL' || workflow.status === statusFilter
    return matchesSearch && matchesStatus
  }) || []

  const tabs = [
    { id: 'workflows', name: 'Workflows', icon: DocumentTextIcon },
    { id: 'analytics', name: 'Analytics', icon: TrophyIcon },
  ]

  return (
    <div className="space-y-6">
      <div className="card">
        <div className="card-header">
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Certification Workflow</h1>
          <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
            Manage contestant certification processes and workflow steps
          </p>
        </div>
        <div className="card-body">
          <div className="border-b border-gray-200 dark:border-gray-700">
            <nav className="-mb-px flex space-x-8">
              {tabs.map((tab) => (
                <button
                  key={tab.id}
                  onClick={() => setActiveTab(tab.id)}
                  className={`${
                    activeTab === tab.id
                      ? 'border-blue-500 text-blue-600'
                      : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                  } whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm flex items-center`}
                >
                  <tab.icon className="h-5 w-5 mr-2" />
                  {tab.name}
                </button>
              ))}
            </nav>
          </div>

          {activeTab === 'workflows' && (
            <div className="mt-6">
              <div className="flex flex-col sm:flex-row gap-4 mb-6">
                <div className="flex-1">
                  <div className="relative">
                    <MagnifyingGlassIcon className="h-5 w-5 absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" />
                    <input
                      type="text"
                      placeholder="Search workflows..."
                      value={searchTerm}
                      onChange={(e) => setSearchTerm(e.target.value)}
                      className="input pl-10"
                    />
                  </div>
                </div>
                <select
                  value={statusFilter}
                  onChange={(e) => setStatusFilter(e.target.value)}
                  className="input"
                >
                  <option value="ALL">All Statuses</option>
                  <option value="PENDING">Pending</option>
                  <option value="IN_PROGRESS">In Progress</option>
                  <option value="COMPLETED">Completed</option>
                  <option value="REJECTED">Rejected</option>
                </select>
              </div>

              <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                  <thead className="bg-gray-50 dark:bg-gray-800">
                    <tr>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                        Contestant
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                        Category
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                        Status
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                        Progress
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                        Created
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                        Actions
                      </th>
                    </tr>
                  </thead>
                  <tbody className="bg-white dark:bg-gray-900 divide-y divide-gray-200 dark:divide-gray-700">
                    {isLoading ? (
                      <tr>
                        <td colSpan={6} className="px-6 py-4 text-center text-gray-500 dark:text-gray-400">
                          Loading workflows...
                        </td>
                      </tr>
                    ) : filteredWorkflows.length === 0 ? (
                      <tr>
                        <td colSpan={6} className="px-6 py-4 text-center text-gray-500 dark:text-gray-400">
                          No workflows found
                        </td>
                      </tr>
                    ) : (
                      filteredWorkflows.map((workflow: CertificationWorkflow) => (
                        <tr key={workflow.id} className="hover:bg-gray-50 dark:hover:bg-gray-800">
                          <td className="px-6 py-4 whitespace-nowrap">
                            <div className="flex items-center">
                              <UserIcon className="h-5 w-5 text-gray-400" />
                              <div className="ml-3">
                                <div className="text-sm font-medium text-gray-900 dark:text-white">
                                  {workflow.contestantName}
                                </div>
                              </div>
                            </div>
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap">
                            <div className="flex items-center">
                              <TrophyIcon className="h-5 w-5 text-gray-400" />
                              <div className="ml-3">
                                <div className="text-sm font-medium text-gray-900 dark:text-white">
                                  {workflow.categoryName}
                                </div>
                              </div>
                            </div>
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap">
                            <div className="flex items-center">
                              {getStatusIcon(workflow.status)}
                              <span className={`ml-2 px-2 py-1 text-xs font-medium rounded-full ${getStatusColor(workflow.status)}`}>
                                {workflow.status}
                              </span>
                            </div>
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap">
                            <div className="flex items-center">
                              <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2">
                                <div 
                                  className="bg-blue-600 h-2 rounded-full" 
                                  style={{ width: `${(workflow.currentStep / workflow.steps.length) * 100}%` }}
                                ></div>
                              </div>
                              <span className="ml-2 text-sm text-gray-500 dark:text-gray-400">
                                {workflow.currentStep}/{workflow.steps.length}
                              </span>
                            </div>
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-400">
                            {new Date(workflow.createdAt).toLocaleDateString()}
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm font-medium">
                            <button
                              onClick={() => handleViewWorkflow(workflow)}
                              className="text-blue-600 hover:text-blue-900 dark:text-blue-400 dark:hover:text-blue-300"
                            >
                              <EyeIcon className="h-4 w-4" />
                            </button>
                          </td>
                        </tr>
                      ))
                    )}
                  </tbody>
                </table>
              </div>
            </div>
          )}

          {activeTab === 'analytics' && (
            <div className="mt-6">
              <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
                <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-6">
                  <div className="flex items-center">
                    <DocumentTextIcon className="h-8 w-8 text-blue-500" />
                    <div className="ml-3">
                      <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Total Workflows</p>
                      <p className="text-2xl font-semibold text-gray-900 dark:text-white">
                        {workflows?.length || 0}
                      </p>
                    </div>
                  </div>
                </div>
                
                <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-6">
                  <div className="flex items-center">
                    <ClockIcon className="h-8 w-8 text-yellow-500" />
                    <div className="ml-3">
                      <p className="text-sm font-medium text-gray-600 dark:text-gray-400">In Progress</p>
                      <p className="text-2xl font-semibold text-gray-900 dark:text-white">
                        {workflows?.filter((w: CertificationWorkflow) => w.status === 'IN_PROGRESS').length || 0}
                      </p>
                    </div>
                  </div>
                </div>
                
                <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-6">
                  <div className="flex items-center">
                    <CheckCircleIcon className="h-8 w-8 text-green-500" />
                    <div className="ml-3">
                      <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Completed</p>
                      <p className="text-2xl font-semibold text-gray-900 dark:text-white">
                        {workflows?.filter((w: CertificationWorkflow) => w.status === 'COMPLETED').length || 0}
                      </p>
                    </div>
                  </div>
                </div>
                
                <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-6">
                  <div className="flex items-center">
                    <TrophyIcon className="h-8 w-8 text-purple-500" />
                    <div className="ml-3">
                      <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Success Rate</p>
                      <p className="text-2xl font-semibold text-gray-900 dark:text-white">
                        {workflows?.length ? Math.round((workflows.filter((w: CertificationWorkflow) => w.status === 'COMPLETED').length / workflows.length) * 100) : 0}%
                      </p>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          )}
        </div>
      </div>

      {/* Workflow Details Modal */}
      {showModal && selectedWorkflow && (
        <div className="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
          <div className="relative top-20 mx-auto p-5 border w-full max-w-4xl shadow-lg rounded-md bg-white dark:bg-gray-800">
            <div className="mt-3">
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-lg font-medium text-gray-900 dark:text-white">
                  Certification Workflow: {selectedWorkflow.contestantName}
                </h3>
                <button
                  onClick={() => setShowModal(false)}
                  className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
                >
                  <XMarkIcon className="h-6 w-6" />
                </button>
              </div>
              
              <div className="space-y-6">
                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Contestant</label>
                    <p className="text-sm text-gray-900 dark:text-white">{selectedWorkflow.contestantName}</p>
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Category</label>
                    <p className="text-sm text-gray-900 dark:text-white">{selectedWorkflow.categoryName}</p>
                  </div>
                </div>
                
                <div>
                  <h4 className="text-md font-medium text-gray-900 dark:text-white mb-3">Workflow Steps</h4>
                  <div className="space-y-3">
                    {selectedWorkflow.steps.map((step, index) => (
                      <div key={step.id} className="flex items-center p-3 border border-gray-200 dark:border-gray-700 rounded-lg">
                        <div className="flex items-center">
                          {getStepIcon(step)}
                          <div className="ml-3">
                            <div className="text-sm font-medium text-gray-900 dark:text-white">
                              {step.name}
                            </div>
                            <div className="text-sm text-gray-600 dark:text-gray-400">
                              {step.description}
                            </div>
                          </div>
                        </div>
                        <div className="ml-auto flex items-center space-x-2">
                          <span className={`px-2 py-1 text-xs font-medium rounded-full ${getStatusColor(step.status)}`}>
                            {step.status}
                          </span>
                          <button
                            onClick={() => handleStepClick(step)}
                            className="text-blue-600 hover:text-blue-900 dark:text-blue-400 dark:hover:text-blue-300"
                          >
                            <PencilIcon className="h-4 w-4" />
                          </button>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Step Update Modal */}
      {selectedStep && (
        <div className="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
          <div className="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white dark:bg-gray-800">
            <div className="mt-3">
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-lg font-medium text-gray-900 dark:text-white">
                  Update Step: {selectedStep.name}
                </h3>
                <button
                  onClick={() => setSelectedStep(null)}
                  className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
                >
                  <XMarkIcon className="h-6 w-6" />
                </button>
              </div>
              
              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Status</label>
                  <select
                    value={selectedStep.status}
                    onChange={(e) => setSelectedStep(prev => prev ? { ...prev, status: e.target.value as any } : null)}
                    className="input mt-1"
                  >
                    <option value="PENDING">Pending</option>
                    <option value="IN_PROGRESS">In Progress</option>
                    <option value="COMPLETED">Completed</option>
                    <option value="REJECTED">Rejected</option>
                  </select>
                </div>
                
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Notes</label>
                  <textarea
                    value={stepNotes}
                    onChange={(e) => setStepNotes(e.target.value)}
                    className="input mt-1"
                    rows={3}
                    placeholder="Add notes..."
                  />
                </div>
                
                <div className="flex justify-end space-x-3">
                  <button
                    onClick={() => setSelectedStep(null)}
                    className="btn-secondary"
                  >
                    Cancel
                  </button>
                  <button
                    onClick={() => handleStepUpdate(selectedWorkflow!.id, selectedStep.id, selectedStep.status)}
                    disabled={updateStepMutation.isLoading}
                    className="btn-primary"
                  >
                    {updateStepMutation.isLoading ? 'Updating...' : 'Update'}
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}

export default CertificationWorkflow
EOF

    cat > "$APP_DIR/frontend/src/components/FileUpload.tsx" << 'EOF'
import React, { useState, useRef, useCallback } from 'react'
import { useQuery, useMutation, useQueryClient } from 'react-query'
import { uploadAPI, usersAPI, api } from '../services/api'
import { useAuth } from '../contexts/AuthContext'
import { getFileIcon, formatFileSize, getCategoryIcon } from '../utils/helpers'
import {
  CloudArrowUpIcon,
  DocumentIcon,
  PhotoIcon,
  TrashIcon,
  EyeIcon,
  ArrowDownTrayIcon,
  ExclamationTriangleIcon,
  CheckCircleIcon,
  ClockIcon,
  MagnifyingGlassIcon,
  FunnelIcon,
  UserIcon,
  CalendarIcon,
  TrophyIcon,
  XMarkIcon,
} from '@heroicons/react/24/outline'

interface UploadedFile {
  id: string
  filename: string
  originalName: string
  mimeType: string
  size: number
  uploadedBy: string
  uploadedAt: string
  category: 'CONTESTANT' | 'JUDGE' | 'EVENT' | 'TEMPLATE' | 'OTHER'
  description?: string
  tags: string[]
  isPublic: boolean
  downloadCount: number
}

const FileUpload: React.FC = () => {
  const { user } = useAuth()
  const [activeTab, setActiveTab] = useState('upload')
  const [dragActive, setDragActive] = useState(false)
  const [uploading, setUploading] = useState(false)
  const [uploadProgress, setUploadProgress] = useState(0)
  const [searchTerm, setSearchTerm] = useState('')
  const [categoryFilter, setCategoryFilter] = useState<string>('ALL')
  const [selectedFile, setSelectedFile] = useState<UploadedFile | null>(null)
  const [showModal, setShowModal] = useState(false)
  const fileInputRef = useRef<HTMLInputElement>(null)

  const queryClient = useQueryClient()

  const { data: files, isLoading } = useQuery(
    'uploadedFiles',
    () => uploadAPI.getFiles().then((res: any) => res.data),
    {
      enabled: user?.role === 'ORGANIZER' || user?.role === 'BOARD' || user?.role === 'JUDGE',
    }
  )

  const uploadMutation = useMutation(
    (formData: FormData) => uploadAPI.uploadFile(formData.get('file') as File),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('uploadedFiles')
        setUploading(false)
        setUploadProgress(0)
      },
      onError: () => {
        setUploading(false)
        setUploadProgress(0)
      }
    }
  )

  const deleteMutation = useMutation(
    (id: string) => uploadAPI.deleteFile(id),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('uploadedFiles')
      }
    }
  )

  const handleDrag = useCallback((e: React.DragEvent) => {
    e.preventDefault()
    e.stopPropagation()
    if (e.type === 'dragenter' || e.type === 'dragover') {
      setDragActive(true)
    } else if (e.type === 'dragleave') {
      setDragActive(false)
    }
  }, [])

  const handleDrop = useCallback((e: React.DragEvent) => {
    e.preventDefault()
    e.stopPropagation()
    setDragActive(false)
    
    if (e.dataTransfer.files && e.dataTransfer.files[0]) {
      handleFiles(e.dataTransfer.files)
    }
  }, [])

  const handleFiles = (files: FileList) => {
    const formData = new FormData()
    Array.from(files).forEach((file) => {
      formData.append('files', file)
    })
    
    setUploading(true)
    uploadMutation.mutate(formData)
  }

  const handleFileInput = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files) {
      handleFiles(e.target.files)
    }
  }

  const handleDelete = (id: string) => {
    if (confirm('Are you sure you want to delete this file?')) {
      deleteMutation.mutate(id)
    }
  }

  const handleDownload = (file: UploadedFile) => {
    api.get(`/upload/${file.id}/download`, { responseType: 'blob' }).then((res: any) => {
      const blob = new Blob([res.data])
      const url = window.URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = file.originalName
      a.click()
      window.URL.revokeObjectURL(url)
    })
  }

  const getCategoryIcon = (category: string) => {
    switch (category) {
      case 'CONTESTANT': return <UserIcon className="h-4 w-4" />
      case 'JUDGE': return <TrophyIcon className="h-4 w-4" />
      case 'EVENT': return <CalendarIcon className="h-4 w-4" />
      case 'TEMPLATE': return <TrophyIcon className="h-4 w-4" />
      default: return <DocumentIcon className="h-4 w-4" />
    }
  }

  const getCategoryColor = (category: string) => {
    switch (category) {
      case 'CONTESTANT': return 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200'
      case 'JUDGE': return 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
      case 'EVENT': return 'bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-200'
      case 'TEMPLATE': return 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200'
      default: return 'bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200'
    }
  }

  const filteredFiles = files?.filter((file: UploadedFile) => {
    const matchesSearch = file.originalName.toLowerCase().includes(searchTerm.toLowerCase()) ||
                         file.description?.toLowerCase().includes(searchTerm.toLowerCase())
    const matchesCategory = categoryFilter === 'ALL' || file.category === categoryFilter
    return matchesSearch && matchesCategory
  }) || []

  const tabs = [
    { id: 'upload', name: 'Upload', icon: CloudArrowUpIcon },
    { id: 'files', name: 'Files', icon: DocumentIcon },
    { id: 'analytics', name: 'Analytics', icon: TrophyIcon },
  ]

  return (
    <div className="space-y-6">
      <div className="card">
        <div className="card-header">
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">File Upload</h1>
          <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
            Upload and manage files for events, contestants, and judges
          </p>
        </div>
        <div className="card-body">
          <div className="border-b border-gray-200 dark:border-gray-700">
            <nav className="-mb-px flex space-x-8">
              {tabs.map((tab) => (
                <button
                  key={tab.id}
                  onClick={() => setActiveTab(tab.id)}
                  className={`${
                    activeTab === tab.id
                      ? 'border-blue-500 text-blue-600'
                      : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                  } whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm flex items-center`}
                >
                  <tab.icon className="h-5 w-5 mr-2" />
                  {tab.name}
                </button>
              ))}
            </nav>
          </div>

          {activeTab === 'upload' && (
            <div className="mt-6">
              <div
                className={`border-2 border-dashed rounded-lg p-8 text-center ${
                  dragActive
                    ? 'border-blue-500 bg-blue-50 dark:bg-blue-900'
                    : 'border-gray-300 dark:border-gray-600'
                }`}
                onDragEnter={handleDrag}
                onDragLeave={handleDrag}
                onDragOver={handleDrag}
                onDrop={handleDrop}
              >
                <CloudArrowUpIcon className="mx-auto h-12 w-12 text-gray-400" />
                <div className="mt-4">
                  <label htmlFor="file-upload" className="cursor-pointer">
                    <span className="mt-2 block text-sm font-medium text-gray-900 dark:text-white">
                      {uploading ? 'Uploading...' : 'Upload files'}
                    </span>
                    <input
                      ref={fileInputRef}
                      id="file-upload"
                      type="file"
                      multiple
                      onChange={handleFileInput}
                      className="sr-only"
                      disabled={uploading}
                    />
                  </label>
                  <p className="mt-1 text-xs text-gray-500 dark:text-gray-400">
                    Drag and drop files here, or click to select files
                  </p>
                </div>
                
                {uploading && (
                  <div className="mt-4">
                    <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2">
                      <div 
                        className="bg-blue-600 h-2 rounded-full transition-all duration-300" 
                        style={{ width: `${uploadProgress}%` }}
                      ></div>
                    </div>
                    <p className="mt-2 text-sm text-gray-600 dark:text-gray-400">
                      Uploading... {uploadProgress}%
                    </p>
                  </div>
                )}
              </div>
            </div>
          )}

          {activeTab === 'files' && (
            <div className="mt-6">
              <div className="flex flex-col sm:flex-row gap-4 mb-6">
                <div className="flex-1">
                  <div className="relative">
                    <MagnifyingGlassIcon className="h-5 w-5 absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" />
                    <input
                      type="text"
                      placeholder="Search files..."
                      value={searchTerm}
                      onChange={(e) => setSearchTerm(e.target.value)}
                      className="input pl-10"
                    />
                  </div>
                </div>
                <select
                  value={categoryFilter}
                  onChange={(e) => setCategoryFilter(e.target.value)}
                  className="input"
                >
                  <option value="ALL">All Categories</option>
                  <option value="CONTESTANT">Contestant</option>
                  <option value="JUDGE">Judge</option>
                  <option value="EVENT">Event</option>
                  <option value="TEMPLATE">Template</option>
                  <option value="OTHER">Other</option>
                </select>
              </div>

              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                {isLoading ? (
                  <div className="col-span-full text-center py-8 text-gray-500 dark:text-gray-400">
                    Loading files...
                  </div>
                ) : filteredFiles.length === 0 ? (
                  <div className="col-span-full text-center py-8 text-gray-500 dark:text-gray-400">
                    No files found
                  </div>
                ) : (
                  filteredFiles.map((file: UploadedFile) => (
                    <div key={file.id} className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-6 hover:shadow-md transition-shadow">
                      <div className="flex items-start justify-between">
                        <div className="flex items-center">
                          {getFileIcon(file.mimeType)}
                          <div className="ml-3">
                            <h3 className="text-lg font-semibold text-gray-900 dark:text-white truncate">
                              {file.originalName}
                            </h3>
                            <p className="text-sm text-gray-600 dark:text-gray-400">
                              {formatFileSize(file.size)}
                            </p>
                          </div>
                        </div>
                        <div className="flex space-x-1">
                          <button
                            onClick={() => handleDownload(file)}
                            className="text-blue-600 hover:text-blue-900 dark:text-blue-400 dark:hover:text-blue-300"
                          >
                            <ArrowDownTrayIcon className="h-4 w-4" />
                          </button>
                          <button
                            onClick={() => handleDelete(file.id)}
                            className="text-red-600 hover:text-red-900 dark:text-red-400 dark:hover:text-red-300"
                          >
                            <TrashIcon className="h-4 w-4" />
                          </button>
                        </div>
                      </div>
                      
                      <div className="mt-3 flex items-center justify-between">
                        <span className={`px-2 py-1 text-xs font-medium rounded-full ${getCategoryColor(file.category)}`}>
                          {file.category}
                        </span>
                        <div className="flex items-center text-sm text-gray-500 dark:text-gray-400">
                          <CalendarIcon className="h-4 w-4 mr-1" />
                          {new Date(file.uploadedAt).toLocaleDateString()}
                        </div>
                      </div>
                      
                      {file.description && (
                        <p className="mt-3 text-sm text-gray-600 dark:text-gray-400">
                          {file.description}
                        </p>
                      )}
                      
                      <div className="mt-3 flex items-center justify-between">
                        <div className="flex items-center text-sm text-gray-500 dark:text-gray-400">
                          <UserIcon className="h-4 w-4 mr-1" />
                          {file.uploadedBy}
                        </div>
                        <div className="flex items-center text-sm text-gray-500 dark:text-gray-400">
                          <ArrowDownTrayIcon className="h-4 w-4 mr-1" />
                          {file.downloadCount} downloads
                        </div>
                      </div>
                    </div>
                  ))
                )}
              </div>
            </div>
          )}

          {activeTab === 'analytics' && (
            <div className="mt-6">
              <div className="grid grid-cols-1 md:grid-cols-4 gap-6">
                <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-6">
                  <div className="flex items-center">
                    <DocumentIcon className="h-8 w-8 text-blue-500" />
                    <div className="ml-3">
                      <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Total Files</p>
                      <p className="text-2xl font-semibold text-gray-900 dark:text-white">
                        {files?.length || 0}
                      </p>
                    </div>
                  </div>
                </div>
                
                <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-6">
                  <div className="flex items-center">
                    <ArrowDownTrayIcon className="h-8 w-8 text-green-500" />
                    <div className="ml-3">
                      <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Total Downloads</p>
                      <p className="text-2xl font-semibold text-gray-900 dark:text-white">
                        {files?.reduce((total: number, file: UploadedFile) => total + file.downloadCount, 0) || 0}
                      </p>
                    </div>
                  </div>
                </div>
                
                <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-6">
                  <div className="flex items-center">
                    <TrophyIcon className="h-8 w-8 text-purple-500" />
                    <div className="ml-3">
                      <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Most Downloaded</p>
                      <p className="text-2xl font-semibold text-gray-900 dark:text-white">
                        {files?.reduce((max: number, file: UploadedFile) => Math.max(max, file.downloadCount), 0) || 0}
                      </p>
                    </div>
                  </div>
                </div>
                
                <div className="bg-white dark:bg-gray-800 rounded-lg border border-gray-200 dark:border-gray-700 p-6">
                  <div className="flex items-center">
                    <CalendarIcon className="h-8 w-8 text-yellow-500" />
                    <div className="ml-3">
                      <p className="text-sm font-medium text-gray-600 dark:text-gray-400">This Month</p>
                      <p className="text-2xl font-semibold text-gray-900 dark:text-white">
                        {files?.filter((file: UploadedFile) => 
                          new Date(file.uploadedAt).getMonth() === new Date().getMonth()
                        ).length || 0}
                      </p>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  )
}

export default FileUpload
EOF

    cat > "$APP_DIR/frontend/src/components/SettingsForm.tsx" << 'EOF'
import React, { useState, useEffect } from 'react'
import { useQuery, useMutation, useQueryClient } from 'react-query'
import { settingsAPI } from '../services/api'
import { useAuth } from '../contexts/AuthContext'
import { 
  CogIcon, 
  ShieldCheckIcon, 
  EnvelopeIcon, 
  ServerIcon,
  CheckCircleIcon,
  ExclamationTriangleIcon
} from '@heroicons/react/24/outline'

interface SettingsFormProps {
  onClose: () => void
}

interface LoggingSettings {
  level: string
  enableAudit: boolean
  enableActivity: boolean
  enableError: boolean
  maxLogAge: number
}

interface SecuritySettings {
  passwordMinLength: number
  passwordRequireUppercase: boolean
  passwordRequireLowercase: boolean
  passwordRequireNumbers: boolean
  passwordRequireSymbols: boolean
  passwordExpiryDays: number
  maxLoginAttempts: number
  lockoutDurationMinutes: number
  requireTwoFactor: boolean
  sessionTimeoutMinutes: number
  enableIpWhitelist: boolean
  allowedIps: string
}

interface BackupSettings {
  enableAutoBackup: boolean
  backupFrequency: string
  backupTime: string
  retentionDays: number
  backupLocation: string
  enableCompression: boolean
  enableEncryption: boolean
}

interface EmailSettings {
  smtpHost: string
  smtpPort: number
  smtpSecure: boolean
  smtpUser: string
  smtpPassword: string
  fromEmail: string
  fromName: string
  enableEmail: boolean
  enableNotifications: boolean
  enableReports: boolean
}

const SettingsForm: React.FC<SettingsFormProps> = ({ onClose }) => {
  const { user } = useAuth()
  const queryClient = useQueryClient()
  const [activeTab, setActiveTab] = useState('general')
  const [testResults, setTestResults] = useState<Record<string, { status: 'success' | 'error', message: string }>>({})

  // Logging settings
  const { data: loggingSettings, isLoading: loggingLoading } = useQuery(
    'logging-settings',
    () => settingsAPI.getLoggingLevels().then(res => res.data),
    { enabled: user?.role === 'ORGANIZER' || user?.role === 'BOARD' }
  )

  const updateLoggingMutation = useMutation(
    (settings: LoggingSettings) => settingsAPI.updateLoggingLevel(settings.level),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('logging-settings')
      }
    }
  )

  // Security settings
  const { data: securitySettings, isLoading: securityLoading } = useQuery(
    'security-settings',
    () => settingsAPI.getSecuritySettings().then(res => res.data),
    { enabled: user?.role === 'ORGANIZER' || user?.role === 'BOARD' }
  )

  const updateSecurityMutation = useMutation(
    (settings: SecuritySettings) => settingsAPI.updateSecuritySettings(settings),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('security-settings')
      }
    }
  )

  // Backup settings
  const { data: backupSettings, isLoading: backupLoading } = useQuery(
    'backup-settings',
    () => settingsAPI.getBackupSettings().then(res => res.data),
    { enabled: user?.role === 'ORGANIZER' || user?.role === 'BOARD' }
  )

  const updateBackupMutation = useMutation(
    (settings: BackupSettings) => settingsAPI.updateBackupSettings(settings),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('backup-settings')
      }
    }
  )

  // Email settings
  const { data: emailSettings, isLoading: emailLoading } = useQuery(
    'email-settings',
    () => settingsAPI.getEmailSettings().then(res => res.data),
    { enabled: user?.role === 'ORGANIZER' || user?.role === 'BOARD' }
  )

  const updateEmailMutation = useMutation(
    (settings: EmailSettings) => settingsAPI.updateEmailSettings(settings),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('email-settings')
      }
    }
  )

  const testConnection = async (type: string) => {
    try {
      const result = await settingsAPI.test(type as 'email' | 'database' | 'backup')
      setTestResults(prev => ({
        ...prev,
        [type]: { status: 'success', message: result.data.message }
      }))
    } catch (error: any) {
      setTestResults(prev => ({
        ...prev,
        [type]: { status: 'error', message: error.response?.data?.error || 'Test failed' }
      }))
    }
  }

  const tabs = [
    { id: 'general', name: 'General', icon: CogIcon },
    { id: 'security', name: 'Security', icon: ShieldCheckIcon },
    { id: 'email', name: 'Email', icon: EnvelopeIcon },
    { id: 'backup', name: 'Backup', icon: ServerIcon },
  ]

  if (loggingLoading || securityLoading || backupLoading || emailLoading) {
    return (
      <div className="flex items-center justify-center p-8">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600"></div>
      </div>
    )
  }

  return (
    <div className="bg-white rounded-lg shadow-lg max-w-4xl mx-auto">
      <div className="border-b border-gray-200">
        <div className="flex">
          {tabs.map((tab) => (
            <button
              key={tab.id}
              onClick={() => setActiveTab(tab.id)}
              className={`flex items-center px-6 py-3 text-sm font-medium border-b-2 ${
                activeTab === tab.id
                  ? 'border-blue-500 text-blue-600'
                  : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
              }`}
            >
              <tab.icon className="w-5 h-5 mr-2" />
              {tab.name}
            </button>
          ))}
        </div>
      </div>

      <div className="p-6">
        {activeTab === 'general' && (
          <div className="space-y-6">
            <h3 className="text-lg font-medium text-gray-900">General Settings</h3>
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Application Name
                </label>
                <input
                  type="text"
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  defaultValue="Event Manager"
                />
              </div>
              
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Timezone
                </label>
                <select className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                  <option value="UTC">UTC</option>
                  <option value="America/New_York">Eastern Time</option>
                  <option value="America/Chicago">Central Time</option>
                  <option value="America/Denver">Mountain Time</option>
                  <option value="America/Los_Angeles">Pacific Time</option>
                </select>
              </div>
            </div>

            <div className="flex justify-end space-x-3">
              <button
                onClick={() => testConnection('database')}
                className="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 border border-gray-300 rounded-md hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                Test Database
              </button>
              <button className="px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-transparent rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500">
                Save Settings
              </button>
            </div>

            {testResults.database && (
              <div className={`p-3 rounded-md ${
                testResults.database.status === 'success' 
                  ? 'bg-green-50 text-green-800' 
                  : 'bg-red-50 text-red-800'
              }`}>
                <div className="flex items-center">
                  {testResults.database.status === 'success' ? (
                    <CheckCircleIcon className="w-5 h-5 mr-2" />
                  ) : (
                    <ExclamationTriangleIcon className="w-5 h-5 mr-2" />
                  )}
                  {testResults.database.message}
                </div>
              </div>
            )}
          </div>
        )}

        {activeTab === 'security' && (
          <div className="space-y-6">
            <h3 className="text-lg font-medium text-gray-900">Security Settings</h3>
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Minimum Password Length
                </label>
                <input
                  type="number"
                  min="6"
                  max="32"
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  defaultValue={securitySettings?.passwordMinLength || 8}
                />
              </div>
              
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Password Expiry (days)
                </label>
                <input
                  type="number"
                  min="30"
                  max="365"
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  defaultValue={securitySettings?.passwordExpiryDays || 90}
                />
              </div>
            </div>

            <div className="space-y-4">
              <div className="flex items-center">
                <input
                  type="checkbox"
                  className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                  defaultChecked={securitySettings?.passwordRequireUppercase || true}
                />
                <label className="ml-2 text-sm text-gray-700">
                  Require uppercase letters
                </label>
              </div>
              
              <div className="flex items-center">
                <input
                  type="checkbox"
                  className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                  defaultChecked={securitySettings?.passwordRequireLowercase || true}
                />
                <label className="ml-2 text-sm text-gray-700">
                  Require lowercase letters
                </label>
              </div>
              
              <div className="flex items-center">
                <input
                  type="checkbox"
                  className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                  defaultChecked={securitySettings?.passwordRequireNumbers || true}
                />
                <label className="ml-2 text-sm text-gray-700">
                  Require numbers
                </label>
              </div>
              
              <div className="flex items-center">
                <input
                  type="checkbox"
                  className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                  defaultChecked={securitySettings?.passwordRequireSymbols || false}
                />
                <label className="ml-2 text-sm text-gray-700">
                  Require special characters
                </label>
              </div>
            </div>

            <div className="flex justify-end">
              <button className="px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-transparent rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500">
                Save Security Settings
              </button>
            </div>
          </div>
        )}

        {activeTab === 'email' && (
          <div className="space-y-6">
            <h3 className="text-lg font-medium text-gray-900">Email Settings</h3>
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  SMTP Host
                </label>
                <input
                  type="text"
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  defaultValue={emailSettings?.smtpHost || ''}
                  placeholder="smtp.gmail.com"
                />
              </div>
              
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  SMTP Port
                </label>
                <input
                  type="number"
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  defaultValue={emailSettings?.smtpPort || 587}
                />
              </div>
              
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  SMTP Username
                </label>
                <input
                  type="text"
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  defaultValue={emailSettings?.smtpUser || ''}
                />
              </div>
              
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  SMTP Password
                </label>
                <input
                  type="password"
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  defaultValue={emailSettings?.smtpPassword || ''}
                />
              </div>
              
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  From Email
                </label>
                <input
                  type="email"
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  defaultValue={emailSettings?.fromEmail || ''}
                />
              </div>
              
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  From Name
                </label>
                <input
                  type="text"
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  defaultValue={emailSettings?.fromName || ''}
                />
              </div>
            </div>

            <div className="space-y-4">
              <div className="flex items-center">
                <input
                  type="checkbox"
                  className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                  defaultChecked={emailSettings?.enableEmail || false}
                />
                <label className="ml-2 text-sm text-gray-700">
                  Enable email notifications
                </label>
              </div>
              
              <div className="flex items-center">
                <input
                  type="checkbox"
                  className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                  defaultChecked={emailSettings?.enableNotifications || true}
                />
                <label className="ml-2 text-sm text-gray-700">
                  Enable system notifications
                </label>
              </div>
            </div>

            <div className="flex justify-end space-x-3">
              <button
                onClick={() => testConnection('email')}
                className="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 border border-gray-300 rounded-md hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                Test Email
              </button>
              <button className="px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-transparent rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500">
                Save Email Settings
              </button>
            </div>

            {testResults.email && (
              <div className={`p-3 rounded-md ${
                testResults.email.status === 'success' 
                  ? 'bg-green-50 text-green-800' 
                  : 'bg-red-50 text-red-800'
              }`}>
                <div className="flex items-center">
                  {testResults.email.status === 'success' ? (
                    <CheckCircleIcon className="w-5 h-5 mr-2" />
                  ) : (
                    <ExclamationTriangleIcon className="w-5 h-5 mr-2" />
                  )}
                  {testResults.email.message}
                </div>
              </div>
            )}
          </div>
        )}

        {activeTab === 'backup' && (
          <div className="space-y-6">
            <h3 className="text-lg font-medium text-gray-900">Backup Settings</h3>
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Backup Location
                </label>
                <input
                  type="text"
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  defaultValue={backupSettings?.backupLocation || './backups'}
                />
              </div>
              
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Retention Days
                </label>
                <input
                  type="number"
                  min="1"
                  max="365"
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  defaultValue={backupSettings?.retentionDays || 30}
                />
              </div>
              
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Backup Frequency
                </label>
                <select className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                  <option value="DAILY">Daily</option>
                  <option value="WEEKLY">Weekly</option>
                  <option value="MONTHLY">Monthly</option>
                </select>
              </div>
              
              <div>
                <label className="block text-sm font-medium text-gray-700 mb-2">
                  Backup Time
                </label>
                <input
                  type="time"
                  className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500"
                  defaultValue={backupSettings?.backupTime || '02:00'}
                />
              </div>
            </div>

            <div className="space-y-4">
              <div className="flex items-center">
                <input
                  type="checkbox"
                  className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                  defaultChecked={backupSettings?.enableAutoBackup || false}
                />
                <label className="ml-2 text-sm text-gray-700">
                  Enable automatic backups
                </label>
              </div>
              
              <div className="flex items-center">
                <input
                  type="checkbox"
                  className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                  defaultChecked={backupSettings?.enableCompression || true}
                />
                <label className="ml-2 text-sm text-gray-700">
                  Enable compression
                </label>
              </div>
              
              <div className="flex items-center">
                <input
                  type="checkbox"
                  className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                  defaultChecked={backupSettings?.enableEncryption || false}
                />
                <label className="ml-2 text-sm text-gray-700">
                  Enable encryption
                </label>
              </div>
            </div>

            <div className="flex justify-end space-x-3">
              <button
                onClick={() => testConnection('backup')}
                className="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 border border-gray-300 rounded-md hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500"
              >
                Test Backup
              </button>
              <button className="px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-transparent rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500">
                Save Backup Settings
              </button>
            </div>

            {testResults.backup && (
              <div className={`p-3 rounded-md ${
                testResults.backup.status === 'success' 
                  ? 'bg-green-50 text-green-800' 
                  : 'bg-red-50 text-red-800'
              }`}>
                <div className="flex items-center">
                  {testResults.backup.status === 'success' ? (
                    <CheckCircleIcon className="w-5 h-5 mr-2" />
                  ) : (
                    <ExclamationTriangleIcon className="w-5 h-5 mr-2" />
                  )}
                  {testResults.backup.message}
                </div>
              </div>
            )}
          </div>
        )}
      </div>

      <div className="border-t border-gray-200 px-6 py-3 flex justify-end">
        <button
          onClick={onClose}
          className="px-4 py-2 text-sm font-medium text-gray-700 bg-gray-100 border border-gray-300 rounded-md hover:bg-gray-200 focus:outline-none focus:ring-2 focus:ring-blue-500"
        >
          Close
        </button>
      </div>
    </div>
  )
}

export default SettingsForm
EOF

    # Bulk Import Component
    cat > "$APP_DIR/frontend/src/components/BulkImport.tsx" << 'EOF'
import React, { useState, useRef } from 'react'
import { useMutation, useQueryClient } from 'react-query'
import { bulkImportAPI } from '../services/api'
import { useAuth } from '../contexts/AuthContext'
import { 
  ArrowUpTrayIcon, 
  DocumentArrowDownIcon, 
  CheckCircleIcon, 
  ExclamationTriangleIcon,
  XCircleIcon,
  InformationCircleIcon
} from '@heroicons/react/24/outline'

interface ImportResult {
  success: boolean
  message: string
  totalProcessed: number
  successful: number
  failed: number
  errors: string[]
  createdUsers: Array<{
    id: string
    name: string
    email: string
    role: string
  }>
}

const BulkImport: React.FC = () => {
  const { user } = useAuth()
  const queryClient = useQueryClient()
  const fileInputRef = useRef<HTMLInputElement>(null)
  
  const [file, setFile] = useState<File | null>(null)
  const [isUploading, setIsUploading] = useState(false)
  const [importResult, setImportResult] = useState<ImportResult | null>(null)
  const [showSample, setShowSample] = useState(false)

  const importMutation = useMutation(bulkImportAPI.importUsers, {
    onSuccess: (data: any) => {
      setImportResult(data as ImportResult)
      setIsUploading(false)
      queryClient.invalidateQueries(['users'])
    },
    onError: (error: any) => {
      setImportResult({
        success: false,
        message: error.response?.data?.error || 'Import failed',
        totalProcessed: 0,
        successful: 0,
        failed: 0,
        errors: [error.response?.data?.error || 'Unknown error'],
        createdUsers: []
      })
      setIsUploading(false)
    }
  })

  const downloadSampleMutation = useMutation(bulkImportAPI.downloadSample, {
    onSuccess: (data: any) => {
      const blob = new Blob([data as BlobPart], { type: 'text/csv' })
      const url = window.URL.createObjectURL(blob)
      const link = document.createElement('a')
      link.href = url
      link.download = 'user_import_sample.csv'
      document.body.appendChild(link)
      link.click()
      document.body.removeChild(link)
      window.URL.revokeObjectURL(url)
    }
  })

  const handleFileSelect = (event: React.ChangeEvent<HTMLInputElement>) => {
    const selectedFile = event.target.files?.[0]
    if (selectedFile) {
      if (selectedFile.type === 'text/csv' || selectedFile.name.endsWith('.csv')) {
        setFile(selectedFile)
        setImportResult(null)
      } else {
        alert('Please select a CSV file')
      }
    }
  }

  const handleImport = async () => {
    if (!file) return
    
    setIsUploading(true)
    const formData = new FormData()
    formData.append('file', file)
    
    importMutation.mutate(formData as any)
  }

  const handleDownloadSample = () => {
    downloadSampleMutation.mutate()
  }

  const resetImport = () => {
    setFile(null)
    setImportResult(null)
    if (fileInputRef.current) {
      fileInputRef.current.value = ''
    }
  }

  if (!user || !['ADMIN', 'BOARD'].includes(user.role)) {
    return (
      <div className="bg-red-50 border border-red-200 rounded-lg p-4">
        <div className="flex">
          <ExclamationTriangleIcon className="h-5 w-5 text-red-400" />
          <div className="ml-3">
            <h3 className="text-sm font-medium text-red-800">
              Access Denied
            </h3>
            <div className="mt-2 text-sm text-red-700">
              You don't have permission to access bulk import functionality.
            </div>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      <div className="bg-white shadow rounded-lg">
        <div className="px-4 py-5 sm:p-6">
          <h3 className="text-lg leading-6 font-medium text-gray-900 mb-4">
            Bulk User Import
          </h3>
          
          <div className="space-y-4">
            {/* File Upload Area */}
            <div className="border-2 border-dashed border-gray-300 rounded-lg p-6">
              <div className="text-center">
                <ArrowUpTrayIcon className="mx-auto h-12 w-12 text-gray-400" />
                <div className="mt-4">
                  <label htmlFor="file-upload" className="cursor-pointer">
                    <span className="mt-2 block text-sm font-medium text-gray-900">
                      Upload CSV file
                    </span>
                    <span className="mt-1 block text-sm text-gray-500">
                      or drag and drop
                    </span>
                  </label>
                  <input
                    ref={fileInputRef}
                    id="file-upload"
                    name="file-upload"
                    type="file"
                    className="sr-only"
                    accept=".csv"
                    onChange={handleFileSelect}
                  />
                </div>
              </div>
              
              {file && (
                <div className="mt-4 p-3 bg-blue-50 rounded-md">
                  <div className="flex items-center">
                    <DocumentArrowDownIcon className="h-5 w-5 text-blue-400" />
                    <span className="ml-2 text-sm text-blue-700">
                      Selected: {file.name} ({(file.size / 1024).toFixed(1)} KB)
                    </span>
                  </div>
                </div>
              )}
            </div>

            {/* Sample Download */}
            <div className="flex items-center justify-between">
              <div className="flex items-center">
                <InformationCircleIcon className="h-5 w-5 text-gray-400 mr-2" />
                <span className="text-sm text-gray-600">
                  Need a sample CSV file?
                </span>
              </div>
              <button
                onClick={handleDownloadSample}
                disabled={downloadSampleMutation.isLoading}
                className="inline-flex items-center px-3 py-2 border border-gray-300 shadow-sm text-sm leading-4 font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50"
              >
                <DocumentArrowDownIcon className="h-4 w-4 mr-2" />
                Download Sample
              </button>
            </div>

            {/* Action Buttons */}
            <div className="flex justify-end space-x-3">
              {file && (
                <button
                  onClick={resetImport}
                  className="px-4 py-2 border border-gray-300 rounded-md text-sm font-medium text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500"
                >
                  Clear
                </button>
              )}
              <button
                onClick={handleImport}
                disabled={!file || isUploading}
                className="px-4 py-2 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50"
              >
                {isUploading ? 'Importing...' : 'Import Users'}
              </button>
            </div>
          </div>
        </div>
      </div>

      {/* Import Results */}
      {importResult && (
        <div className="bg-white shadow rounded-lg">
          <div className="px-4 py-5 sm:p-6">
            <h3 className="text-lg leading-6 font-medium text-gray-900 mb-4">
              Import Results
            </h3>
            
            <div className="space-y-4">
              {/* Summary */}
              <div className={`p-4 rounded-md ${
                importResult.success ? 'bg-green-50' : 'bg-red-50'
              }`}>
                <div className="flex">
                  {importResult.success ? (
                    <CheckCircleIcon className="h-5 w-5 text-green-400" />
                  ) : (
                    <XCircleIcon className="h-5 w-5 text-red-400" />
                  )}
                  <div className="ml-3">
                    <h3 className={`text-sm font-medium ${
                      importResult.success ? 'text-green-800' : 'text-red-800'
                    }`}>
                      {importResult.message}
                    </h3>
                    <div className={`mt-2 text-sm ${
                      importResult.success ? 'text-green-700' : 'text-red-700'
                    }`}>
                      <p>Total processed: {importResult.totalProcessed}</p>
                      <p>Successful: {importResult.successful}</p>
                      <p>Failed: {importResult.failed}</p>
                    </div>
                  </div>
                </div>
              </div>

              {/* Errors */}
              {importResult.errors.length > 0 && (
                <div className="bg-red-50 border border-red-200 rounded-md p-4">
                  <h4 className="text-sm font-medium text-red-800 mb-2">
                    Errors:
                  </h4>
                  <ul className="text-sm text-red-700 space-y-1">
                    {importResult.errors.map((error, index) => (
                      <li key={index}> {error}</li>
                    ))}
                  </ul>
                </div>
              )}

              {/* Created Users */}
              {importResult.createdUsers.length > 0 && (
                <div className="bg-green-50 border border-green-200 rounded-md p-4">
                  <h4 className="text-sm font-medium text-green-800 mb-2">
                    Successfully Created Users:
                  </h4>
                  <div className="space-y-2">
                    {importResult.createdUsers.map((user) => (
                      <div key={user.id} className="text-sm text-green-700">
                        <span className="font-medium">{user.name}</span> ({user.email}) - {user.role}
                      </div>
                    ))}
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>
      )}

      {/* CSV Format Information */}
      <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
        <h4 className="text-sm font-medium text-blue-800 mb-2">
          CSV Format Requirements:
        </h4>
        <div className="text-sm text-blue-700 space-y-1">
          <p> Required columns: name, email, role</p>
          <p> Optional columns: phone, bio, pronouns, preferredName</p>
          <p> Role must be one of: ADMIN, BOARD, JUDGE, CONTESTANT, AUDITOR, TALLY_MASTER, EMCEE</p>
          <p> Email addresses must be unique</p>
          <p> First row should contain column headers</p>
        </div>
      </div>
    </div>
  )
}

export default BulkImport
EOF

    # Force overwrite ContestsPage to fix create method signature

    
    # Force overwrite ContestsPage to fix create method signature
    cat > "$APP_DIR/frontend/src/pages/ContestsPage.tsx" << 'EOF'
import React, { useState } from 'react'
import { useParams } from 'react-router-dom'
import { useQuery, useMutation, useQueryClient } from 'react-query'
import { contestsAPI } from '../services/api'
import { PlusIcon, PencilIcon, TrashIcon } from '@heroicons/react/24/outline'

interface Contest {
  id: string
  name: string
  description: string
  startDate: string
  endDate: string
  maxContestants: number
  status: 'DRAFT' | 'ACTIVE' | 'COMPLETED' | 'ARCHIVED'
  eventId: string
  createdAt: string
  updatedAt: string
}

const ContestsPage: React.FC = () => {
  const { eventId } = useParams<{ eventId: string }>()
  const [showModal, setShowModal] = useState(false)
  const [editingContest, setEditingContest] = useState<Contest | null>(null)
  const [formData, setFormData] = useState<Partial<Contest>>({})
  const queryClient = useQueryClient()

  const { data: contests, isLoading } = useQuery(
    ['contests', eventId],
    () => contestsAPI.getByEvent(eventId!).then((res: any) => res.data),
    { enabled: !!eventId }
  )

  const createMutation = useMutation(
    (data: Partial<Contest>) => contestsAPI.create(eventId!, data), // FIXED: Correct signature
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['contests', eventId])
        setShowModal(false)
        setFormData({})
      }
    }
  )

  const updateMutation = useMutation(
    ({ id, data }: { id: string; data: Partial<Contest> }) => 
      contestsAPI.update(id, data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['contests', eventId])
        setShowModal(false)
        setEditingContest(null)
        setFormData({})
      }
    }
  )

  const deleteMutation = useMutation(
    (id: string) => contestsAPI.delete(id),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['contests', eventId])
      }
    }
  )

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    if (editingContest) {
      updateMutation.mutate({ id: editingContest.id, data: formData })
    } else {
      createMutation.mutate(formData)
    }
  }

  const handleEdit = (contest: Contest) => {
    setEditingContest(contest)
    setFormData(contest)
    setShowModal(true)
  }

  const handleDelete = (id: string) => {
    if (confirm('Are you sure you want to delete this contest?')) {
      deleteMutation.mutate(id)
    }
  }

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="loading-spinner"></div>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      <div className="card">
        <div className="card-header">
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Contests Management</h1>
          <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
            Create and manage contests within events
          </p>
        </div>
        <div className="card-body">
          <div className="flex justify-between items-center mb-6">
            <h2 className="text-lg font-semibold">Contests</h2>
            <button
              onClick={() => setShowModal(true)}
              className="btn btn-primary"
            >
              <PlusIcon className="h-5 w-5 mr-2" />
              Add Contest
            </button>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {contests?.map((contest: Contest) => (
              <div key={contest.id} className="card">
                <div className="card-header">
                  <h3 className="font-semibold">{contest.name}</h3>
                  <p className="text-sm text-gray-600 dark:text-gray-400">
                    {contest.description}
                  </p>
                </div>
                <div className="card-body">
                  <div className="space-y-2">
                    <p className="text-sm">
                      <span className="font-medium">Status:</span> {contest.status}
                    </p>
                    <p className="text-sm">
                      <span className="font-medium">Max Contestants:</span> {contest.maxContestants}
                    </p>
                    <p className="text-sm">
                      <span className="font-medium">Start:</span> {new Date(contest.startDate).toLocaleDateString()}
                    </p>
                    <p className="text-sm">
                      <span className="font-medium">End:</span> {new Date(contest.endDate).toLocaleDateString()}
                    </p>
                  </div>
                </div>
                <div className="card-footer">
                  <div className="flex space-x-2">
                    <button
                      onClick={() => handleEdit(contest)}
                      className="btn btn-outline btn-sm"
                    >
                      <PencilIcon className="h-4 w-4" />
                    </button>
                    <button
                      onClick={() => handleDelete(contest.id)}
                      className="btn btn-destructive btn-sm"
                    >
                      <TrashIcon className="h-4 w-4" />
                    </button>
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>
      </div>

      {/* Modal */}
      {showModal && (
        <div className="modal">
          <div className="modal-overlay" onClick={() => setShowModal(false)}></div>
          <div className="modal-content">
            <h2 className="text-xl font-bold mb-4">
              {editingContest ? 'Edit Contest' : 'Add Contest'}
            </h2>
            <form onSubmit={handleSubmit} className="space-y-4">
              <div>
                <label className="label">Name</label>
                <input
                  type="text"
                  value={formData.name || ''}
                  onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                  className="input"
                  required
                />
              </div>
              <div>
                <label className="label">Description</label>
                <textarea
                  value={formData.description || ''}
                  onChange={(e) => setFormData({ ...formData, description: e.target.value })}
                  className="input"
                  rows={3}
                />
              </div>
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <label className="label">Start Date</label>
                  <input
                    type="date"
                    value={formData.startDate || ''}
                    onChange={(e) => setFormData({ ...formData, startDate: e.target.value })}
                    className="input"
                    required
                  />
                </div>
                <div>
                  <label className="label">End Date</label>
                  <input
                    type="date"
                    value={formData.endDate || ''}
                    onChange={(e) => setFormData({ ...formData, endDate: e.target.value })}
                    className="input"
                    required
                  />
                </div>
              </div>
              <div>
                <label className="label">Max Contestants</label>
                <input
                  type="number"
                  value={formData.maxContestants || ''}
                  onChange={(e) => setFormData({ ...formData, maxContestants: parseInt(e.target.value) })}
                  className="input"
                  min="1"
                  required
                />
              </div>
              <div className="flex justify-end space-x-2">
                <button
                  type="button"
                  onClick={() => setShowModal(false)}
                  className="btn btn-outline"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  className="btn btn-primary"
                  disabled={createMutation.isLoading || updateMutation.isLoading}
                >
                  {editingContest ? 'Update' : 'Create'}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}
    </div>
  )
}

export default ContestsPage
EOF
    
    cat > "$APP_DIR/frontend/src/pages/LoginPage.tsx" << 'EOF'
import React, { useState } from 'react'
import { useAuth } from '../contexts/AuthContext'

const LoginPage: React.FC = () => {
  const [email, setEmail] = useState('')
  const [password, setPassword] = useState('')
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState('')
  const [showPassword, setShowPassword] = useState(false)
  const { login } = useAuth()

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setIsLoading(true)
    setError('')

    try {
      await login(email, password)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Login failed')
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-gray-900 dark:to-gray-800 flex flex-col justify-center py-12 sm:px-6 lg:px-8">
      <div className="sm:mx-auto sm:w-full sm:max-w-md">
        <div className="text-center">
          <div className="mx-auto h-12 w-12 bg-indigo-600 rounded-full flex items-center justify-center">
            <svg className="h-8 w-8 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          </div>
          <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900 dark:text-white">
            Event Manager
          </h2>
          <p className="mt-2 text-center text-sm text-gray-600 dark:text-gray-400">
            Professional Contest Management System
          </p>
        </div>
      </div>

      <div className="mt-8 sm:mx-auto sm:w-full sm:max-w-md">
        <div className="bg-white dark:bg-gray-800 py-8 px-4 shadow-xl sm:rounded-lg sm:px-10">
          <form className="space-y-6" onSubmit={handleSubmit}>
            <div>
              <label htmlFor="email" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Email address
              </label>
              <div className="mt-1">
                <input
                  id="email"
                  name="email"
                  type="email"
                  autoComplete="email"
                  required
                  value={email}
                  onChange={(e) => setEmail(e.target.value)}
                  className="appearance-none block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md placeholder-gray-400 dark:placeholder-gray-500 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 dark:bg-gray-700 dark:text-white sm:text-sm"
                  placeholder="Enter your email"
                />
              </div>
            </div>

            <div>
              <label htmlFor="password" className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                Password
              </label>
              <div className="mt-1 relative">
                <input
                  id="password"
                  name="password"
                  type={showPassword ? 'text' : 'password'}
                  autoComplete="current-password"
                  required
                  value={password}
                  onChange={(e) => setPassword(e.target.value)}
                  className="appearance-none block w-full px-3 py-2 pr-10 border border-gray-300 dark:border-gray-600 rounded-md placeholder-gray-400 dark:placeholder-gray-500 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 dark:bg-gray-700 dark:text-white sm:text-sm"
                  placeholder="Enter your password"
                />
                <button
                  type="button"
                  className="absolute inset-y-0 right-0 pr-3 flex items-center"
                  onClick={() => setShowPassword(!showPassword)}
                >
                  {showPassword ? (
                    <svg className="h-5 w-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.878 9.878L3 3m6.878 6.878L21 21" />
                    </svg>
                  ) : (
                    <svg className="h-5 w-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
                    </svg>
                  )}
                </button>
              </div>
            </div>

            {error && (
              <div className="rounded-md bg-red-50 dark:bg-red-900 p-4">
                <div className="flex">
                  <div className="flex-shrink-0">
                    <svg className="h-5 w-5 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                  </div>
                  <div className="ml-3">
                    <h3 className="text-sm font-medium text-red-800 dark:text-red-200">
                      Login Error
                    </h3>
                    <div className="mt-2 text-sm text-red-700 dark:text-red-300">
                      {error}
                    </div>
                  </div>
                </div>
              </div>
            )}

            <div>
              <button
                type="submit"
                disabled={isLoading}
                className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50 disabled:cursor-not-allowed transition-colors duration-200"
              >
                {isLoading ? (
                  <div className="flex items-center">
                    <svg className="animate-spin -ml-1 mr-3 h-5 w-5 text-white" fill="none" viewBox="0 0 24 24">
                      <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                      <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                    </svg>
                    Signing in...
                  </div>
                ) : (
                  'Sign in'
                )}
              </button>
            </div>
          </form>
        </div>
      </div>
    </div>
  )
}

export default LoginPage
EOF

    cat > "$APP_DIR/frontend/src/pages/Dashboard.tsx" << 'EOF'
import React, { useState } from 'react'
import { useQuery } from 'react-query'
import { useNavigate } from 'react-router-dom'
import { useAuth } from '../contexts/AuthContext'
import { useSocket } from '../contexts/SocketContext'
import { adminAPI, eventsAPI, contestsAPI, usersAPI } from '../services/api'
import {
  ChartBarIcon,
  UsersIcon,
  CalendarIcon,
  TrophyIcon,
  DocumentTextIcon,
  ClockIcon,
  CheckCircleIcon,
  ExclamationTriangleIcon,
  ArrowUpIcon,
  ArrowDownIcon,
  EyeIcon,
  PencilIcon,
  TrashIcon,
  PlusIcon,
  DocumentArrowDownIcon,
  PrinterIcon,
} from '@heroicons/react/24/outline'
import { format, subDays, subWeeks, subMonths } from 'date-fns'

const Dashboard: React.FC = () => {
  const { user, isLoading: authLoading } = useAuth()
  const { isConnected } = useSocket()
  const navigate = useNavigate()
  const [timeRange, setTimeRange] = useState<'7d' | '30d' | '90d' | '1y'>('30d')

  // Admin/Board queries
  const { data: stats, isLoading: statsLoading } = useQuery(
    'admin-stats',
    () => adminAPI.getStats().then(res => res.data),
    {
      enabled: !authLoading && (user?.role === 'ORGANIZER' || user?.role === 'BOARD'),
      refetchInterval: 30000, // Refresh every 30 seconds
    }
  )

  const { data: events, isLoading: eventsLoading } = useQuery(
    'recent-events',
    () => eventsAPI.getAll().then(res => res.data.slice(0, 5)),
    {
      enabled: !authLoading && (user?.role === 'ORGANIZER' || user?.role === 'BOARD'),
      refetchInterval: 60000, // Refresh every minute
    }
  )

  const { data: contests, isLoading: contestsLoading } = useQuery(
    'recent-contests',
    () => contestsAPI.getAll().then(res => res.data.slice(0, 5)),
    {
      enabled: !authLoading && (user?.role === 'ORGANIZER' || user?.role === 'BOARD'),
      refetchInterval: 60000,
    }
  )

  const { data: users, isLoading: usersLoading } = useQuery(
    'recent-users',
    () => usersAPI.getAll().then(res => res.data.slice(0, 5)),
    {
      enabled: !authLoading && (user?.role === 'ORGANIZER' || user?.role === 'BOARD'),
      refetchInterval: 120000, // Refresh every 2 minutes
    }
  )

  const { data: activityLogs, isLoading: activityLoading } = useQuery(
    'activity-logs',
    () => adminAPI.getActivityLogs().then(res => res.data.slice(0, 10)),
    {
      enabled: !authLoading && (user?.role === 'ORGANIZER' || user?.role === 'BOARD'),
      refetchInterval: 30000,
    }
  )

  const getRoleSpecificContent = () => {
    switch (user?.role) {
      case 'ORGANIZER':
      case 'BOARD':
        return (
          <div className="space-y-6">
            {/* System Status */}
            <div className="bg-white dark:bg-gray-800 overflow-hidden shadow rounded-lg">
              <div className="px-4 py-5 sm:p-6">
                <h3 className="text-lg leading-6 font-medium text-gray-900 dark:text-white mb-4">
                  System Status
                </h3>
                <div className="flex items-center space-x-4">
                  <div className="flex items-center">
                    <div className={`w-3 h-3 rounded-full ${isConnected ? 'bg-green-400' : 'bg-red-400'}`}></div>
                    <span className="ml-2 text-sm text-gray-600 dark:text-gray-400">
                      WebSocket: {isConnected ? 'Connected' : 'Disconnected'}
                    </span>
                  </div>
                  <div className="flex items-center">
                    <div className="w-3 h-3 rounded-full bg-green-400"></div>
                    <span className="ml-2 text-sm text-gray-600 dark:text-gray-400">Database: Online</span>
                  </div>
                  <div className="flex items-center">
                    <div className="w-3 h-3 rounded-full bg-green-400"></div>
                    <span className="ml-2 text-sm text-gray-600 dark:text-gray-400">API: Online</span>
                  </div>
                </div>
              </div>
            </div>

            {/* System Overview */}
            <div className="bg-white dark:bg-gray-800 overflow-hidden shadow rounded-lg">
              <div className="px-4 py-5 sm:p-6">
                <h3 className="text-lg leading-6 font-medium text-gray-900 dark:text-white mb-4">
                  System Overview
                </h3>
                {statsLoading ? (
                  <div className="animate-pulse">
                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                      {[...Array(4)].map((_, i) => (
                        <div key={i} className="h-20 bg-gray-200 dark:bg-gray-700 rounded"></div>
                      ))}
                    </div>
                  </div>
                ) : (
                  <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                    <div className="bg-blue-50 dark:bg-blue-900 p-4 rounded-lg">
                      <div className="flex items-center">
                        <div className="flex-shrink-0">
                          <div className="w-8 h-8 bg-blue-500 rounded-md flex items-center justify-center">
                            <span className="text-white font-bold text-sm">E</span>
                          </div>
                        </div>
                        <div className="ml-3">
                          <p className="text-sm font-medium text-blue-600 dark:text-blue-400">Events</p>
                          <p className="text-2xl font-semibold text-blue-900 dark:text-blue-100">{stats?.events || 0}</p>
                        </div>
                      </div>
                    </div>
                    <div className="bg-green-50 dark:bg-green-900 p-4 rounded-lg">
                      <div className="flex items-center">
                        <div className="flex-shrink-0">
                          <div className="w-8 h-8 bg-green-500 rounded-md flex items-center justify-center">
                            <span className="text-white font-bold text-sm">C</span>
                          </div>
                        </div>
                        <div className="ml-3">
                          <p className="text-sm font-medium text-green-600 dark:text-green-400">Contests</p>
                          <p className="text-2xl font-semibold text-green-900 dark:text-green-100">{stats?.contests || 0}</p>
                        </div>
                      </div>
                    </div>
                    <div className="bg-yellow-50 dark:bg-yellow-900 p-4 rounded-lg">
                      <div className="flex items-center">
                        <div className="flex-shrink-0">
                          <div className="w-8 h-8 bg-yellow-500 rounded-md flex items-center justify-center">
                            <span className="text-white font-bold text-sm">U</span>
                          </div>
                        </div>
                        <div className="ml-3">
                          <p className="text-sm font-medium text-yellow-600 dark:text-yellow-400">Users</p>
                          <p className="text-2xl font-semibold text-yellow-900 dark:text-yellow-100">{stats?.users || 0}</p>
                        </div>
                      </div>
                    </div>
                    <div className="bg-purple-50 dark:bg-purple-900 p-4 rounded-lg">
                      <div className="flex items-center">
                        <div className="flex-shrink-0">
                          <div className="w-8 h-8 bg-purple-500 rounded-md flex items-center justify-center">
                            <span className="text-white font-bold text-sm">S</span>
                          </div>
                        </div>
                        <div className="ml-3">
                          <p className="text-sm font-medium text-purple-600 dark:text-purple-400">Scores</p>
                          <p className="text-2xl font-semibold text-purple-900 dark:text-purple-100">{stats?.scores || 0}</p>
                        </div>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            </div>

            {/* Quick Actions */}
            <div className="bg-white dark:bg-gray-800 overflow-hidden shadow rounded-lg">
              <div className="px-4 py-5 sm:p-6">
                <h3 className="text-lg leading-6 font-medium text-gray-900 dark:text-white mb-4">
                  Quick Actions
                </h3>
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                  <button 
                    onClick={() => navigate('/events')}
                    className="p-4 bg-blue-50 dark:bg-blue-900 hover:bg-blue-100 dark:hover:bg-blue-800 rounded-lg text-left transition-colors"
                  >
                    <div className="text-blue-600 dark:text-blue-400 font-medium">Create New Event</div>
                    <div className="text-sm text-blue-500 dark:text-blue-300">Start a new contest event</div>
                  </button>
                  <button 
                    onClick={() => navigate('/users')}
                    className="p-4 bg-green-50 dark:bg-green-900 hover:bg-green-100 dark:hover:bg-green-800 rounded-lg text-left transition-colors"
                  >
                    <div className="text-green-600 dark:text-green-400 font-medium">Manage Users</div>
                    <div className="text-sm text-green-500 dark:text-green-300">Add judges and contestants</div>
                  </button>
                  <button 
                    onClick={() => navigate('/reports')}
                    className="p-4 bg-yellow-50 dark:bg-yellow-900 hover:bg-yellow-100 dark:hover:bg-yellow-800 rounded-lg text-left transition-colors"
                  >
                    <div className="text-yellow-600 dark:text-yellow-400 font-medium">View Reports</div>
                    <div className="text-sm text-yellow-500 dark:text-yellow-300">Generate contest reports</div>
                  </button>
                </div>
              </div>
            </div>

            {/* Recent Events */}
            <div className="bg-white dark:bg-gray-800 overflow-hidden shadow rounded-lg">
              <div className="px-4 py-5 sm:p-6">
                <h3 className="text-lg leading-6 font-medium text-gray-900 dark:text-white mb-4">
                  Recent Events
                </h3>
                {eventsLoading ? (
                  <div className="animate-pulse space-y-3">
                    {[...Array(3)].map((_, i) => (
                      <div key={i} className="h-16 bg-gray-200 dark:bg-gray-700 rounded"></div>
                    ))}
                  </div>
                ) : (
                  <div className="space-y-3">
                    {events?.map((event: any) => (
                      <div key={event.id} className="flex items-center justify-between p-3 bg-gray-50 dark:bg-gray-700 rounded-lg">
                        <div>
                          <h4 className="text-sm font-medium text-gray-900 dark:text-white">{event.name}</h4>
                          <p className="text-sm text-gray-500 dark:text-gray-400">{event.description}</p>
                        </div>
                        <div className="text-sm text-gray-500 dark:text-gray-400">
                          {new Date(event.createdAt).toLocaleDateString()}
                        </div>
                      </div>
                    ))}
                  </div>
                )}
              </div>
            </div>
          </div>
        )

      case 'JUDGE':
        return (
          <div className="space-y-6">
            <div className="bg-white dark:bg-gray-800 overflow-hidden shadow rounded-lg">
              <div className="px-4 py-5 sm:p-6">
                <h3 className="text-lg leading-6 font-medium text-gray-900 dark:text-white mb-4">
                  Judge Dashboard
                </h3>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  <div>
                    <h4 className="text-md font-medium text-gray-900 dark:text-white mb-2">Assigned Categories</h4>
                    <div className="space-y-2">
                      <div className="p-3 bg-green-50 dark:bg-green-900 rounded-md">
                        <h5 className="font-medium text-green-900 dark:text-green-100">Category A - Performance</h5>
                        <p className="text-sm text-green-700 dark:text-green-300">5 contestants to score</p>
                      </div>
                      <div className="p-3 bg-blue-50 dark:bg-blue-900 rounded-md">
                        <h5 className="font-medium text-blue-900 dark:text-blue-100">Category B - Technique</h5>
                        <p className="text-sm text-blue-700 dark:text-blue-300">3 contestants to score</p>
                      </div>
                    </div>
                  </div>
                  <div>
                    <h4 className="text-md font-medium text-gray-900 dark:text-white mb-2">Scoring Progress</h4>
                    <div className="space-y-2">
                      <div className="flex justify-between">
                        <span className="text-sm text-gray-600 dark:text-gray-400">Category A</span>
                        <span className="text-sm font-medium text-green-600 dark:text-green-400">80% Complete</span>
                      </div>
                      <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2">
                        <div className="bg-green-600 h-2 rounded-full" style={{width: '80%'}}></div>
                      </div>
                      <div className="flex justify-between">
                        <span className="text-sm text-gray-600 dark:text-gray-400">Category B</span>
                        <span className="text-sm font-medium text-blue-600 dark:text-blue-400">60% Complete</span>
                      </div>
                      <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2">
                        <div className="bg-blue-600 h-2 rounded-full" style={{width: '60%'}}></div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        )

      case 'CONTESTANT':
        return (
          <div className="space-y-6">
            <div className="bg-white dark:bg-gray-800 overflow-hidden shadow rounded-lg">
              <div className="px-4 py-5 sm:p-6">
                <h3 className="text-lg leading-6 font-medium text-gray-900 dark:text-white mb-4">
                  Contestant Dashboard
                </h3>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  <div>
                    <h4 className="text-md font-medium text-gray-900 dark:text-white mb-2">My Scores</h4>
                    <div className="space-y-2">
                      <div className="p-3 bg-purple-50 dark:bg-purple-900 rounded-md">
                        <h5 className="font-medium text-purple-900 dark:text-purple-100">Category A - Performance</h5>
                        <p className="text-sm text-purple-700 dark:text-purple-300">Average Score: 8.5/10</p>
                      </div>
                      <div className="p-3 bg-blue-50 dark:bg-blue-900 rounded-md">
                        <h5 className="font-medium text-blue-900 dark:text-blue-100">Category B - Technique</h5>
                        <p className="text-sm text-blue-700 dark:text-blue-300">Average Score: 7.8/10</p>
                      </div>
                    </div>
                  </div>
                  <div>
                    <h4 className="text-md font-medium text-gray-900 dark:text-white mb-2">Contest Information</h4>
                    <div className="space-y-2 text-sm text-gray-600 dark:text-gray-400">
                      <p> Contest: Spring Contest 2024</p>
                      <p> Contestant Number: #001</p>
                      <p> Categories: Performance, Technique</p>
                      <p> Status: Active</p>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        )

      case 'EMCEE':
        return (
          <div className="space-y-6">
            <div className="bg-white dark:bg-gray-800 overflow-hidden shadow rounded-lg">
              <div className="px-4 py-5 sm:p-6">
                <h3 className="text-lg leading-6 font-medium text-gray-900 dark:text-white mb-4">
                  Emcee Dashboard
                </h3>
                <div className="space-y-4">
                  <div className="p-4 bg-pink-50 dark:bg-pink-900 rounded-lg">
                    <h4 className="font-medium text-pink-900 dark:text-pink-100 mb-2">Available Scripts</h4>
                    <p className="text-sm text-pink-700 dark:text-pink-300">Access your emcee scripts and announcements</p>
                  </div>
                  <div className="p-4 bg-blue-50 dark:bg-blue-900 rounded-lg">
                    <h4 className="font-medium text-blue-900 dark:text-blue-100 mb-2">Contest Schedule</h4>
                    <p className="text-sm text-blue-700 dark:text-blue-300">View upcoming contests and events</p>
                  </div>
                </div>
              </div>
            </div>
          </div>
        )

      case 'TALLY_MASTER':
      case 'AUDITOR':
        return (
          <div className="space-y-6">
            <div className="bg-white dark:bg-gray-800 overflow-hidden shadow rounded-lg">
              <div className="px-4 py-5 sm:p-6">
                <h3 className="text-lg leading-6 font-medium text-gray-900 dark:text-white mb-4">
                  {user?.role === 'TALLY_MASTER' ? 'Tally Master' : 'Auditor'} Dashboard
                </h3>
                <div className="space-y-4">
                  <div className="p-4 bg-indigo-50 dark:bg-indigo-900 rounded-lg">
                    <h4 className="font-medium text-indigo-900 dark:text-indigo-100 mb-2">Certification Queue</h4>
                    <p className="text-sm text-indigo-700 dark:text-indigo-300">Review and certify judge scores</p>
                  </div>
                  <div className="p-4 bg-green-50 dark:bg-green-900 rounded-lg">
                    <h4 className="font-medium text-green-900 dark:text-green-100 mb-2">Score Verification</h4>
                    <p className="text-sm text-green-700 dark:text-green-300">Verify and validate contest scores</p>
                  </div>
                </div>
              </div>
            </div>
          </div>
        )

      default:
        return (
          <div className="bg-white dark:bg-gray-800 overflow-hidden shadow rounded-lg">
            <div className="px-4 py-5 sm:p-6">
              <h3 className="text-lg leading-6 font-medium text-gray-900 dark:text-white mb-4">
                Welcome to Event Manager
              </h3>
              <div className="text-center">
                <p className="text-gray-600 dark:text-gray-400 mb-4">
                  Welcome to the Event Manager Dashboard!
                </p>
                <div className="text-sm text-gray-500 dark:text-gray-500">
                  <p>User ID: {user?.id}</p>
                  <p>Email: {user?.email}</p>
                  <p>Role: {user?.role}</p>
                </div>
              </div>
            </div>
          </div>
        )
    }
  }

  return (
    <div className="space-y-6">
      {authLoading ? (
        <div className="flex items-center justify-center h-64">
          <div className="loading-spinner"></div>
        </div>
      ) : (
        <>
          {/* Welcome Header */}
          <div className="bg-white dark:bg-gray-800 overflow-hidden shadow rounded-lg">
            <div className="px-4 py-5 sm:p-6">
              <div className="flex items-center justify-between">
                <div>
                  <h1 className="text-2xl font-bold text-gray-900 dark:text-white">
                    Welcome back, {user?.preferredName || user?.name}!
                  </h1>
                  <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
                    Here's what's happening with your contests today.
                  </p>
                </div>
                <div className="flex items-center space-x-2">
                  <div className={`w-3 h-3 rounded-full ${isConnected ? 'bg-green-400' : 'bg-red-400'}`}></div>
                  <span className="text-sm text-gray-500 dark:text-gray-400">
                    {isConnected ? 'Live' : 'Offline'}
                  </span>
                </div>
              </div>
            </div>
          </div>

          {/* Role-specific content */}
          {getRoleSpecificContent()}
        </>
      )}
    </div>
  )
}

export default Dashboard
EOF

    cat > "$APP_DIR/frontend/src/App.tsx" << 'EOF'
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom'
import { QueryClient, QueryClientProvider } from 'react-query'
import { AuthProvider } from './contexts/AuthContext'
import { SocketProvider } from './contexts/SocketContext'
import { ThemeProvider } from './contexts/ThemeContext'
import Layout from './components/Layout'
import LoginPage from './pages/LoginPage'
import Dashboard from './pages/Dashboard'
import EventsPage from './pages/EventsPage'
import ContestsPage from './pages/ContestsPage'
import CategoriesPage from './pages/CategoriesPage'
import ScoringPage from './pages/ScoringPage'
import ResultsPage from './pages/ResultsPage'
import UsersPage from './pages/UsersPage'
import AdminPage from './pages/AdminPage'
import SettingsPage from './pages/SettingsPage'
import ProfilePage from './pages/ProfilePage'
import EmceePage from './pages/EmceePage'
import TemplatesPage from './pages/TemplatesPage'
import ReportsPage from './pages/ReportsPage'
import WinnersPage from './pages/WinnersPage'
import ProtectedRoute from './components/ProtectedRoute'
import ErrorBoundary from './components/ErrorBoundary'
import './index.css'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retry: 1,
      refetchOnWindowFocus: false,
    },
  },
})

function App() {
  return (
    <ErrorBoundary>
      <QueryClientProvider client={queryClient}>
        <ThemeProvider>
          <Router>
            <AuthProvider>
              <SocketProvider>
                <div className="min-h-screen bg-gray-50 dark:bg-gray-900">
                  <Routes>
                    <Route path="/login" element={<LoginPage />} />
                    <Route
                      path="/*"
                      element={
                        <ProtectedRoute>
                          <Layout>
                            <Routes>
                              <Route path="/" element={<Navigate to="/dashboard" replace />} />
                              <Route path="/dashboard" element={<Dashboard />} />
                              <Route path="/events" element={<EventsPage />} />
                              <Route path="/events/:eventId/contests" element={<ContestsPage />} />
                              <Route path="/contests/:contestId/categories" element={<CategoriesPage />} />
                              <Route path="/scoring" element={<ScoringPage />} />
                              <Route path="/results" element={<ResultsPage />} />
                              <Route path="/users" element={<UsersPage />} />
                              <Route path="/admin" element={<AdminPage />} />
                              <Route path="/settings" element={<SettingsPage />} />
                              <Route path="/profile" element={<ProfilePage />} />
                              <Route path="/emcee" element={<EmceePage />} />
                              <Route path="/templates" element={<TemplatesPage />} />
                              <Route path="/reports" element={<ReportsPage />} />
                              <Route path="/winners" element={<WinnersPage />} />
                            </Routes>
                          </Layout>
                        </ProtectedRoute>
                      }
                    />
                  </Routes>
                </div>
            </SocketProvider>
          </AuthProvider>
          </Router>
        </ThemeProvider>
      </QueryClientProvider>
    </ErrorBoundary>
  )
}

export default App
EOF

    cat > "$APP_DIR/frontend/src/index.css" << 'EOF'
@tailwind base;
@tailwind components;
@tailwind utilities;

/* CSS Variables for theming */
:root {
  --color-primary: 99 102 241;
  --color-primary-dark: 79 70 229;
  --color-secondary: 16 185 129;
  --color-accent: 245 158 11;
  --color-danger: 239 68 68;
  --color-warning: 245 158 11;
  --color-success: 16 185 129;
  --color-info: 59 130 246;
}

.dark {
  --color-primary: 129 140 248;
  --color-primary-dark: 99 102 241;
  --color-secondary: 52 211 153;
  --color-accent: 251 191 36;
  --color-danger: 248 113 113;
  --color-warning: 251 191 36;
  --color-success: 52 211 153;
  --color-info: 96 165 250;
}

/* Base styles */
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  background-color: rgb(249 250 251);
  color: rgb(17 24 39);
}

.dark body {
  background-color: rgb(17 24 39);
  color: rgb(243 244 246);
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

/* Custom utility classes */
@layer components {
  .btn {
    @apply inline-flex items-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2 transition-colors duration-200;
  }

  .btn-primary {
    @apply btn text-white bg-indigo-600 hover:bg-indigo-700 focus:ring-indigo-500;
  }

  .btn-secondary {
    @apply btn text-gray-700 bg-white hover:bg-gray-50 focus:ring-indigo-500 border-gray-300;
  }

  .btn-danger {
    @apply btn text-white bg-red-600 hover:bg-red-700 focus:ring-red-500;
  }

  .btn-success {
    @apply btn text-white bg-green-600 hover:bg-green-700 focus:ring-green-500;
  }

  .btn-warning {
    @apply btn text-white bg-yellow-600 hover:bg-yellow-700 focus:ring-yellow-500;
  }

  .btn-sm {
    @apply px-3 py-1.5 text-xs;
  }

  .btn-lg {
    @apply px-6 py-3 text-base;
  }

  .card {
    @apply bg-white dark:bg-gray-800 overflow-hidden shadow rounded-lg;
  }

  .card-header {
    @apply px-4 py-5 sm:px-6 border-b border-gray-200 dark:border-gray-700;
  }

  .card-body {
    @apply px-4 py-5 sm:p-6;
  }

  .card-footer {
    @apply px-4 py-4 sm:px-6 border-t border-gray-200 dark:border-gray-700;
  }

  .input {
    @apply block w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm placeholder-gray-400 dark:placeholder-gray-500 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 dark:bg-gray-700 dark:text-white sm:text-sm;
  }

  .input-error {
    @apply border-red-300 dark:border-red-600 focus:ring-red-500 focus:border-red-500;
  }

  .label {
    @apply block text-sm font-medium text-gray-700 dark:text-gray-300;
  }

  .label-required::after {
    content: ' *';
    @apply text-red-500;
  }

  .badge {
    @apply inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium;
  }

  .badge-primary {
    @apply badge bg-indigo-100 text-indigo-800 dark:bg-indigo-900 dark:text-indigo-200;
  }

  .badge-secondary {
    @apply badge bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-200;
  }

  .badge-success {
    @apply badge bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200;
  }

  .badge-warning {
    @apply badge bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200;
  }

  .badge-danger {
    @apply badge bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200;
  }

  .table {
    @apply min-w-full divide-y divide-gray-200 dark:divide-gray-700;
  }

  .table-header {
    @apply bg-gray-50 dark:bg-gray-800;
  }

  .table-header-cell {
    @apply px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider;
  }

  .table-body {
    @apply bg-white dark:bg-gray-900 divide-y divide-gray-200 dark:divide-gray-700;
  }

  .table-cell {
    @apply px-6 py-4 whitespace-nowrap text-sm text-gray-900 dark:text-gray-100;
  }

  .alert {
    @apply rounded-md p-4;
  }

  .alert-info {
    @apply alert bg-blue-50 dark:bg-blue-900 border border-blue-200 dark:border-blue-700;
  }

  .alert-success {
    @apply alert bg-green-50 dark:bg-green-900 border border-green-200 dark:border-green-700;
  }

  .alert-warning {
    @apply alert bg-yellow-50 dark:bg-yellow-900 border border-yellow-200 dark:border-yellow-700;
  }

  .alert-danger {
    @apply alert bg-red-50 dark:bg-red-900 border border-red-200 dark:border-red-700;
  }

  .sidebar {
    @apply flex flex-col w-64 bg-white dark:bg-gray-800 border-r border-gray-200 dark:border-gray-700;
  }

  .sidebar-item {
    @apply flex items-center px-2 py-2 text-sm font-medium rounded-md transition-colors duration-200;
  }

  .sidebar-item-active {
    @apply sidebar-item bg-gray-100 dark:bg-gray-700 text-gray-900 dark:text-white;
  }

  .sidebar-item-inactive {
    @apply sidebar-item text-gray-600 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700 hover:text-gray-900 dark:hover:text-white;
  }

  .mobile-menu {
    @apply fixed inset-0 z-50 lg:hidden;
  }

  .mobile-menu-overlay {
    @apply fixed inset-0 bg-black/50;
  }

  .mobile-menu-content {
    @apply fixed top-0 left-0 h-full w-80 bg-white dark:bg-gray-800 border-r shadow-lg;
  }

  .dropdown {
    @apply origin-top-right absolute right-0 mt-2 w-48 rounded-md shadow-lg py-1 bg-white dark:bg-gray-800 ring-1 ring-black ring-opacity-5 focus:outline-none;
  }

  .dropdown-item {
    @apply block px-4 py-2 text-sm text-gray-700 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-700;
  }

  .modal-overlay {
    @apply fixed inset-0 bg-gray-600 bg-opacity-75 overflow-y-auto h-full w-full z-50;
  }

  .modal {
    @apply relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white dark:bg-gray-800;
  }

  .loading-spinner {
    @apply animate-spin rounded-full border-b-2 border-indigo-600;
  }

  .status-indicator {
    @apply inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium;
  }

  .status-online {
    @apply status-indicator bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200;
  }

  .status-offline {
    @apply status-indicator bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-200;
  }

  .status-pending {
    @apply status-indicator bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200;
  }

  .status-error {
    @apply status-indicator bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200;
  }

  .scoring-input {
    @apply w-20 px-2 py-1 text-center border border-gray-300 dark:border-gray-600 rounded focus:outline-none focus:ring-2 focus:ring-indigo-500 dark:bg-gray-700 dark:text-white;
  }

  .certification-badge {
    @apply inline-flex items-center px-2 py-1 rounded-full text-xs font-medium;
  }

  .certification-pending {
    @apply certification-badge bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200;
  }

  .certification-approved {
    @apply certification-badge bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200;
  }

  .certification-rejected {
    @apply certification-badge bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200;
  }

  .role-badge {
    @apply inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium;
  }

  .role-organizer {
    @apply role-badge bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200;
  }

  .role-board {
    @apply role-badge bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-200;
  }

  .role-judge {
    @apply role-badge bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200;
  }

  .role-contestant {
    @apply role-badge bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200;
  }

  .role-emcee {
    @apply role-badge bg-pink-100 text-pink-800 dark:bg-pink-900 dark:text-pink-200;
  }

  .role-tally-master {
    @apply role-badge bg-indigo-100 text-indigo-800 dark:bg-indigo-900 dark:text-indigo-200;
  }

  .role-auditor {
    @apply role-badge bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200;
  }
}

/* Print styles */
@media print {
  .no-print {
    display: none !important;
  }
  
  .print-break {
    page-break-before: always;
  }
  
  .print-break-after {
    page-break-after: always;
  }
  
  .print-break-inside-avoid {
    page-break-inside: avoid;
  }
  
  body {
    background: white !important;
    color: black !important;
  }
  
  .card {
    box-shadow: none !important;
    border: 1px solid #ccc !important;
  }
  
  .btn {
    display: none !important;
  }
}

/* Responsive grid utilities */
.grid-responsive {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 1rem;
}

.grid-responsive-sm {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 0.75rem;
}

.grid-responsive-lg {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 1.5rem;
}

/* Animation utilities */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.animate-fade-in {
  animation: fadeIn 0.3s ease-out;
}

@keyframes slideIn {
  from {
    transform: translateX(-100%);
  }
  to {
    transform: translateX(0);
  }
}

.animate-slide-in {
  animation: slideIn 0.3s ease-out;
}

@keyframes pulse {
  0%, 100% {
    opacity: 1;
  }
  50% {
    opacity: 0.5;
  }
}

.animate-pulse-slow {
  animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

/* Custom scrollbar */
::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: rgb(243 244 246);
}

.dark ::-webkit-scrollbar-track {
  background: rgb(31 41 55);
}

::-webkit-scrollbar-thumb {
  background: rgb(156 163 175);
  border-radius: 4px;
}

.dark ::-webkit-scrollbar-thumb {
  background: rgb(75 85 99);
}

::-webkit-scrollbar-thumb:hover {
  background: rgb(107 114 128);
}

.dark ::-webkit-scrollbar-thumb:hover {
  background: rgb(107 114 128);
}

/* Focus styles */
.focus-ring {
  @apply focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 dark:focus:ring-offset-gray-800;
}

/* Dark mode transitions */
* {
  transition: background-color 0.2s ease-in-out, border-color 0.2s ease-in-out, color 0.2s ease-in-out;
}

/* High contrast mode support */
@media (prefers-contrast: high) {
  .card {
    border: 2px solid currentColor;
  }
  
  .btn {
    border: 2px solid currentColor;
  }
}

/* Reduced motion support */
@media (prefers-reduced-motion: reduce) {
  * {
    animation-duration: 0.01ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: 0.01ms !important;
  }
}
EOF
    # Create placeholder pages for all routes
    cat > "$APP_DIR/frontend/src/pages/EventsPage.tsx" << 'EOF'
import React, { useState } from 'react'
import { useQuery, useMutation, useQueryClient } from 'react-query'
import { eventsAPI, archiveAPI } from '../services/api'
import { useAuth } from '../contexts/AuthContext'
import DataTable from '../components/DataTable'
import SearchFilter from '../components/SearchFilter'
import ArchiveManager from '../components/ArchiveManager'
import { PlusIcon, PencilIcon, TrashIcon, ArchiveBoxIcon, EyeIcon, XMarkIcon } from '@heroicons/react/24/outline'
import { format } from 'date-fns'

interface Event {
  id: string
  name: string
  description: string
  startDate: string
  endDate: string
  location: string
  maxContestants: number
  status: 'DRAFT' | 'ACTIVE' | 'COMPLETED' | 'ARCHIVED'
  createdAt: string
  updatedAt: string
  _count?: {
    contests: number
    contestants: number
  }
}

const EventsPage: React.FC = () => {
  const { user } = useAuth()
  const [showModal, setShowModal] = useState(false)
  const [showArchiveModal, setShowArchiveModal] = useState(false)
  const [editingEvent, setEditingEvent] = useState<Event | null>(null)
  const [formData, setFormData] = useState<Partial<Event>>({})
  const [searchTerm, setSearchTerm] = useState('')
  const [statusFilter, setStatusFilter] = useState('')
  const queryClient = useQueryClient()

  const { data: events, isLoading } = useQuery(
    'events',
    () => eventsAPI.getAll().then((res: any) => res.data),
    { 
      refetchInterval: 300000, // Refresh every 5 minutes (reduced from 30 seconds)
      refetchOnWindowFocus: false,
      staleTime: 120000
    }
  )

  const createMutation = useMutation(
    (data: Partial<Event>) => eventsAPI.create(data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('events')
        setShowModal(false)
        setFormData({})
      }
    }
  )

  const updateMutation = useMutation(
    ({ id, data }: { id: string; data: Partial<Event> }) => eventsAPI.update(id, data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('events')
        setShowModal(false)
        setEditingEvent(null)
        setFormData({})
      }
    }
  )

  const deleteMutation = useMutation(
    (id: string) => eventsAPI.delete(id),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('events')
      }
    }
  )

  const archiveMutation = useMutation(
    ({ id, reason }: { id: string; reason: string }) => archiveAPI.archiveEvent(id, reason),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('events')
        setShowArchiveModal(false)
      }
    }
  )

  const handleCreate = () => {
    setEditingEvent(null)
    setFormData({
      name: '',
      description: '',
      startDate: '',
      endDate: '',
      location: '',
      maxContestants: 100,
      status: 'DRAFT'
    })
    setShowModal(true)
  }

  const handleEdit = (event: Event) => {
    setEditingEvent(event)
    setFormData(event)
    setShowModal(true)
  }

  const handleDelete = (id: string) => {
    if (confirm('Are you sure you want to delete this event?')) {
      deleteMutation.mutate(id)
    }
  }

  const handleArchive = (event: Event) => {
    setEditingEvent(event)
    setShowArchiveModal(true)
  }

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    if (editingEvent) {
      updateMutation.mutate({ id: editingEvent.id, data: formData })
    } else {
      createMutation.mutate(formData)
    }
  }

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'DRAFT': return 'bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200'
      case 'ACTIVE': return 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
      case 'COMPLETED': return 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200'
      case 'ARCHIVED': return 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200'
      default: return 'bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200'
    }
  }

  const getStatusText = (status: string) => {
    switch (status) {
      case 'DRAFT': return 'Draft'
      case 'ACTIVE': return 'Active'
      case 'COMPLETED': return 'Completed'
      case 'ARCHIVED': return 'Archived'
      default: return status
    }
  }

  const filteredEvents = events?.filter((event: Event) => {
    const matchesSearch = event.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                         event.description.toLowerCase().includes(searchTerm.toLowerCase()) ||
                         event.location.toLowerCase().includes(searchTerm.toLowerCase())
    const matchesStatus = !statusFilter || event.status === statusFilter
    return matchesSearch && matchesStatus
  }) || []

  const eventColumns = [
    { key: 'name', label: 'Event Name', sortable: true },
    { key: 'location', label: 'Location', sortable: true },
    { key: 'startDate', label: 'Start Date', sortable: true, render: (value: string) => format(new Date(value), 'MMM dd, yyyy') },
    { key: 'endDate', label: 'End Date', sortable: true, render: (value: string) => format(new Date(value), 'MMM dd, yyyy') },
    { key: 'status', label: 'Status', sortable: true, render: (value: string) => (
      <span className={`status-indicator ${getStatusColor(value)}`}>
        {getStatusText(value)}
      </span>
    ) },
    { key: '_count.contests', label: 'Contests', sortable: true, render: (value: number) => value || 0 },
    { key: '_count.contestants', label: 'Contestants', sortable: true, render: (value: number) => value || 0 },
    { key: 'actions', label: 'Actions', render: (value: any, row: Event) => (
      <div className="flex space-x-2">
        <button
          onClick={() => handleEdit(row)}
          className="btn-sm btn-outline"
          title="Edit Event"
        >
          <PencilIcon className="h-4 w-4" />
        </button>
        <button
          onClick={() => handleArchive(row)}
          className="btn-sm btn-outline"
          title="Archive Event"
        >
          <ArchiveBoxIcon className="h-4 w-4" />
        </button>
        <button
          onClick={() => handleDelete(row.id)}
          className="btn-sm btn-destructive"
          title="Delete Event"
        >
          <TrashIcon className="h-4 w-4" />
        </button>
      </div>
    )}
  ]

  return (
    <div className="space-y-6">
      <div className="card">
        <div className="card-header">
          <div className="flex justify-between items-center">
            <div>
              <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Events Management</h1>
              <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
                Create and manage contest events
              </p>
            </div>
            {(user?.role === 'ORGANIZER' || user?.role === 'BOARD') && (
              <button
                onClick={handleCreate}
                className="btn-primary"
              >
                <PlusIcon className="h-5 w-5 mr-2" />
                Create Event
              </button>
            )}
          </div>
        </div>
        <div className="card-body">
          <div className="mb-6">
            <SearchFilter
              searchTerm={searchTerm}
              onSearchChange={setSearchTerm}
              filters={{
                status: {
                  label: 'Status',
                  options: [
                    { value: '', label: 'All Statuses' },
                    { value: 'DRAFT', label: 'Draft' },
                    { value: 'ACTIVE', label: 'Active' },
                    { value: 'COMPLETED', label: 'Completed' },
                    { value: 'ARCHIVED', label: 'Archived' }
                  ],
                  value: statusFilter,
                  onChange: setStatusFilter
                }
              }}
              placeholder="Search events..."
            />
          </div>
          
          <DataTable
            data={filteredEvents}
            columns={eventColumns}
            loading={isLoading}
            searchable={false}
            pagination={true}
            pageSize={10}
          />
        </div>
      </div>

      {/* Create/Edit Modal */}
      {showModal && (
        <div className="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
          <div className="relative top-20 mx-auto p-5 border w-full max-w-3xl shadow-lg rounded-md bg-white dark:bg-gray-800">
            <div className="mt-3">
              <div className="flex items-center justify-between mb-6">
                <h3 className="text-lg font-medium text-gray-900 dark:text-white">
                  {editingEvent ? 'Edit Event' : 'Create Event'}
                </h3>
                <button
                  onClick={() => setShowModal(false)}
                  className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
                >
                  <XMarkIcon className="h-6 w-6" />
                </button>
              </div>
              
              <form onSubmit={handleSubmit} className="space-y-6">
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                    Event Name *
                  </label>
                  <input
                    type="text"
                    value={formData.name || ''}
                    onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                    className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white"
                    placeholder="Enter event name"
                    required
                  />
                </div>
                
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                    Description
                  </label>
                  <textarea
                    value={formData.description || ''}
                    onChange={(e) => setFormData({ ...formData, description: e.target.value })}
                    className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white"
                    rows={3}
                    placeholder="Enter event description"
                  />
                </div>
                
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                      Start Date *
                    </label>
                    <input
                      type="datetime-local"
                      value={formData.startDate || ''}
                      onChange={(e) => setFormData({ ...formData, startDate: e.target.value })}
                      className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white"
                      required
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                      End Date *
                    </label>
                    <input
                      type="datetime-local"
                      value={formData.endDate || ''}
                      onChange={(e) => setFormData({ ...formData, endDate: e.target.value })}
                      className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white"
                      required
                    />
                  </div>
                </div>
                
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                      Location *
                    </label>
                    <input
                      type="text"
                      value={formData.location || ''}
                      onChange={(e) => setFormData({ ...formData, location: e.target.value })}
                      className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white"
                      placeholder="Enter event location"
                      required
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                      Max Contestants *
                    </label>
                    <input
                      type="number"
                      value={formData.maxContestants || 100}
                      onChange={(e) => setFormData({ ...formData, maxContestants: parseInt(e.target.value) })}
                      className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white"
                      min="1"
                      required
                    />
                  </div>
                </div>
                
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                    Status
                  </label>
                  <select
                    value={formData.status || 'DRAFT'}
                    onChange={(e) => setFormData({ ...formData, status: e.target.value as any })}
                    className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white"
                  >
                    <option value="DRAFT">Draft</option>
                    <option value="ACTIVE">Active</option>
                    <option value="COMPLETED">Completed</option>
                    <option value="ARCHIVED">Archived</option>
                  </select>
                </div>

                <div className="flex justify-end space-x-3 pt-4 border-t border-gray-200 dark:border-gray-600">
                  <button
                    type="button"
                    onClick={() => setShowModal(false)}
                    className="px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md hover:bg-gray-200 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500"
                  >
                    Cancel
                  </button>
                  <button
                    type="submit"
                    disabled={createMutation.isLoading || updateMutation.isLoading}
                    className="px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-transparent rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    {createMutation.isLoading || updateMutation.isLoading ? (
                      <span className="flex items-center">
                        <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        Saving...
                      </span>
                    ) : (
                      'Save Event'
                    )}
                  </button>
                </div>
              </form>
            </div>
          </div>
        </div>
      )}

      {/* Archive Modal */}
      {showArchiveModal && editingEvent && (
        <div className="modal">
          <div className="modal-overlay" onClick={() => setShowArchiveModal(false)} />
          <div className="modal-content">
            <h2 className="text-xl font-bold mb-4">Archive Event</h2>
            <p className="mb-4">Are you sure you want to archive "{editingEvent.name}"?</p>
            <form onSubmit={(e) => {
              e.preventDefault()
              const reason = (e.target as any).reason.value
              archiveMutation.mutate({ id: editingEvent.id, reason })
            }} className="space-y-4">
              <div>
                <label className="label">Archive Reason</label>
                <textarea
                  name="reason"
                  className="input"
                  rows={3}
                  placeholder="Enter reason for archiving..."
                  required
                />
              </div>
              <div className="flex justify-end space-x-2">
                <button
                  type="button"
                  onClick={() => setShowArchiveModal(false)}
                  className="btn-secondary"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  className="btn-destructive"
                  disabled={archiveMutation.isLoading}
                >
                  {archiveMutation.isLoading ? 'Archiving...' : 'Archive Event'}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}
    </div>
  )
}

export default EventsPage
EOF

    cat > "$APP_DIR/frontend/src/pages/ContestsPage.tsx" << 'EOF'
import React, { useState } from 'react'
import { useParams } from 'react-router-dom'
import { useQuery, useMutation, useQueryClient } from 'react-query'
import { contestsAPI } from '../services/api'
import { PlusIcon, PencilIcon, TrashIcon } from '@heroicons/react/24/outline'

interface Contest {
  id: string
  name: string
  description: string
  startDate: string
  endDate: string
  maxContestants: number
  status: 'DRAFT' | 'ACTIVE' | 'COMPLETED' | 'ARCHIVED'
  eventId: string
  createdAt: string
  updatedAt: string
}

const ContestsPage: React.FC = () => {
  const { eventId } = useParams<{ eventId: string }>()
  const [showModal, setShowModal] = useState(false)
  const [editingContest, setEditingContest] = useState<Contest | null>(null)
  const [formData, setFormData] = useState<Partial<Contest>>({})
  const queryClient = useQueryClient()

  const { data: contests, isLoading } = useQuery(
    ['contests', eventId],
    () => contestsAPI.getByEvent(eventId!).then(res => res.data),
    { enabled: !!eventId }
  )

  const createMutation = useMutation(
    (data: Partial<Contest>) => contestsAPI.create(eventId!, data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['contests', eventId])
        setShowModal(false)
        setFormData({})
      }
    }
  )

  const updateMutation = useMutation(
    ({ id, data }: { id: string; data: Partial<Contest> }) => 
      contestsAPI.update(id, data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['contests', eventId])
        setShowModal(false)
        setEditingContest(null)
        setFormData({})
      }
    }
  )

  const deleteMutation = useMutation(
    (id: string) => contestsAPI.delete(id),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['contests', eventId])
      }
    }
  )

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    if (editingContest) {
      updateMutation.mutate({ id: editingContest.id, data: formData })
    } else {
      createMutation.mutate(formData)
    }
  }

  const handleEdit = (contest: Contest) => {
    setEditingContest(contest)
    setFormData(contest)
    setShowModal(true)
  }

  const handleDelete = (id: string) => {
    if (confirm('Are you sure you want to delete this contest?')) {
      deleteMutation.mutate(id)
    }
  }

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="loading-spinner"></div>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      <div className="card">
        <div className="card-header">
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Contests Management</h1>
          <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
            Create and manage contests within events
          </p>
        </div>
        <div className="card-body">
          <div className="flex justify-between items-center mb-6">
            <h2 className="text-lg font-semibold">Contests</h2>
            <button
              onClick={() => setShowModal(true)}
              className="btn btn-primary"
            >
              <PlusIcon className="h-5 w-5 mr-2" />
              Add Contest
            </button>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {contests?.map((contest: Contest) => (
              <div key={contest.id} className="card">
                <div className="card-header">
                  <h3 className="font-semibold">{contest.name}</h3>
                  <p className="text-sm text-gray-600 dark:text-gray-400">
                    {contest.description}
                  </p>
                </div>
                <div className="card-body">
                  <div className="space-y-2">
                    <p className="text-sm">
                      <span className="font-medium">Status:</span> {contest.status}
                    </p>
                    <p className="text-sm">
                      <span className="font-medium">Max Contestants:</span> {contest.maxContestants}
                    </p>
                    <p className="text-sm">
                      <span className="font-medium">Start:</span> {new Date(contest.startDate).toLocaleDateString()}
                    </p>
                    <p className="text-sm">
                      <span className="font-medium">End:</span> {new Date(contest.endDate).toLocaleDateString()}
                    </p>
                  </div>
                </div>
                <div className="card-footer">
                  <div className="flex space-x-2">
                    <button
                      onClick={() => handleEdit(contest)}
                      className="btn btn-outline btn-sm"
                    >
                      <PencilIcon className="h-4 w-4" />
                    </button>
                    <button
                      onClick={() => handleDelete(contest.id)}
                      className="btn btn-destructive btn-sm"
                    >
                      <TrashIcon className="h-4 w-4" />
                    </button>
                  </div>
                </div>
              </div>
            ))}
          </div>
        </div>
      </div>

      {/* Modal */}
      {showModal && (
        <div className="modal">
          <div className="modal-overlay" onClick={() => setShowModal(false)}></div>
          <div className="modal-content">
            <h2 className="text-xl font-bold mb-4">
              {editingContest ? 'Edit Contest' : 'Add Contest'}
            </h2>
            <form onSubmit={handleSubmit} className="space-y-4">
              <div>
                <label className="label">Name</label>
                <input
                  type="text"
                  value={formData.name || ''}
                  onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                  className="input"
                  required
                />
              </div>
              <div>
                <label className="label">Description</label>
                <textarea
                  value={formData.description || ''}
                  onChange={(e) => setFormData({ ...formData, description: e.target.value })}
                  className="input"
                  rows={3}
                />
              </div>
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <label className="label">Start Date</label>
                  <input
                    type="date"
                    value={formData.startDate || ''}
                    onChange={(e) => setFormData({ ...formData, startDate: e.target.value })}
                    className="input"
                    required
                  />
                </div>
                <div>
                  <label className="label">End Date</label>
                  <input
                    type="date"
                    value={formData.endDate || ''}
                    onChange={(e) => setFormData({ ...formData, endDate: e.target.value })}
                    className="input"
                    required
                  />
                </div>
              </div>
              <div>
                <label className="label">Max Contestants</label>
                <input
                  type="number"
                  value={formData.maxContestants || ''}
                  onChange={(e) => setFormData({ ...formData, maxContestants: parseInt(e.target.value) })}
                  className="input"
                  min="1"
                  required
                />
              </div>
              <div className="flex justify-end space-x-2">
                <button
                  type="button"
                  onClick={() => setShowModal(false)}
                  className="btn btn-outline"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  className="btn btn-primary"
                  disabled={createMutation.isLoading || updateMutation.isLoading}
                >
                  {editingContest ? 'Update' : 'Create'}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}
    </div>
  )
}

export default ContestsPage
EOF

    cat > "$APP_DIR/frontend/src/pages/CategoriesPage.tsx" << 'EOF'
import React, { useState } from 'react'
import { useParams } from 'react-router-dom'
import { useQuery, useMutation, useQueryClient } from 'react-query'
import { categoriesAPI, contestsAPI } from '../services/api'
import { useAuth } from '../contexts/AuthContext'
import DataTable from '../components/DataTable'
import SearchFilter from '../components/SearchFilter'
import CategoryTemplates from '../components/CategoryTemplates'
import { PlusIcon, PencilIcon, TrashIcon, EyeIcon, DocumentDuplicateIcon } from '@heroicons/react/24/outline'

interface Category {
  id: string
  name: string
  description: string
  maxScore: number
  order: number
  contestId: string
  createdAt: string
  updatedAt: string
  _count?: {
    criteria: number
    contestants: number
    judges: number
    scores: number
  }
  criteria?: Criterion[]
  contest?: {
    id: string
    name: string
    event?: {
      id: string
      name: string
    }
  }
}

interface Criterion {
  id: string
  name: string
  description: string
  maxScore: number
  order: number
  categoryId: string
}

const CategoriesPage: React.FC = () => {
  const { contestId } = useParams<{ contestId: string }>()
  const { user } = useAuth()
  const [showModal, setShowModal] = useState(false)
  const [showTemplatesModal, setShowTemplatesModal] = useState(false)
  const [editingCategory, setEditingCategory] = useState<Category | null>(null)
  const [formData, setFormData] = useState<Partial<Category>>({})
  const [searchTerm, setSearchTerm] = useState('')
  const queryClient = useQueryClient()

  const { data: categories, isLoading } = useQuery(
    ['categories', contestId],
    () => categoriesAPI.getByContest(contestId!).then((res: any) => res.data),
    { enabled: !!contestId, refetchInterval: 300000, refetchOnWindowFocus: false, staleTime: 120000 }
  )

  const { data: contest } = useQuery(
    ['contest', contestId],
    () => contestsAPI.getById(contestId!).then((res: any) => res.data),
    { enabled: !!contestId }
  )

  const createMutation = useMutation(
    (data: Partial<Category>) => categoriesAPI.create(contestId!, data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['categories', contestId])
        setShowModal(false)
        setFormData({})
      }
    }
  )

  const updateMutation = useMutation(
    ({ id, data }: { id: string; data: Partial<Category> }) => categoriesAPI.update(id, data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['categories', contestId])
        setShowModal(false)
        setEditingCategory(null)
        setFormData({})
      }
    }
  )

  const deleteMutation = useMutation(
    (id: string) => categoriesAPI.delete(id),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['categories', contestId])
      }
    }
  )

  const handleCreate = () => {
    setEditingCategory(null)
    setFormData({
      name: '',
      description: '',
      maxScore: 100,
      order: (categories?.length || 0) + 1,
      contestId: contestId!
    })
    setShowModal(true)
  }

  const handleEdit = (category: Category) => {
    setEditingCategory(category)
    setFormData(category)
    setShowModal(true)
  }

  const handleDelete = (id: string) => {
    if (confirm('Are you sure you want to delete this category? This will also delete all associated scores.')) {
      deleteMutation.mutate(id)
    }
  }

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    if (editingCategory) {
      updateMutation.mutate({ id: editingCategory.id, data: formData })
    } else {
      createMutation.mutate(formData)
    }
  }

  const filteredCategories = categories?.filter((category: Category) => {
    return category.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
           category.description.toLowerCase().includes(searchTerm.toLowerCase())
  }) || []

  const categoryColumns = [
    { key: 'order', label: 'Order', sortable: true },
    { key: 'name', label: 'Category Name', sortable: true },
    { key: 'description', label: 'Description', sortable: true },
    { key: 'maxScore', label: 'Max Score', sortable: true },
    { key: '_count.criteria', label: 'Criteria', sortable: true, render: (value: number) => value || 0 },
    { key: '_count.contestants', label: 'Contestants', sortable: true, render: (value: number) => value || 0 },
    { key: '_count.judges', label: 'Judges', sortable: true, render: (value: number) => value || 0 },
    { key: '_count.scores', label: 'Scores', sortable: true, render: (value: number) => value || 0 },
    { key: 'actions', label: 'Actions', render: (value: any, row: Category) => (
      <div className="flex space-x-2">
        <button
          onClick={() => handleEdit(row)}
          className="btn-sm btn-outline"
          title="Edit Category"
        >
          <PencilIcon className="h-4 w-4" />
        </button>
        <button
          onClick={() => handleDelete(row.id)}
          className="btn-sm btn-destructive"
          title="Delete Category"
        >
          <TrashIcon className="h-4 w-4" />
        </button>
      </div>
    )}
  ]

  return (
    <div className="space-y-6">
      <div className="card">
        <div className="card-header">
          <div className="flex justify-between items-center">
            <div>
              <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Categories Management</h1>
              <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
                {contest ? `Categories for ${contest.name}` : 'Create and manage contest categories'}
              </p>
            </div>
            <div className="flex space-x-2">
              {(user?.role === 'ORGANIZER' || user?.role === 'BOARD') && (
                <>
                  <button
                    onClick={() => setShowTemplatesModal(true)}
                    className="btn-secondary"
                  >
                    <DocumentDuplicateIcon className="h-5 w-5 mr-2" />
                    Templates
                  </button>
                  <button
                    onClick={handleCreate}
                    className="btn-primary"
                  >
                    <PlusIcon className="h-5 w-5 mr-2" />
                    Create Category
                  </button>
                </>
              )}
            </div>
          </div>
        </div>
        <div className="card-body">
          <div className="mb-6">
            <SearchFilter
              searchTerm={searchTerm}
              onSearchChange={setSearchTerm}
              placeholder="Search categories..."
            />
          </div>
          
          <DataTable
            data={filteredCategories}
            columns={categoryColumns}
            loading={isLoading}
            searchable={false}
            pagination={true}
            pageSize={10}
          />
        </div>
      </div>

      {/* Create/Edit Modal */}
      {showModal && (
        <div className="modal">
          <div className="modal-overlay" onClick={() => setShowModal(false)} />
          <div className="modal-content">
            <h2 className="text-xl font-bold mb-4">
              {editingCategory ? 'Edit Category' : 'Create Category'}
            </h2>
            <form onSubmit={handleSubmit} className="space-y-4">
              <div>
                <label className="label">Category Name</label>
                <input
                  type="text"
                  value={formData.name || ''}
                  onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                  className="input"
                  required
                />
              </div>
              <div>
                <label className="label">Description</label>
                <textarea
                  value={formData.description || ''}
                  onChange={(e) => setFormData({ ...formData, description: e.target.value })}
                  className="input"
                  rows={3}
                />
              </div>
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <label className="label">Max Score</label>
                  <input
                    type="number"
                    value={formData.maxScore || 100}
                    onChange={(e) => setFormData({ ...formData, maxScore: parseInt(e.target.value) })}
                    className="input"
                    min="1"
                    required
                  />
                </div>
                <div>
                  <label className="label">Order</label>
                  <input
                    type="number"
                    value={formData.order || 1}
                    onChange={(e) => setFormData({ ...formData, order: parseInt(e.target.value) })}
                    className="input"
                    min="1"
                    required
                  />
                </div>
              </div>
              <div className="flex justify-end space-x-2">
                <button
                  type="button"
                  onClick={() => setShowModal(false)}
                  className="btn-secondary"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  className="btn-primary"
                  disabled={createMutation.isLoading || updateMutation.isLoading}
                >
                  {createMutation.isLoading || updateMutation.isLoading ? 'Saving...' : 'Save'}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}

      {/* Templates Modal */}
      {showTemplatesModal && (
        <div className="modal">
          <div className="modal-overlay" onClick={() => setShowTemplatesModal(false)} />
          <div className="modal-content max-w-4xl">
            <h2 className="text-xl font-bold mb-4">Category Templates</h2>
            <CategoryTemplates />
            <div className="flex justify-end mt-4">
              <button
                onClick={() => setShowTemplatesModal(false)}
                className="btn-secondary"
              >
                Close
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}

export default CategoriesPage
EOF

    cat > "$APP_DIR/frontend/src/pages/ScoringPage.tsx" << 'EOF'
import React, { useState } from 'react'
import { useQuery, useMutation, useQueryClient } from 'react-query'
import { scoringAPI, categoriesAPI, usersAPI } from '../services/api'
import { useAuth } from '../contexts/AuthContext'
import CertificationWorkflow from '../components/CertificationWorkflow'
import DataTable from '../components/DataTable'
import SearchFilter from '../components/SearchFilter'
import { CheckCircleIcon, XCircleIcon, ClockIcon, StarIcon } from '@heroicons/react/24/outline'

interface Category {
  id: string
  name: string
  description: string
  maxScore: number
  order: number
  contestId: string
  status: 'DRAFT' | 'ACTIVE' | 'COMPLETED' | 'ARCHIVED'
  _count?: {
    criteria: number
    contestants: number
    judges: number
    scores: number
  }
  criteria?: Criterion[]
  contestants?: Contestant[]
  judges?: Judge[]
}

interface Criterion {
  id: string
  name: string
  description: string
  maxScore: number
  order: number
}

interface Contestant {
  id: string
  name: string
  email: string
  contestantNumber?: string
}

interface Judge {
  id: string
  name: string
  email: string
}

interface Score {
  id: string
  score: number
  comment?: string
  createdAt: string
  updatedAt: string
  judge: Judge
  contestant: Contestant
  criterion: Criterion
  category: Category
}

const ScoringPage: React.FC = () => {
  const { user } = useAuth()
  const [selectedCategory, setSelectedCategory] = useState<Category | null>(null)
  const [showScoreModal, setShowScoreModal] = useState(false)
  const [editingScore, setEditingScore] = useState<Score | null>(null)
  const [formData, setFormData] = useState<Partial<Score>>({})
  const [searchTerm, setSearchTerm] = useState('')
  const [statusFilter, setStatusFilter] = useState('')
  const queryClient = useQueryClient()

  const { data: categories, isLoading } = useQuery(
    'scoring-categories',
    () => categoriesAPI.getAll().then((res: any) => res.data),
    { 
      refetchInterval: 300000, // Refresh every 5 minutes (reduced from 30 seconds)
      refetchOnWindowFocus: false,
      staleTime: 120000
    }
  )

  const { data: scores, isLoading: scoresLoading } = useQuery(
    ['scores', selectedCategory?.id],
    () => selectedCategory ? scoringAPI.getScores(selectedCategory.id, '').then((res: any) => res.data) : Promise.resolve([]),
    { enabled: !!selectedCategory, refetchInterval: 300000, refetchOnWindowFocus: false, staleTime: 120000 }
  )

  const submitScoreMutation = useMutation(
    ({ categoryId, contestantId, data }: { categoryId: string; contestantId: string; data: any }) =>
      scoringAPI.submitScore(categoryId, contestantId, data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['scores', selectedCategory?.id])
        setShowScoreModal(false)
        setFormData({})
      }
    }
  )

  const updateScoreMutation = useMutation(
    ({ scoreId, data }: { scoreId: string; data: any }) => scoringAPI.updateScore(scoreId, data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['scores', selectedCategory?.id])
        setShowScoreModal(false)
        setEditingScore(null)
        setFormData({})
      }
    }
  )

  const certifyMutation = useMutation(
    (categoryId: string) => scoringAPI.certifyScores(categoryId),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('scoring-categories')
        queryClient.invalidateQueries(['scores', selectedCategory?.id])
      }
    }
  )

  const handleCategorySelect = (category: Category) => {
    setSelectedCategory(category)
  }

  const handleScoreSubmit = (contestant: Contestant, criterion: Criterion, score: number, comment?: string) => {
    if (!selectedCategory) return
    
    const scoreData = {
      score,
      comment,
      criterionId: criterion.id,
      contestantId: contestant.id
    }
    
    submitScoreMutation.mutate({
      categoryId: selectedCategory.id,
      contestantId: contestant.id,
      data: scoreData
    })
  }

  const handleScoreEdit = (score: Score) => {
    setEditingScore(score)
    setFormData(score)
    setShowScoreModal(true)
  }

  const handleCertify = () => {
    if (selectedCategory && confirm('Are you sure you want to certify all scores for this category?')) {
      certifyMutation.mutate(selectedCategory.id)
    }
  }

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'DRAFT': return 'bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200'
      case 'ACTIVE': return 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
      case 'COMPLETED': return 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200'
      case 'ARCHIVED': return 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200'
      default: return 'bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200'
    }
  }

  const getStatusText = (status: string) => {
    switch (status) {
      case 'DRAFT': return 'Draft'
      case 'ACTIVE': return 'Active'
      case 'COMPLETED': return 'Completed'
      case 'ARCHIVED': return 'Archived'
      default: return status
    }
  }

  const filteredCategories = categories?.filter((category: Category) => {
    const matchesSearch = category.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                         category.description.toLowerCase().includes(searchTerm.toLowerCase())
    const matchesStatus = !statusFilter || category.status === statusFilter
    return matchesSearch && matchesStatus
  }) || []

  const categoryColumns = [
    { key: 'name', label: 'Category Name', sortable: true },
    { key: 'description', label: 'Description', sortable: true },
    { key: 'maxScore', label: 'Max Score', sortable: true },
    { key: 'status', label: 'Status', sortable: true, render: (value: string) => (
      <span className={`status-indicator ${getStatusColor(value)}`}>
        {getStatusText(value)}
      </span>
    ) },
    { key: '_count.contestants', label: 'Contestants', sortable: true, render: (value: number) => value || 0 },
    { key: '_count.scores', label: 'Scores', sortable: true, render: (value: number) => value || 0 },
    { key: 'actions', label: 'Actions', render: (value: any, row: Category) => (
      <div className="flex space-x-2">
        <button
          onClick={() => handleCategorySelect(row)}
          className="btn-sm btn-primary"
          title="Score Category"
        >
          <StarIcon className="h-4 w-4" />
        </button>
      </div>
    )}
  ]

  const getRoleSpecificContent = () => {
    if (user?.role === 'JUDGE') {
      return (
        <div className="space-y-6">
          <div className="card">
            <div className="card-header">
              <h2 className="text-xl font-bold text-gray-900 dark:text-white">Assigned Categories</h2>
              <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
                Categories you are assigned to judge
              </p>
            </div>
            <div className="card-body">
              <DataTable
                data={filteredCategories}
                columns={categoryColumns}
                loading={isLoading}
                searchable={false}
                pagination={true}
                pageSize={10}
              />
            </div>
          </div>

          {selectedCategory && (
            <div className="card">
              <div className="card-header">
                <div className="flex justify-between items-center">
                  <div>
                    <h2 className="text-xl font-bold text-gray-900 dark:text-white">
                      Scoring: {selectedCategory.name}
                    </h2>
                    <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
                      Submit scores for contestants in this category
                    </p>
                  </div>
                  <button
                    onClick={() => setSelectedCategory(null)}
                    className="btn-secondary"
                  >
                    Back to Categories
                  </button>
                </div>
              </div>
              <div className="card-body">
                <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                  {selectedCategory.contestants?.map((contestant) => (
                    <div key={contestant.id} className="card">
                      <div className="card-header">
                        <h3 className="font-semibold">{contestant.name}</h3>
                        <p className="text-sm text-gray-600 dark:text-gray-400">
                          #{contestant.contestantNumber || contestant.id.slice(-4)}
                        </p>
                      </div>
                      <div className="card-body">
                        <div className="space-y-3">
                          {selectedCategory.criteria?.map((criterion) => {
                            const existingScore = scores?.find((s: Score) => 
                              s.contestant.id === contestant.id && s.criterion.id === criterion.id
                            )
                            return (
                              <div key={criterion.id} className="flex items-center justify-between">
                                <div className="flex-1">
                                  <label className="text-sm font-medium">{criterion.name}</label>
                                  <p className="text-xs text-gray-600 dark:text-gray-400">
                                    Max: {criterion.maxScore}
                                  </p>
                                </div>
                                <div className="flex items-center space-x-2">
                                  <input
                                    type="number"
                                    min="0"
                                    max={criterion.maxScore}
                                    defaultValue={existingScore?.score || ''}
                                    className="score-input"
                                    onChange={(e) => {
                                      const score = parseInt(e.target.value)
                                      if (!isNaN(score) && score >= 0 && score <= criterion.maxScore) {
                                        handleScoreSubmit(contestant, criterion, score)
                                      }
                                    }}
                                  />
                                  {existingScore && (
                                    <CheckCircleIcon className="h-5 w-5 text-green-500" />
                                  )}
                                </div>
                              </div>
                            )
                          })}
                        </div>
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            </div>
          )}
        </div>
      )
    }

    if (user?.role === 'TALLY_MASTER') {
      return (
        <div className="space-y-6">
          <div className="card">
            <div className="card-header">
              <h2 className="text-xl font-bold text-gray-900 dark:text-white">Certification Queue</h2>
              <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
                Categories ready for tally master certification
              </p>
            </div>
            <div className="card-body">
              <CertificationWorkflow />
            </div>
          </div>
        </div>
      )
    }

    if (user?.role === 'AUDITOR') {
      return (
        <div className="space-y-6">
          <div className="card">
            <div className="card-header">
              <h2 className="text-xl font-bold text-gray-900 dark:text-white">Final Certification</h2>
              <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
                Final certification of contest results
              </p>
            </div>
            <div className="card-body">
              <CertificationWorkflow />
            </div>
          </div>
        </div>
      )
    }

    return (
      <div className="space-y-6">
        <div className="card">
          <div className="card-header">
            <h2 className="text-xl font-bold text-gray-900 dark:text-white">All Categories</h2>
            <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
              View and manage scoring for all categories
            </p>
          </div>
          <div className="card-body">
            <div className="mb-6">
              <SearchFilter
                searchTerm={searchTerm}
                onSearchChange={setSearchTerm}
                filters={{
                  status: {
                    label: 'Status',
                    options: [
                      { value: '', label: 'All Statuses' },
                      { value: 'DRAFT', label: 'Draft' },
                      { value: 'ACTIVE', label: 'Active' },
                      { value: 'COMPLETED', label: 'Completed' },
                      { value: 'ARCHIVED', label: 'Archived' }
                    ],
                    value: statusFilter,
                    onChange: setStatusFilter
                  }
                }}
                placeholder="Search categories..."
              />
            </div>
            
            <DataTable
              data={filteredCategories}
              columns={categoryColumns}
              loading={isLoading}
              searchable={false}
              pagination={true}
              pageSize={10}
            />
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      <div className="card">
        <div className="card-header">
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Scoring System</h1>
          <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
            Submit and manage contest scores
          </p>
        </div>
        <div className="card-body">
          {getRoleSpecificContent()}
        </div>
      </div>
    </div>
  )
}

export default ScoringPage
EOF

    cat > "$APP_DIR/frontend/src/pages/ResultsPage.tsx" << 'EOF'
import React, { useState } from 'react'
import { useQuery } from 'react-query'
import { resultsAPI, eventsAPI, contestsAPI, categoriesAPI } from '../services/api'
import { useAuth } from '../contexts/AuthContext'
import DataTable from '../components/DataTable'
import SearchFilter from '../components/SearchFilter'
import PrintReports from '../components/PrintReports'
import { TrophyIcon, StarIcon, PrinterIcon, ArrowDownTrayIcon, XMarkIcon } from '@heroicons/react/24/outline'
import { format } from 'date-fns'

interface Result {
  id: string
  contestantId: string
  categoryId: string
  totalScore: number
  averageScore: number
  rank: number
  isCertified: boolean
  certifiedAt?: string
  certifiedBy?: string
  contestant: {
    id: string
    name: string
    email: string
    contestantNumber?: string
  }
  category: {
    id: string
    name: string
    maxScore: number
    contest?: {
      id: string
      name: string
      event?: {
        id: string
        name: string
      }
    }
  }
  scores: Score[]
}

interface Score {
  id: string
  score: number
  comment?: string
  createdAt: string
  judge: {
    id: string
    name: string
  }
  criterion: {
    id: string
    name: string
    maxScore: number
  }
}

interface Category {
  id: string
  name: string
  description: string
  maxScore: number
  status: 'DRAFT' | 'ACTIVE' | 'COMPLETED' | 'ARCHIVED'
  _count?: {
    contestants: number
    scores: number
  }
}

const ResultsPage: React.FC = () => {
  const { user } = useAuth()
  const [selectedCategory, setSelectedCategory] = useState<Category | null>(null)
  const [searchTerm, setSearchTerm] = useState('')
  const [statusFilter, setStatusFilter] = useState('')
  const [showPrintModal, setShowPrintModal] = useState(false)

  const { data: categories, isLoading: categoriesLoading } = useQuery(
    'results-categories',
    () => categoriesAPI.getAll().then((res: any) => res.data),
    { 
      refetchInterval: 300000, // Refresh every 5 minutes (reduced from 30 seconds)
      refetchOnWindowFocus: false,
      staleTime: 120000
    }
  )

  const { data: results, isLoading: resultsLoading } = useQuery(
    ['results', selectedCategory?.id],
    () => selectedCategory ? resultsAPI.getCategoryResults(selectedCategory.id).then((res: any) => res.data) : Promise.resolve([]),
    { enabled: !!selectedCategory, refetchInterval: 300000, refetchOnWindowFocus: false, staleTime: 120000 }
  )

  const { data: allResults } = useQuery(
    'all-results',
    () => resultsAPI.getAll().then((res: any) => res.data),
    { enabled: !selectedCategory, refetchInterval: 300000, refetchOnWindowFocus: false, staleTime: 120000 }
  )

  const handleCategorySelect = (category: Category) => {
    setSelectedCategory(category)
  }

  const handlePrint = () => {
    setShowPrintModal(true)
  }

  const getRankIcon = (rank: number) => {
    if (rank === 1) return <TrophyIcon className="h-6 w-6 text-yellow-500" />
    if (rank === 2) return <TrophyIcon className="h-6 w-6 text-gray-400" />
    if (rank === 3) return <TrophyIcon className="h-6 w-6 text-amber-600" />
    return <span className="text-lg font-bold text-gray-600 dark:text-gray-400">#{rank}</span>
  }

  const getRankColor = (rank: number) => {
    if (rank === 1) return 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200'
    if (rank === 2) return 'bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200'
    if (rank === 3) return 'bg-amber-100 text-amber-800 dark:bg-amber-900 dark:text-amber-200'
    return 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200'
  }

  const getCertificationStatus = (isCertified: boolean, certifiedAt?: string) => {
    if (isCertified) {
      return (
        <div className="flex items-center space-x-1">
          <StarIcon className="h-4 w-4 text-green-500" />
          <span className="text-sm text-green-600 dark:text-green-400">
            Certified {certifiedAt && format(new Date(certifiedAt), 'MMM dd, yyyy')}
          </span>
        </div>
      )
    }
    return (
      <div className="flex items-center space-x-1">
        <StarIcon className="h-4 w-4 text-gray-400" />
        <span className="text-sm text-gray-600 dark:text-gray-400">Pending</span>
      </div>
    )
  }

  const filteredCategories = categories?.filter((category: Category) => {
    const matchesSearch = category.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                         category.description.toLowerCase().includes(searchTerm.toLowerCase())
    const matchesStatus = !statusFilter || category.status === statusFilter
    return matchesSearch && matchesStatus
  }) || []

  const categoryColumns = [
    { key: 'name', label: 'Category Name', sortable: true },
    { key: 'description', label: 'Description', sortable: true },
    { key: 'maxScore', label: 'Max Score', sortable: true },
    { key: 'status', label: 'Status', sortable: true, render: (value: string) => (
      <span className={`status-indicator ${getStatusColor(value)}`}>
        {getStatusText(value)}
      </span>
    ) },
    { key: '_count.contestants', label: 'Contestants', sortable: true, render: (value: number) => value || 0 },
    { key: 'actions', label: 'Actions', render: (value: any, row: Category) => (
      <div className="flex space-x-2">
        <button
          onClick={() => handleCategorySelect(row)}
          className="btn-sm btn-primary"
          title="View Results"
        >
          <TrophyIcon className="h-4 w-4" />
        </button>
      </div>
    )}
  ]

  const resultColumns = [
    { key: 'rank', label: 'Rank', sortable: true, render: (value: number) => (
      <div className="flex items-center space-x-2">
        {getRankIcon(value)}
        <span className={`status-indicator ${getRankColor(value)}`}>
          #{value}
        </span>
      </div>
    ) },
    { key: 'contestant.name', label: 'Contestant', sortable: true, render: (value: string, row: Result) => (
      <div>
        <div className="font-medium">{row.contestant.name}</div>
        <div className="text-sm text-gray-600 dark:text-gray-400">
          #{row.contestant.contestantNumber || row.contestant.id.slice(-4)}
        </div>
      </div>
    ) },
    { key: 'totalScore', label: 'Total Score', sortable: true, render: (value: number, row: Result) => (
      <div className="text-right">
        <div className="font-bold text-lg">{value.toFixed(2)}</div>
        <div className="text-sm text-gray-600 dark:text-gray-400">
          / {row.category.maxScore}
        </div>
      </div>
    ) },
    { key: 'averageScore', label: 'Average', sortable: true, render: (value: number) => (
      <div className="text-right font-medium">{value.toFixed(2)}</div>
    ) },
    { key: 'isCertified', label: 'Status', sortable: true, render: (value: boolean, row: Result) => 
      getCertificationStatus(value, row.certifiedAt)
    },
    { key: 'actions', label: 'Actions', render: (value: any, row: Result) => (
      <div className="flex space-x-2">
        <button
          onClick={() => handlePrint()}
          className="btn-sm btn-outline"
          title="Print Results"
        >
          <PrinterIcon className="h-4 w-4" />
        </button>
      </div>
    )}
  ]

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'DRAFT': return 'bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200'
      case 'ACTIVE': return 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
      case 'COMPLETED': return 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200'
      case 'ARCHIVED': return 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200'
      default: return 'bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200'
    }
  }

  const getStatusText = (status: string) => {
    switch (status) {
      case 'DRAFT': return 'Draft'
      case 'ACTIVE': return 'Active'
      case 'COMPLETED': return 'Completed'
      case 'ARCHIVED': return 'Archived'
      default: return status
    }
  }

  const getRoleSpecificContent = () => {
    if (user?.role === 'CONTESTANT') {
      return (
        <div className="space-y-6">
          <div className="card">
            <div className="card-header">
              <h2 className="text-xl font-bold text-gray-900 dark:text-white">My Results</h2>
              <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
                Your contest results and rankings
              </p>
            </div>
            <div className="card-body">
              <DataTable
                data={allResults?.filter((result: Result) => result.contestant.id === user.id) || []}
                columns={resultColumns}
                loading={resultsLoading}
                searchable={false}
                pagination={true}
                pageSize={10}
              />
            </div>
          </div>
        </div>
      )
    }

    return (
      <div className="space-y-6">
        <div className="card">
          <div className="card-header">
            <div className="flex justify-between items-center">
              <div>
                <h2 className="text-xl font-bold text-gray-900 dark:text-white">Contest Results</h2>
                <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
                  View and manage contest results
                </p>
              </div>
              <div className="flex space-x-2">
                <button
                  onClick={handlePrint}
                  className="btn-secondary"
                >
                  <PrinterIcon className="h-5 w-5 mr-2" />
                  Print Reports
                </button>
              </div>
            </div>
          </div>
          <div className="card-body">
            <div className="mb-6">
              <SearchFilter
                searchTerm={searchTerm}
                onSearchChange={setSearchTerm}
                filters={{
                  status: {
                    label: 'Status',
                    options: [
                      { value: '', label: 'All Statuses' },
                      { value: 'DRAFT', label: 'Draft' },
                      { value: 'ACTIVE', label: 'Active' },
                      { value: 'COMPLETED', label: 'Completed' },
                      { value: 'ARCHIVED', label: 'Archived' }
                    ],
                    value: statusFilter,
                    onChange: setStatusFilter
                  }
                }}
                placeholder="Search categories..."
              />
            </div>
            
            <DataTable
              data={filteredCategories}
              columns={categoryColumns}
              loading={categoriesLoading}
              searchable={false}
              pagination={true}
              pageSize={10}
            />
          </div>
        </div>

        {selectedCategory && (
          <div className="card">
            <div className="card-header">
              <div className="flex justify-between items-center">
                <div>
                  <h2 className="text-xl font-bold text-gray-900 dark:text-white">
                    Results: {selectedCategory.name}
                  </h2>
                  <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
                    Contestant rankings and scores
                  </p>
                </div>
                <div className="flex space-x-2">
                  <button
                    onClick={handlePrint}
                    className="btn-secondary"
                  >
                    <PrinterIcon className="h-5 w-5 mr-2" />
                    Print
                  </button>
                  <button
                    onClick={() => setSelectedCategory(null)}
                    className="btn-outline"
                  >
                    Back to Categories
                  </button>
                </div>
              </div>
            </div>
            <div className="card-body">
              <DataTable
                data={results || []}
                columns={resultColumns}
                loading={resultsLoading}
                searchable={false}
                pagination={true}
                pageSize={10}
              />
            </div>
          </div>
        )}
      </div>
    )
  }

  return (
    <div className="space-y-6">
      <div className="card">
        <div className="card-header">
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Results & Reports</h1>
          <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
            View contest results and generate reports
          </p>
        </div>
        <div className="card-body">
          {getRoleSpecificContent()}
        </div>
      </div>

      {/* Print Reports Modal */}
      {showPrintModal && (
        <div className="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
          <div className="relative top-20 mx-auto p-5 border w-full max-w-6xl shadow-lg rounded-md bg-white dark:bg-gray-800">
            <div className="mt-3">
              <div className="flex items-center justify-between mb-6">
                <h3 className="text-lg font-medium text-gray-900 dark:text-white">
                  Print Reports
                </h3>
                <button
                  onClick={() => setShowPrintModal(false)}
                  className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
                >
                  <XMarkIcon className="h-6 w-6" />
                </button>
              </div>
              
              <div className="space-y-6">
                <PrintReports />
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}

export default ResultsPage
EOF

    cat > "$APP_DIR/frontend/src/pages/UsersPage.tsx" << 'EOF'
import React, { useState } from 'react'
import { useQuery, useMutation, useQueryClient } from 'react-query'
import { usersAPI, adminAPI } from '../services/api'
import { useAuth } from '../contexts/AuthContext'
import DataTable from '../components/DataTable'
import SearchFilter from '../components/SearchFilter'
import { PlusIcon, PencilIcon, TrashIcon, UserIcon, ShieldCheckIcon, KeyIcon, XMarkIcon } from '@heroicons/react/24/outline'
import { format } from 'date-fns'

interface User {
  id: string
  name: string
  email: string
  role: 'ORGANIZER' | 'BOARD' | 'JUDGE' | 'TALLY_MASTER' | 'AUDITOR' | 'CONTESTANT'
  status: 'ACTIVE' | 'INACTIVE' | 'PENDING'
  preferredName?: string
  pronouns?: string
  phone?: string
  createdAt: string
  updatedAt: string
  lastLoginAt?: string
  _count?: {
    events: number
    contests: number
    scores: number
  }
}

const UsersPage: React.FC = () => {
  const { user: currentUser } = useAuth()
  const [showModal, setShowModal] = useState(false)
  const [editingUser, setEditingUser] = useState<User | null>(null)
  const [showResetModal, setShowResetModal] = useState(false)
  const [selectedUser, setSelectedUser] = useState<User | null>(null)
  const [formData, setFormData] = useState<Partial<User>>({})
  const [searchTerm, setSearchTerm] = useState('')
  const [roleFilter, setRoleFilter] = useState('')
  const [statusFilter, setStatusFilter] = useState('')
  const queryClient = useQueryClient()

  const { data: users, isLoading } = useQuery(
    'users',
    () => usersAPI.getAll().then((res: any) => res.data),
    { 
      refetchInterval: 300000, // Refresh every 5 minutes (reduced from 30 seconds)
      refetchOnWindowFocus: false,
      staleTime: 120000
    }
  )

  const createMutation = useMutation(
    (data: Partial<User>) => usersAPI.create(data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('users')
        setShowModal(false)
        setFormData({})
      }
    }
  )

  const updateMutation = useMutation(
    ({ id, data }: { id: string; data: Partial<User> }) => usersAPI.update(id, data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('users')
        setShowModal(false)
        setEditingUser(null)
        setFormData({})
      }
    }
  )

  const deleteMutation = useMutation(
    (id: string) => usersAPI.delete(id),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('users')
      }
    }
  )

  const resetPasswordMutation = useMutation(
    ({ id, data }: { id: string; data: any }) => usersAPI.resetPassword(id, data),
    {
      onSuccess: () => {
        setShowResetModal(false)
        setSelectedUser(null)
      }
    }
  )

  const handleCreate = () => {
    setEditingUser(null)
    setFormData({})
    setShowModal(true)
  }

  const handleEdit = (user: User) => {
    setEditingUser(user)
    setFormData(user)
    setShowModal(true)
  }

  const handleDelete = (id: string) => {
    if (window.confirm('Are you sure you want to delete this user?')) {
      deleteMutation.mutate(id)
    }
  }

  const handleResetPassword = (user: User) => {
    setSelectedUser(user)
    setShowResetModal(true)
  }

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    if (editingUser) {
      updateMutation.mutate({ id: editingUser.id, data: formData })
    } else {
      createMutation.mutate(formData)
    }
  }

  const handleResetSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    const formData = new FormData(e.target as HTMLFormElement)
    const newPassword = formData.get('newPassword') as string
    const confirmPassword = formData.get('confirmPassword') as string

    if (newPassword !== confirmPassword) {
      alert('Passwords do not match')
      return
    }

    resetPasswordMutation.mutate({
      id: selectedUser!.id,
      data: { newPassword }
    })
  }

  const getRoleColor = (role: string) => {
    switch (role) {
      case 'ORGANIZER': return 'bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-200'
      case 'BOARD': return 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200'
      case 'JUDGE': return 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
      case 'TALLY_MASTER': return 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200'
      case 'AUDITOR': return 'bg-orange-100 text-orange-800 dark:bg-orange-900 dark:text-orange-200'
      case 'CONTESTANT': return 'bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200'
      default: return 'bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200'
    }
  }

  const getRoleText = (role: string) => {
    switch (role) {
      case 'ORGANIZER': return 'Organizer'
      case 'BOARD': return 'Board Member'
      case 'JUDGE': return 'Judge'
      case 'TALLY_MASTER': return 'Tally Master'
      case 'AUDITOR': return 'Auditor'
      case 'CONTESTANT': return 'Contestant'
      default: return role
    }
  }

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'ACTIVE': return 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
      case 'INACTIVE': return 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200'
      case 'PENDING': return 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200'
      default: return 'bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200'
    }
  }

  const getStatusText = (status: string) => {
    switch (status) {
      case 'ACTIVE': return 'Active'
      case 'INACTIVE': return 'Inactive'
      case 'PENDING': return 'Pending'
      default: return status
    }
  }

  const filteredUsers = users?.filter((user: User) => {
    const matchesSearch = user.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                         user.email.toLowerCase().includes(searchTerm.toLowerCase())
    const matchesRole = !roleFilter || user.role === roleFilter
    const matchesStatus = !statusFilter || user.status === statusFilter
    return matchesSearch && matchesRole && matchesStatus
  }) || []

  const columns = [
    { key: 'name', label: 'Name', sortable: true, render: (value: string, row: User) => (
      <div className="flex items-center space-x-3">
        <div className="flex-shrink-0">
          <UserIcon className="h-8 w-8 text-gray-400" />
        </div>
        <div>
          <div className="font-medium text-gray-900 dark:text-white">{row.name}</div>
          <div className="text-sm text-gray-600 dark:text-gray-400">{row.email}</div>
        </div>
      </div>
    ) },
    { key: 'role', label: 'Role', sortable: true, render: (value: string) => (
      <span className={`status-indicator ${getRoleColor(value)}`}>
        {getRoleText(value)}
      </span>
    ) },
    { key: 'status', label: 'Status', sortable: true, render: (value: string) => (
      <span className={`status-indicator ${getStatusColor(value)}`}>
        {getStatusText(value)}
      </span>
    ) },
    { key: 'lastLoginAt', label: 'Last Login', sortable: true, render: (value: string) => (
      value ? format(new Date(value), 'MMM dd, yyyy HH:mm') : 'Never'
    ) },
    { key: 'createdAt', label: 'Created', sortable: true, render: (value: string) => 
      format(new Date(value), 'MMM dd, yyyy')
    },
    { key: 'actions', label: 'Actions', render: (value: any, row: User) => (
      <div className="flex space-x-2">
        <button
          onClick={() => handleEdit(row)}
          className="btn-sm btn-outline"
          title="Edit User"
        >
          <PencilIcon className="h-4 w-4" />
        </button>
        <button
          onClick={() => handleResetPassword(row)}
          className="btn-sm btn-outline"
          title="Reset Password"
        >
          <KeyIcon className="h-4 w-4" />
        </button>
        {row.id !== currentUser?.id && (
          <button
            onClick={() => handleDelete(row.id)}
            className="btn-sm btn-danger"
            title="Delete User"
          >
            <TrashIcon className="h-4 w-4" />
          </button>
        )}
      </div>
    )}
  ]

  const canManageUsers = currentUser?.role === 'ORGANIZER' || currentUser?.role === 'BOARD'

  if (!canManageUsers) {
    return (
      <div className="space-y-6">
        <div className="card">
          <div className="card-header">
            <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Access Denied</h1>
            <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
              You don't have permission to manage users
            </p>
          </div>
          <div className="card-body">
            <div className="text-center py-12">
              <ShieldCheckIcon className="h-12 w-12 text-gray-400 mx-auto mb-4" />
              <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">Access Restricted</h3>
              <p className="text-gray-600 dark:text-gray-400">
                Only organizers and board members can manage users
              </p>
            </div>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      <div className="card">
        <div className="card-header">
          <div className="flex justify-between items-center">
            <div>
              <h1 className="text-2xl font-bold text-gray-900 dark:text-white">User Management</h1>
              <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
                Manage system users and their permissions
              </p>
            </div>
            <button
              onClick={handleCreate}
              className="btn-primary"
            >
              <PlusIcon className="h-5 w-5 mr-2" />
              Add User
            </button>
          </div>
        </div>
        <div className="card-body">
          <div className="mb-6">
            <SearchFilter
              searchTerm={searchTerm}
              onSearchChange={setSearchTerm}
              filters={{
                role: {
                  label: 'Role',
                  options: [
                    { value: '', label: 'All Roles' },
                    { value: 'ORGANIZER', label: 'Organizer' },
                    { value: 'BOARD', label: 'Board Member' },
                    { value: 'JUDGE', label: 'Judge' },
                    { value: 'TALLY_MASTER', label: 'Tally Master' },
                    { value: 'AUDITOR', label: 'Auditor' },
                    { value: 'CONTESTANT', label: 'Contestant' }
                  ],
                  value: roleFilter,
                  onChange: setRoleFilter
                },
                status: {
                  label: 'Status',
                  options: [
                    { value: '', label: 'All Statuses' },
                    { value: 'ACTIVE', label: 'Active' },
                    { value: 'INACTIVE', label: 'Inactive' },
                    { value: 'PENDING', label: 'Pending' }
                  ],
                  value: statusFilter,
                  onChange: setStatusFilter
                }
              }}
              placeholder="Search users..."
            />
          </div>
          
          <DataTable
            data={filteredUsers}
            columns={columns}
            loading={isLoading}
            searchable={false}
            pagination={true}
            pageSize={10}
          />
        </div>
      </div>

      {/* User Modal */}
      {showModal && (
        <div className="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
          <div className="relative top-20 mx-auto p-5 border w-full max-w-2xl shadow-lg rounded-md bg-white dark:bg-gray-800">
            <div className="mt-3">
              <div className="flex items-center justify-between mb-6">
                <h3 className="text-lg font-medium text-gray-900 dark:text-white">
                  {editingUser ? 'Edit User' : 'Add User'}
                </h3>
                <button
                  onClick={() => setShowModal(false)}
                  className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
                >
                  <XMarkIcon className="h-6 w-6" />
                </button>
              </div>
              
              <form onSubmit={handleSubmit} className="space-y-6">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                      Name *
                    </label>
                    <input
                      type="text"
                      value={formData.name || ''}
                      onChange={(e) => setFormData({ ...formData, name: e.target.value })}
                      className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white"
                      placeholder="Enter full name"
                      required
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                      Email *
                    </label>
                    <input
                      type="email"
                      value={formData.email || ''}
                      onChange={(e) => setFormData({ ...formData, email: e.target.value })}
                      className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white"
                      placeholder="Enter email address"
                      required
                    />
                  </div>
                </div>
                
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                      Role *
                    </label>
                    <select
                      value={formData.role || ''}
                      onChange={(e) => setFormData({ ...formData, role: e.target.value as any })}
                      className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white"
                      required
                    >
                      <option value="">Select Role</option>
                      <option value="ORGANIZER">Organizer</option>
                      <option value="BOARD">Board Member</option>
                      <option value="JUDGE">Judge</option>
                      <option value="TALLY_MASTER">Tally Master</option>
                      <option value="AUDITOR">Auditor</option>
                      <option value="CONTESTANT">Contestant</option>
                      <option value="EMCEE">Emcee</option>
                    </select>
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                      Status
                    </label>
                    <select
                      value={formData.status || ''}
                      onChange={(e) => setFormData({ ...formData, status: e.target.value as any })}
                      className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white"
                      required
                    >
                      <option value="">Select Status</option>
                      <option value="ACTIVE">Active</option>
                      <option value="INACTIVE">Inactive</option>
                      <option value="PENDING">Pending</option>
                    </select>
                  </div>
                </div>

                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                      Preferred Name
                    </label>
                    <input
                      type="text"
                      value={formData.preferredName || ''}
                      onChange={(e) => setFormData({ ...formData, preferredName: e.target.value })}
                      className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white"
                      placeholder="Enter preferred name"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                      Pronouns
                    </label>
                    <input
                      type="text"
                      value={formData.pronouns || ''}
                      onChange={(e) => setFormData({ ...formData, pronouns: e.target.value })}
                      className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white"
                      placeholder="e.g., he/him, she/her, they/them"
                    />
                  </div>
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                    Phone Number
                  </label>
                  <input
                    type="tel"
                    value={formData.phone || ''}
                    onChange={(e) => setFormData({ ...formData, phone: e.target.value })}
                    className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white"
                    placeholder="Enter phone number"
                  />
                </div>

                {!editingUser && (
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                      Password *
                    </label>
                    <input
                      type="password"
                      name="password"
                      className="w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white"
                      placeholder="Enter password"
                      required
                    />
                  </div>
                )}

                <div className="flex justify-end space-x-3 pt-4 border-t border-gray-200 dark:border-gray-600">
                  <button
                    type="button"
                    onClick={() => setShowModal(false)}
                    className="px-4 py-2 text-sm font-medium text-gray-700 dark:text-gray-300 bg-gray-100 dark:bg-gray-700 border border-gray-300 dark:border-gray-600 rounded-md hover:bg-gray-200 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-500"
                  >
                    Cancel
                  </button>
                  <button
                    type="submit"
                    disabled={createMutation.isLoading || updateMutation.isLoading}
                    className="px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-transparent rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
                  >
                    {createMutation.isLoading || updateMutation.isLoading ? (
                      <span className="flex items-center">
                        <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                        </svg>
                        {editingUser ? 'Updating...' : 'Creating...'}
                      </span>
                    ) : (
                      editingUser ? 'Update User' : 'Create User'
                    )}
                  </button>
                </div>
              </form>
            </div>
          </div>
        </div>
      )}

      {/* Reset Password Modal */}
      {showResetModal && selectedUser && (
        <div className="modal">
          <div className="modal-overlay" onClick={() => setShowResetModal(false)} />
          <div className="modal-content">
            <h2 className="text-xl font-bold mb-4">Reset Password</h2>
            <p className="text-sm text-gray-600 dark:text-gray-400 mb-4">
              Reset password for {selectedUser.name}
            </p>
            <form onSubmit={handleResetSubmit} className="space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                  New Password
                </label>
                <input
                  type="password"
                  name="newPassword"
                  className="input"
                  required
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                  Confirm Password
                </label>
                <input
                  type="password"
                  name="confirmPassword"
                  className="input"
                  required
                />
              </div>
              <div className="flex justify-end space-x-2">
                <button
                  type="button"
                  onClick={() => setShowResetModal(false)}
                  className="btn-secondary"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  className="btn-primary"
                  disabled={resetPasswordMutation.isLoading}
                >
                  Reset Password
                </button>
              </div>
            </form>
          </div>
        </div>
      )}
    </div>
  )
}

export default UsersPage
EOF

    cat > "$APP_DIR/frontend/src/pages/AdminPage.tsx" << 'EOF'
import React, { useState } from 'react'
import { useQuery, useMutation, useQueryClient } from 'react-query'
import { adminAPI, backupAPI, settingsAPI } from '../services/api'
import { useAuth } from '../contexts/AuthContext'
import AuditLog from '../components/AuditLog'
import BackupManager from '../components/BackupManager'
import SecurityDashboard from '../components/SecurityDashboard'
import SettingsForm from '../components/SettingsForm'
import EmceeScripts from '../components/EmceeScripts'
import DataTable from '../components/DataTable'
import SearchFilter from '../components/SearchFilter'
import { 
  ShieldCheckIcon, 
  ServerIcon, 
  CircleStackIcon, 
  ChartBarIcon,
  ExclamationTriangleIcon,
  CheckCircleIcon,
  ClockIcon,
  UsersIcon,
  CalendarIcon,
  TrophyIcon,
  CogIcon,
  DocumentTextIcon
} from '@heroicons/react/24/outline'
import { format } from 'date-fns'

interface AdminStats {
  totalUsers: number
  totalEvents: number
  totalContests: number
  totalCategories: number
  totalScores: number
  activeUsers: number
  pendingCertifications: number
  systemHealth: 'HEALTHY' | 'WARNING' | 'CRITICAL'
  lastBackup?: string
  databaseSize: string
  uptime: string
}

interface ActivityLog {
  id: string
  userId: string
  action: string
  resource: string
  resourceId?: string
  details?: any
  ipAddress: string
  userAgent: string
  createdAt: string
  user: {
    id: string
    name: string
    email: string
    role: string
  }
}

const AdminPage: React.FC = () => {
  const { user } = useAuth()
  const [activeTab, setActiveTab] = useState('overview')
  const [searchTerm, setSearchTerm] = useState('')
  const [dateFilter, setDateFilter] = useState('')
  const [actionFilter, setActionFilter] = useState('')
  const [showSettings, setShowSettings] = useState(false)
  const queryClient = useQueryClient()

  const { data: stats, isLoading: statsLoading } = useQuery(
    'adminStats',
    () => adminAPI.getStats().then((res: any) => res.data),
    { 
      refetchInterval: 300000, // Refresh every 5 minutes (reduced from 30 seconds)
      refetchOnWindowFocus: false,
      staleTime: 120000
    }
  )

  const { data: activityLogs, isLoading: logsLoading } = useQuery(
    ['activityLogs', { searchTerm, dateFilter, actionFilter }],
    () => adminAPI.getActivityLogs().then((res: any) => res.data),
    { refetchInterval: 300000, refetchOnWindowFocus: false, staleTime: 120000 }
  )

  const { data: activeUsers } = useQuery(
    'activeUsers',
    () => adminAPI.getActiveUsers().then((res: any) => res.data),
    { refetchInterval: 300000, refetchOnWindowFocus: false, staleTime: 120000 }
  )

  const { data: systemSettings } = useQuery(
    'systemSettings',
    () => adminAPI.getSettings().then((res: any) => res.data)
  )

  const testConnectionMutation = useMutation(
    (type: string) => adminAPI.testConnection(type),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('adminStats')
      }
    }
  )

  const getHealthColor = (health: string) => {
    switch (health) {
      case 'HEALTHY': return 'text-green-600 dark:text-green-400'
      case 'WARNING': return 'text-yellow-600 dark:text-yellow-400'
      case 'CRITICAL': return 'text-red-600 dark:text-red-400'
      default: return 'text-gray-600 dark:text-gray-400'
    }
  }

  const getHealthIcon = (health: string) => {
    switch (health) {
      case 'HEALTHY': return <CheckCircleIcon className="h-5 w-5 text-green-500" />
      case 'WARNING': return <ExclamationTriangleIcon className="h-5 w-5 text-yellow-500" />
      case 'CRITICAL': return <ExclamationTriangleIcon className="h-5 w-5 text-red-500" />
      default: return <ClockIcon className="h-5 w-5 text-gray-500" />
    }
  }

  const filteredLogs = activityLogs?.filter((log: ActivityLog) => {
    const matchesSearch = log.action.toLowerCase().includes(searchTerm.toLowerCase()) ||
                         log.resource.toLowerCase().includes(searchTerm.toLowerCase()) ||
                         log.user.name.toLowerCase().includes(searchTerm.toLowerCase())
    const matchesDate = !dateFilter || log.createdAt.startsWith(dateFilter)
    const matchesAction = !actionFilter || log.action === actionFilter
    return matchesSearch && matchesDate && matchesAction
  }) || []

  const logColumns = [
    { key: 'user.name', label: 'User', sortable: true, render: (value: string, row: ActivityLog) => (
      <div className="flex items-center space-x-3">
        <UsersIcon className="h-5 w-5 text-gray-400" />
        <div>
          <div className="font-medium text-gray-900 dark:text-white">{row.user.name}</div>
          <div className="text-sm text-gray-600 dark:text-gray-400">{row.user.email}</div>
        </div>
      </div>
    ) },
    { key: 'action', label: 'Action', sortable: true, render: (value: string) => (
      <span className="font-mono text-sm bg-gray-100 dark:bg-gray-800 px-2 py-1 rounded">
        {value}
      </span>
    ) },
    { key: 'resource', label: 'Resource', sortable: true, render: (value: string, row: ActivityLog) => (
      <div>
        <div className="font-medium">{value}</div>
        {row.resourceId && (
          <div className="text-sm text-gray-600 dark:text-gray-400">
            ID: {row.resourceId}
          </div>
        )}
      </div>
    ) },
    { key: 'ipAddress', label: 'IP Address', sortable: true, render: (value: string) => (
      <span className="font-mono text-sm">{value}</span>
    ) },
    { key: 'createdAt', label: 'Timestamp', sortable: true, render: (value: string) => 
      format(new Date(value), 'MMM dd, yyyy HH:mm:ss')
    }
  ]

  const tabs = [
    { id: 'overview', name: 'Overview', icon: ChartBarIcon },
    { id: 'logs', name: 'Activity Logs', icon: ClockIcon },
    { id: 'security', name: 'Security', icon: ShieldCheckIcon },
    { id: 'backup', name: 'Backup', icon: CircleStackIcon },
    { id: 'system', name: 'System', icon: ServerIcon },
    { id: 'settings', name: 'Settings', icon: CogIcon }
  ]

  const canAccessAdmin = user?.role === 'ORGANIZER' || user?.role === 'BOARD'

  if (!canAccessAdmin) {
    return (
      <div className="space-y-6">
        <div className="card">
          <div className="card-header">
            <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Access Denied</h1>
            <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
              You don't have permission to access admin functions
            </p>
          </div>
          <div className="card-body">
            <div className="text-center py-12">
              <ShieldCheckIcon className="h-12 w-12 text-gray-400 mx-auto mb-4" />
              <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">Access Restricted</h3>
              <p className="text-gray-600 dark:text-gray-400">
                Only organizers and board members can access admin functions
              </p>
            </div>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      <div className="card">
        <div className="card-header">
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Admin Dashboard</h1>
          <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
            System administration and monitoring
          </p>
        </div>
        <div className="card-body">
          <div className="border-b border-gray-200 dark:border-gray-700">
            <nav className="-mb-px flex space-x-8">
              {tabs.map((tab) => (
                <button
                  key={tab.id}
                  onClick={() => setActiveTab(tab.id)}
                  className={`${
                    activeTab === tab.id
                      ? 'border-blue-500 text-blue-600'
                      : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                  } whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm flex items-center`}
                >
                  <tab.icon className="h-5 w-5 mr-2" />
                  {tab.name}
                </button>
              ))}
            </nav>
          </div>

          <div className="mt-6">
            {activeTab === 'overview' && (
              <div className="space-y-6">
                {/* System Health */}
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
                  <div className="card">
                    <div className="card-body">
                      <div className="flex items-center">
                        <div className="flex-shrink-0">
                          {getHealthIcon(stats?.systemHealth || 'HEALTHY')}
                        </div>
                        <div className="ml-3">
                          <p className="text-sm font-medium text-gray-600 dark:text-gray-400">System Health</p>
                          <p className={`text-lg font-semibold ${getHealthColor(stats?.systemHealth || 'HEALTHY')}`}>
                            {stats?.systemHealth || 'HEALTHY'}
                          </p>
                        </div>
                      </div>
                    </div>
                  </div>

                  <div className="card">
                    <div className="card-body">
                      <div className="flex items-center">
                        <div className="flex-shrink-0">
                          <UsersIcon className="h-8 w-8 text-blue-500" />
                        </div>
                        <div className="ml-3">
                          <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Total Users</p>
                          <p className="text-2xl font-semibold text-gray-900 dark:text-white">
                            {stats?.totalUsers || 0}
                          </p>
                        </div>
                      </div>
                    </div>
                  </div>

                  <div className="card">
                    <div className="card-body">
                      <div className="flex items-center">
                        <div className="flex-shrink-0">
                          <CalendarIcon className="h-8 w-8 text-green-500" />
                        </div>
                        <div className="ml-3">
                          <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Total Events</p>
                          <p className="text-2xl font-semibold text-gray-900 dark:text-white">
                            {stats?.totalEvents || 0}
                          </p>
                        </div>
                      </div>
                    </div>
                  </div>

                  <div className="card">
                    <div className="card-body">
                      <div className="flex items-center">
                        <div className="flex-shrink-0">
                          <TrophyIcon className="h-8 w-8 text-yellow-500" />
                        </div>
                        <div className="ml-3">
                          <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Total Contests</p>
                          <p className="text-2xl font-semibold text-gray-900 dark:text-white">
                            {stats?.totalContests || 0}
                          </p>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>

                {/* Quick Stats */}
                <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                  <div className="card">
                    <div className="card-header">
                      <h3 className="text-lg font-medium text-gray-900 dark:text-white">Database</h3>
                    </div>
                    <div className="card-body">
                      <div className="space-y-2">
                        <div className="flex justify-between">
                          <span className="text-sm text-gray-600 dark:text-gray-400">Size:</span>
                          <span className="text-sm font-medium">{stats?.databaseSize || 'N/A'}</span>
                        </div>
                        <div className="flex justify-between">
                          <span className="text-sm text-gray-600 dark:text-gray-400">Last Backup:</span>
                          <span className="text-sm font-medium">
                            {stats?.lastBackup ? format(new Date(stats.lastBackup), 'MMM dd, yyyy') : 'Never'}
                          </span>
                        </div>
                      </div>
                    </div>
                  </div>

                  <div className="card">
                    <div className="card-header">
                      <h3 className="text-lg font-medium text-gray-900 dark:text-white">Performance</h3>
                    </div>
                    <div className="card-body">
                      <div className="space-y-2">
                        <div className="flex justify-between">
                          <span className="text-sm text-gray-600 dark:text-gray-400">Uptime:</span>
                          <span className="text-sm font-medium">{stats?.uptime || 'N/A'}</span>
                        </div>
                        <div className="flex justify-between">
                          <span className="text-sm text-gray-600 dark:text-gray-400">Active Users:</span>
                          <span className="text-sm font-medium">{stats?.activeUsers || 0}</span>
                        </div>
                      </div>
                    </div>
                  </div>

                  <div className="card">
                    <div className="card-header">
                      <h3 className="text-lg font-medium text-gray-900 dark:text-white">Certifications</h3>
                    </div>
                    <div className="card-body">
                      <div className="space-y-2">
                        <div className="flex justify-between">
                          <span className="text-sm text-gray-600 dark:text-gray-400">Pending:</span>
                          <span className="text-sm font-medium text-yellow-600 dark:text-yellow-400">
                            {stats?.pendingCertifications || 0}
                          </span>
                        </div>
                        <div className="flex justify-between">
                          <span className="text-sm text-gray-600 dark:text-gray-400">Total Scores:</span>
                          <span className="text-sm font-medium">{stats?.totalScores || 0}</span>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>

                {/* System Tests */}
                <div className="card">
                  <div className="card-header">
                    <h3 className="text-lg font-medium text-gray-900 dark:text-white">System Tests</h3>
                  </div>
                  <div className="card-body">
                    <div className="flex space-x-4">
                      <button
                        onClick={() => testConnectionMutation.mutate('database')}
                        className="btn-outline"
                        disabled={testConnectionMutation.isLoading}
                      >
                        <CircleStackIcon className="h-5 w-5 mr-2" />
                        Test Database
                      </button>
                      <button
                        onClick={() => testConnectionMutation.mutate('email')}
                        className="btn-outline"
                        disabled={testConnectionMutation.isLoading}
                      >
                        <ServerIcon className="h-5 w-5 mr-2" />
                        Test Email
                      </button>
                      <button
                        onClick={() => testConnectionMutation.mutate('backup')}
                        className="btn-outline"
                        disabled={testConnectionMutation.isLoading}
                      >
                        <CircleStackIcon className="h-5 w-5 mr-2" />
                        Test Backup
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            )}

            {activeTab === 'logs' && (
              <div className="space-y-6">
                <div className="mb-6">
                  <SearchFilter
                    searchTerm={searchTerm}
                    onSearchChange={setSearchTerm}
                    filters={{
                      date: {
                        label: 'Date',
                        options: [
                          { value: '', label: 'All Dates' },
                          { value: new Date().toISOString().split('T')[0], label: 'Today' },
                          { value: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], label: 'Last 7 days' },
                          { value: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0], label: 'Last 30 days' }
                        ],
                        value: dateFilter,
                        onChange: setDateFilter
                      },
                      action: {
                        label: 'Action',
                        options: [
                          { value: '', label: 'All Actions' },
                          { value: 'CREATE', label: 'Create' },
                          { value: 'UPDATE', label: 'Update' },
                          { value: 'DELETE', label: 'Delete' },
                          { value: 'LOGIN', label: 'Login' },
                          { value: 'LOGOUT', label: 'Logout' }
                        ],
                        value: actionFilter,
                        onChange: setActionFilter
                      }
                    }}
                    placeholder="Search activity logs..."
                  />
                </div>

                <DataTable
                  data={filteredLogs}
                  columns={logColumns}
                  loading={logsLoading}
                  searchable={false}
                  pagination={true}
                  pageSize={20}
                />
              </div>
            )}

            {activeTab === 'security' && (
              <SecurityDashboard />
            )}

            {activeTab === 'backup' && (
              <BackupManager />
            )}

            {activeTab === 'system' && (
              <div className="space-y-6">
                <div className="card">
                  <div className="card-header">
                    <h3 className="text-lg font-medium text-gray-900 dark:text-white">System Settings</h3>
                  </div>
                  <div className="card-body">
                    <div className="space-y-4">
                      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                        <div>
                          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                            Application Name
                          </label>
                          <input
                            type="text"
                            value={systemSettings?.appName || ''}
                            className="input"
                            readOnly
                          />
                        </div>
                        <div>
                          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                            Version
                          </label>
                          <input
                            type="text"
                            value={systemSettings?.version || ''}
                            className="input"
                            readOnly
                          />
                        </div>
                      </div>
                      <div>
                        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                          Environment
                        </label>
                        <input
                          type="text"
                          value={systemSettings?.environment || ''}
                          className="input"
                          readOnly
                        />
                      </div>
                      <div className="flex justify-end">
                        <button
                          onClick={() => setShowSettings(true)}
                          className="btn btn-primary"
                        >
                          <CogIcon className="w-4 h-4 mr-2" />
                          Open Settings
                        </button>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            )}

            {activeTab === 'settings' && (
              <div className="space-y-6">
                <div className="card">
                  <div className="card-header">
                    <h3 className="text-lg font-medium text-gray-900 dark:text-white">System Configuration</h3>
                    <p className="text-sm text-gray-600 dark:text-gray-400">
                      Configure system settings, security policies, email settings, and backup preferences.
                    </p>
                  </div>
                  <div className="card-body">
                    <div className="flex justify-center">
                      <button
                        onClick={() => setShowSettings(true)}
                        className="btn btn-primary btn-lg"
                      >
                        <CogIcon className="w-5 h-5 mr-2" />
                        Open Settings Panel
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
      </div>

      {showSettings && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <SettingsForm onClose={() => setShowSettings(false)} />
        </div>
      )}
    </div>
  )
}

export default AdminPage
EOF

    cat > "$APP_DIR/frontend/src/pages/SettingsPage.tsx" << 'EOF'
import React, { useState } from 'react'
import { useQuery, useMutation, useQueryClient } from 'react-query'
import { settingsAPI, adminAPI } from '../services/api'
import { useAuth } from '../contexts/AuthContext'
import { 
  CogIcon,
  ServerIcon,
  EnvelopeIcon,
  ShieldCheckIcon,
  CircleStackIcon,
  BellIcon,
  KeyIcon,
  GlobeAltIcon,
  DocumentTextIcon,
  CloudIcon,
  ExclamationTriangleIcon,
  CheckCircleIcon,
  InformationCircleIcon
} from '@heroicons/react/24/outline'

interface SystemSetting {
  id: string
  key: string
  value: string
  description: string
  category: 'GENERAL' | 'EMAIL' | 'SECURITY' | 'DATABASE' | 'NOTIFICATIONS' | 'BACKUP'
  type: 'STRING' | 'NUMBER' | 'BOOLEAN' | 'JSON'
  isPublic: boolean
  updatedAt: string
  updatedBy: string
}

interface EmailSettings {
  smtpHost: string
  smtpPort: number
  smtpUser: string
  smtpPass: string
  smtpFrom: string
  smtpSecure: boolean
}

interface SecuritySettings {
  sessionTimeout: number
  maxLoginAttempts: number
  passwordMinLength: number
  requireTwoFactor: boolean
  allowedOrigins: string[]
}

const SettingsPage: React.FC = () => {
  const { user } = useAuth()
  const [activeTab, setActiveTab] = useState('general')
  const [formData, setFormData] = useState<any>({})
  const [testResults, setTestResults] = useState<Record<string, any>>({})
  const [isTesting, setIsTesting] = useState(false)
  const queryClient = useQueryClient()

  const { data: settings, isLoading } = useQuery(
    'settings',
    () => settingsAPI.getSettings().then((res: any) => res.data),
    {
      onSuccess: (data) => {
        // Group settings by category
        const groupedSettings: Record<string, any> = {}
        data.forEach((setting: SystemSetting) => {
          if (!groupedSettings[setting.category]) {
            groupedSettings[setting.category] = {}
          }
          groupedSettings[setting.category][setting.key] = setting.value
        })
        setFormData(groupedSettings)
      }
    }
  )

  const updateMutation = useMutation(
    (data: any) => settingsAPI.updateSettings(data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('settings')
      }
    }
  )

  const testMutation = useMutation(
    (type: string) => settingsAPI.test(type as any),
    {
      onSuccess: (data, type) => {
        setTestResults(prev => ({ ...prev, [type]: data.data }))
      },
      onError: (error: any, type) => {
        setTestResults(prev => ({ ...prev, [type]: { success: false, error: error.message } }))
      }
    }
  )

  const handleInputChange = (category: string, key: string, value: any) => {
    setFormData((prev: any) => ({
      ...prev,
      [category]: {
        ...prev[category],
        [key]: value
      }
    }))
  }

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    updateMutation.mutate(formData)
  }

  const handleTest = async (type: string) => {
    setIsTesting(true)
    try {
      await testMutation.mutateAsync(type)
    } finally {
      setIsTesting(false)
    }
  }

  const tabs = [
    { id: 'general', name: 'General', icon: CogIcon },
    { id: 'email', name: 'Email', icon: EnvelopeIcon },
    { id: 'security', name: 'Security', icon: ShieldCheckIcon },
    { id: 'database', name: 'Database', icon: CircleStackIcon },
    { id: 'notifications', name: 'Notifications', icon: BellIcon },
    { id: 'backup', name: 'Backup', icon: CloudIcon },
  ]

  const canManageSettings = user?.role === 'ORGANIZER' || user?.role === 'BOARD'

  if (!canManageSettings) {
    return (
      <div className="space-y-6">
        <div className="card">
          <div className="card-header">
            <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Access Denied</h1>
            <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
              You don't have permission to manage system settings
            </p>
          </div>
          <div className="card-body">
            <div className="text-center py-12">
              <ShieldCheckIcon className="h-12 w-12 text-gray-400 mx-auto mb-4" />
              <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">Access Restricted</h3>
              <p className="text-gray-600 dark:text-gray-400">
                Only organizers and board members can manage system settings
              </p>
            </div>
          </div>
        </div>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      <div className="card">
        <div className="card-header">
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">System Settings</h1>
          <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
            Configure system-wide settings and preferences
          </p>
        </div>
        <div className="card-body">
          <div className="border-b border-gray-200 dark:border-gray-700">
            <nav className="-mb-px flex space-x-8">
              {tabs.map((tab) => (
                <button
                  key={tab.id}
                  onClick={() => setActiveTab(tab.id)}
                  className={`${
                    activeTab === tab.id
                      ? 'border-blue-500 text-blue-600'
                      : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                  } whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm flex items-center`}
                >
                  <tab.icon className="h-5 w-5 mr-2" />
                  {tab.name}
                </button>
              ))}
            </nav>
          </div>

          <form onSubmit={handleSubmit} className="mt-6">
            {activeTab === 'general' && (
              <div className="space-y-6">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      Application Name
                    </label>
                    <input
                      type="text"
                      value={formData.GENERAL?.appName || ''}
                      onChange={(e) => handleInputChange('GENERAL', 'appName', e.target.value)}
                      className="input"
                      placeholder="Event Manager"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      Application URL
                    </label>
                    <input
                      type="url"
                      value={formData.GENERAL?.appUrl || ''}
                      onChange={(e) => handleInputChange('GENERAL', 'appUrl', e.target.value)}
                      className="input"
                      placeholder="https://eventmanager.com"
                    />
                  </div>
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                    Timezone
                  </label>
                  <select
                    value={formData.GENERAL?.timezone || 'UTC'}
                    onChange={(e) => handleInputChange('GENERAL', 'timezone', e.target.value)}
                    className="input"
                  >
                    <option value="UTC">UTC</option>
                    <option value="America/New_York">Eastern Time</option>
                    <option value="America/Chicago">Central Time</option>
                    <option value="America/Denver">Mountain Time</option>
                    <option value="America/Los_Angeles">Pacific Time</option>
                  </select>
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                    Default Language
                  </label>
                  <select
                    value={formData.GENERAL?.language || 'en'}
                    onChange={(e) => handleInputChange('GENERAL', 'language', e.target.value)}
                    className="input"
                  >
                    <option value="en">English</option>
                    <option value="es">Spanish</option>
                    <option value="fr">French</option>
                    <option value="de">German</option>
                  </select>
                </div>
              </div>
            )}

            {activeTab === 'email' && (
              <div className="space-y-6">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      SMTP Host
                    </label>
                    <input
                      type="text"
                      value={formData.EMAIL?.smtpHost || ''}
                      onChange={(e) => handleInputChange('EMAIL', 'smtpHost', e.target.value)}
                      className="input"
                      placeholder="smtp.gmail.com"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      SMTP Port
                    </label>
                    <input
                      type="number"
                      value={formData.EMAIL?.smtpPort || 587}
                      onChange={(e) => handleInputChange('EMAIL', 'smtpPort', parseInt(e.target.value))}
                      className="input"
                      placeholder="587"
                    />
                  </div>
                </div>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      SMTP Username
                    </label>
                    <input
                      type="text"
                      value={formData.EMAIL?.smtpUser || ''}
                      onChange={(e) => handleInputChange('EMAIL', 'smtpUser', e.target.value)}
                      className="input"
                      placeholder="your-email@gmail.com"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      SMTP Password
                    </label>
                    <input
                      type="password"
                      value={formData.EMAIL?.smtpPass || ''}
                      onChange={(e) => handleInputChange('EMAIL', 'smtpPass', e.target.value)}
                      className="input"
                      placeholder=""
                    />
                  </div>
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                    From Email Address
                  </label>
                  <input
                    type="email"
                    value={formData.EMAIL?.smtpFrom || ''}
                    onChange={(e) => handleInputChange('EMAIL', 'smtpFrom', e.target.value)}
                    className="input"
                    placeholder="noreply@eventmanager.com"
                  />
                </div>
                <div className="flex items-center">
                  <input
                    type="checkbox"
                    checked={formData.EMAIL?.smtpSecure || false}
                    onChange={(e) => handleInputChange('EMAIL', 'smtpSecure', e.target.checked)}
                    className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                  />
                  <label className="ml-2 block text-sm text-gray-700 dark:text-gray-300">
                    Use SSL/TLS
                  </label>
                </div>
                <div className="flex space-x-4">
                  <button
                    type="button"
                    onClick={() => handleTest('email')}
                    className="btn-outline"
                    disabled={isTesting}
                  >
                    <EnvelopeIcon className="h-5 w-5 mr-2" />
                    Test Email Connection
                  </button>
                  {testResults.email && (
                    <div className={`flex items-center ${testResults.email.success ? 'text-green-600' : 'text-red-600'}`}>
                      {testResults.email.success ? (
                        <CheckCircleIcon className="h-5 w-5 mr-1" />
                      ) : (
                        <ExclamationTriangleIcon className="h-5 w-5 mr-1" />
                      )}
                      <span className="text-sm">
                        {testResults.email.success ? 'Connection successful' : testResults.email.error}
                      </span>
                    </div>
                  )}
                </div>
              </div>
            )}

            {activeTab === 'security' && (
              <div className="space-y-6">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      Session Timeout (minutes)
                    </label>
                    <input
                      type="number"
                      value={formData.SECURITY?.sessionTimeout || 60}
                      onChange={(e) => handleInputChange('SECURITY', 'sessionTimeout', parseInt(e.target.value))}
                      className="input"
                      min="5"
                      max="1440"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      Max Login Attempts
                    </label>
                    <input
                      type="number"
                      value={formData.SECURITY?.maxLoginAttempts || 5}
                      onChange={(e) => handleInputChange('SECURITY', 'maxLoginAttempts', parseInt(e.target.value))}
                      className="input"
                      min="3"
                      max="10"
                    />
                  </div>
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                    Minimum Password Length
                  </label>
                  <input
                    type="number"
                    value={formData.SECURITY?.passwordMinLength || 8}
                    onChange={(e) => handleInputChange('SECURITY', 'passwordMinLength', parseInt(e.target.value))}
                    className="input"
                    min="6"
                    max="32"
                  />
                </div>
                <div className="flex items-center">
                  <input
                    type="checkbox"
                    checked={formData.SECURITY?.requireTwoFactor || false}
                    onChange={(e) => handleInputChange('SECURITY', 'requireTwoFactor', e.target.checked)}
                    className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                  />
                  <label className="ml-2 block text-sm text-gray-700 dark:text-gray-300">
                    Require Two-Factor Authentication
                  </label>
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                    Allowed Origins (one per line)
                  </label>
                  <textarea
                    value={formData.SECURITY?.allowedOrigins?.join('\n') || ''}
                    onChange={(e) => handleInputChange('SECURITY', 'allowedOrigins', e.target.value.split('\n').filter(Boolean))}
                    className="input"
                    rows={4}
                    placeholder="https://eventmanager.com&#10;https://www.eventmanager.com"
                  />
                </div>
              </div>
            )}

            {activeTab === 'database' && (
              <div className="space-y-6">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      Database Host
                    </label>
                    <input
                      type="text"
                      value={formData.DATABASE?.dbHost || ''}
                      onChange={(e) => handleInputChange('DATABASE', 'dbHost', e.target.value)}
                      className="input"
                      placeholder="localhost"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      Database Port
                    </label>
                    <input
                      type="number"
                      value={formData.DATABASE?.dbPort || 5432}
                      onChange={(e) => handleInputChange('DATABASE', 'dbPort', parseInt(e.target.value))}
                      className="input"
                      placeholder="5432"
                    />
                  </div>
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                    Database Name
                  </label>
                  <input
                    type="text"
                    value={formData.DATABASE?.dbName || ''}
                    onChange={(e) => handleInputChange('DATABASE', 'dbName', e.target.value)}
                    className="input"
                    placeholder="eventmanager"
                  />
                </div>
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      Database Username
                    </label>
                    <input
                      type="text"
                      value={formData.DATABASE?.dbUser || ''}
                      onChange={(e) => handleInputChange('DATABASE', 'dbUser', e.target.value)}
                      className="input"
                      placeholder="postgres"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      Database Password
                    </label>
                    <input
                      type="password"
                      value={formData.DATABASE?.dbPassword || ''}
                      onChange={(e) => handleInputChange('DATABASE', 'dbPassword', e.target.value)}
                      className="input"
                      placeholder=""
                    />
                  </div>
                </div>
                <div className="flex space-x-4">
                  <button
                    type="button"
                    onClick={() => handleTest('database')}
                    className="btn-outline"
                    disabled={isTesting}
                  >
                    <CircleStackIcon className="h-5 w-5 mr-2" />
                    Test Database Connection
                  </button>
                  {testResults.database && (
                    <div className={`flex items-center ${testResults.database.success ? 'text-green-600' : 'text-red-600'}`}>
                      {testResults.database.success ? (
                        <CheckCircleIcon className="h-5 w-5 mr-1" />
                      ) : (
                        <ExclamationTriangleIcon className="h-5 w-5 mr-1" />
                      )}
                      <span className="text-sm">
                        {testResults.database.success ? 'Connection successful' : testResults.database.error}
                      </span>
                    </div>
                  )}
                </div>
              </div>
            )}

            {activeTab === 'notifications' && (
              <div className="space-y-6">
                <div className="flex items-center">
                  <input
                    type="checkbox"
                    checked={formData.NOTIFICATIONS?.emailNotifications || false}
                    onChange={(e) => handleInputChange('NOTIFICATIONS', 'emailNotifications', e.target.checked)}
                    className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                  />
                  <label className="ml-2 block text-sm text-gray-700 dark:text-gray-300">
                    Enable Email Notifications
                  </label>
                </div>
                <div className="flex items-center">
                  <input
                    type="checkbox"
                    checked={formData.NOTIFICATIONS?.scoreNotifications || false}
                    onChange={(e) => handleInputChange('NOTIFICATIONS', 'scoreNotifications', e.target.checked)}
                    className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                  />
                  <label className="ml-2 block text-sm text-gray-700 dark:text-gray-300">
                    Notify on Score Submission
                  </label>
                </div>
                <div className="flex items-center">
                  <input
                    type="checkbox"
                    checked={formData.NOTIFICATIONS?.certificationNotifications || false}
                    onChange={(e) => handleInputChange('NOTIFICATIONS', 'certificationNotifications', e.target.checked)}
                    className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                  />
                  <label className="ml-2 block text-sm text-gray-700 dark:text-gray-300">
                    Notify on Certification Status Changes
                  </label>
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                    Notification Email Template
                  </label>
                  <textarea
                    value={formData.NOTIFICATIONS?.emailTemplate || ''}
                    onChange={(e) => handleInputChange('NOTIFICATIONS', 'emailTemplate', e.target.value)}
                    className="input"
                    rows={6}
                    placeholder="Enter email template..."
                  />
                </div>
              </div>
            )}

            {activeTab === 'backup' && (
              <div className="space-y-6">
                <div className="flex items-center">
                  <input
                    type="checkbox"
                    checked={formData.BACKUP?.autoBackup || false}
                    onChange={(e) => handleInputChange('BACKUP', 'autoBackup', e.target.checked)}
                    className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                  />
                  <label className="ml-2 block text-sm text-gray-700 dark:text-gray-300">
                    Enable Automatic Backups
                  </label>
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                    Backup Frequency (hours)
                  </label>
                  <input
                    type="number"
                    value={formData.BACKUP?.backupFrequency || 24}
                    onChange={(e) => handleInputChange('BACKUP', 'backupFrequency', parseInt(e.target.value))}
                    className="input"
                    min="1"
                    max="168"
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                    Backup Retention (days)
                  </label>
                  <input
                    type="number"
                    value={formData.BACKUP?.backupRetention || 30}
                    onChange={(e) => handleInputChange('BACKUP', 'backupRetention', parseInt(e.target.value))}
                    className="input"
                    min="1"
                    max="365"
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                    Backup Storage Path
                  </label>
                  <input
                    type="text"
                    value={formData.BACKUP?.backupPath || '/backups'}
                    onChange={(e) => handleInputChange('BACKUP', 'backupPath', e.target.value)}
                    className="input"
                    placeholder="/backups"
                  />
                </div>
                <div className="flex space-x-4">
                  <button
                    type="button"
                    onClick={() => handleTest('backup')}
                    className="btn-outline"
                    disabled={isTesting}
                  >
                    <CloudIcon className="h-5 w-5 mr-2" />
                    Test Backup System
                  </button>
                  {testResults.backup && (
                    <div className={`flex items-center ${testResults.backup.success ? 'text-green-600' : 'text-red-600'}`}>
                      {testResults.backup.success ? (
                        <CheckCircleIcon className="h-5 w-5 mr-1" />
                      ) : (
                        <ExclamationTriangleIcon className="h-5 w-5 mr-1" />
                      )}
                      <span className="text-sm">
                        {testResults.backup.success ? 'Backup system ready' : testResults.backup.error}
                      </span>
                    </div>
                  )}
                </div>
              </div>
            )}

            <div className="mt-8 flex justify-end space-x-4">
              <button
                type="button"
                className="btn-secondary"
                onClick={() => window.location.reload()}
              >
                Reset
              </button>
              <button
                type="submit"
                className="btn-primary"
                disabled={updateMutation.isLoading}
              >
                {updateMutation.isLoading ? 'Saving...' : 'Save Settings'}
              </button>
            </div>
          </form>
        </div>
      </div>
    </div>
  )
}

export default SettingsPage
EOF

    cat > "$APP_DIR/frontend/src/pages/ProfilePage.tsx" << 'EOF'
import React, { useState } from 'react'
import { useMutation, useQueryClient } from 'react-query'
import { useAuth } from '../contexts/AuthContext'
import { usersAPI } from '../services/api'
import {
  UserIcon,
  EnvelopeIcon,
  PhoneIcon,
  CalendarIcon,
  MapPinIcon,
  ShieldCheckIcon,
  KeyIcon,
  EyeIcon,
  EyeSlashIcon,
  PencilIcon,
  CheckIcon,
  XMarkIcon,
  ExclamationTriangleIcon,
  InformationCircleIcon,
  ClockIcon,
  DocumentTextIcon,
  CogIcon,
  BellIcon,
  GlobeAltIcon,
  LockClosedIcon,
  UserGroupIcon,
  AcademicCapIcon,
  BriefcaseIcon,
  StarIcon,
  TrophyIcon,
  ChartBarIcon,
  ClipboardDocumentListIcon
} from '@heroicons/react/24/outline'
import { format } from 'date-fns'

interface UserProfile {
  id: string
  email: string
  name: string
  firstName: string
  lastName: string
  phone?: string
  address?: string
  city?: string
  state?: string
  zipCode?: string
  country?: string
  role: 'ORGANIZER' | 'BOARD' | 'JUDGE' | 'TALLY_MASTER' | 'AUDITOR' | 'CONTESTANT'
  status: 'ACTIVE' | 'INACTIVE' | 'PENDING' | 'SUSPENDED'
  lastLoginAt?: string
  createdAt: string
  updatedAt: string
  preferences: {
    theme: 'light' | 'dark' | 'system'
    language: string
    timezone: string
    notifications: {
      email: boolean
      push: boolean
      sms: boolean
    }
  }
  certifications: {
    id: string
    name: string
    level: string
    issuedAt: string
    expiresAt?: string
    status: 'ACTIVE' | 'EXPIRED' | 'PENDING'
  }[]
  statistics: {
    totalEvents: number
    totalContests: number
    totalScores: number
    averageScore: number
    lastActivity: string
  }
}

const ProfilePage: React.FC = () => {
  const { user, logout } = useAuth()
  const [activeTab, setActiveTab] = useState('profile')
  const [showPasswordModal, setShowPasswordModal] = useState(false)
  const [showPreferencesModal, setShowPreferencesModal] = useState(false)
  const [formData, setFormData] = useState<Partial<UserProfile>>({})
  const [passwordData, setPasswordData] = useState({
    currentPassword: '',
    newPassword: '',
    confirmPassword: ''
  })
  const [showCurrentPassword, setShowCurrentPassword] = useState(false)
  const [showNewPassword, setShowNewPassword] = useState(false)
  const [showConfirmPassword, setShowConfirmPassword] = useState(false)
  const queryClient = useQueryClient()

  // Mock user profile data
  const userProfile: UserProfile = {
    id: user?.id || '1',
    email: user?.email || 'user@eventmanager.com',
    name: user?.name || 'John Doe',
    firstName: 'John',
    lastName: 'Doe',
    phone: '+1 (555) 123-4567',
    address: '123 Main Street',
    city: 'Anytown',
    state: 'CA',
    zipCode: '12345',
    country: 'United States',
    role: (user?.role as any) || 'JUDGE',
    status: 'ACTIVE',
    lastLoginAt: '2024-01-15T10:30:00Z',
    createdAt: '2024-01-01T00:00:00Z',
    updatedAt: '2024-01-15T10:30:00Z',
    preferences: {
      theme: 'system',
      language: 'en',
      timezone: 'America/Los_Angeles',
      notifications: {
        email: true,
        push: true,
        sms: false
      }
    },
    certifications: [
      {
        id: '1',
        name: 'Certified Judge - Vocal Performance',
        level: 'Advanced',
        issuedAt: '2024-01-01T00:00:00Z',
        expiresAt: '2025-01-01T00:00:00Z',
        status: 'ACTIVE'
      },
      {
        id: '2',
        name: 'Music Theory Certification',
        level: 'Intermediate',
        issuedAt: '2023-06-01T00:00:00Z',
        expiresAt: '2024-06-01T00:00:00Z',
        status: 'ACTIVE'
      }
    ],
    statistics: {
      totalEvents: 12,
      totalContests: 45,
      totalScores: 180,
      averageScore: 87.5,
      lastActivity: '2024-01-15T10:30:00Z'
    }
  }

  const updateProfileMutation = useMutation(
    (data: Partial<UserProfile>) => usersAPI.updateProfile(userProfile.id, data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('userProfile')
        setFormData({})
      }
    }
  )

  const changePasswordMutation = useMutation(
    (data: any) => usersAPI.resetPassword(userProfile.id, data),
    {
      onSuccess: () => {
        setPasswordData({ currentPassword: '', newPassword: '', confirmPassword: '' })
        setShowPasswordModal(false)
      }
    }
  )

  const handleInputChange = (field: string, value: any) => {
    setFormData(prev => ({
      ...prev,
      [field]: value
    }))
  }

  const handlePasswordChange = (field: string, value: string) => {
    setPasswordData(prev => ({
      ...prev,
      [field]: value
    }))
  }

  const handleSaveProfile = () => {
    updateProfileMutation.mutate(formData)
  }

  const handleChangePassword = () => {
    if (passwordData.newPassword !== passwordData.confirmPassword) {
      alert('New passwords do not match')
      return
    }
    changePasswordMutation.mutate(passwordData)
  }

  const getRoleIcon = (role: string) => {
    switch (role) {
      case 'ORGANIZER':
        return <CogIcon className="h-5 w-5 text-blue-500" />
      case 'BOARD':
        return <ShieldCheckIcon className="h-5 w-5 text-purple-500" />
      case 'JUDGE':
        return <AcademicCapIcon className="h-5 w-5 text-green-500" />
      case 'TALLY_MASTER':
        return <ChartBarIcon className="h-5 w-5 text-orange-500" />
      case 'AUDITOR':
        return <ClipboardDocumentListIcon className="h-5 w-5 text-red-500" />
      case 'CONTESTANT':
        return <UserIcon className="h-5 w-5 text-gray-500" />
      default:
        return <UserIcon className="h-5 w-5 text-gray-500" />
    }
  }

  const getRoleColor = (role: string) => {
    switch (role) {
      case 'ORGANIZER':
        return 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200'
      case 'BOARD':
        return 'bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-200'
      case 'JUDGE':
        return 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
      case 'TALLY_MASTER':
        return 'bg-orange-100 text-orange-800 dark:bg-orange-900 dark:text-orange-200'
      case 'AUDITOR':
        return 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200'
      case 'CONTESTANT':
        return 'bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200'
      default:
        return 'bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200'
    }
  }

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'ACTIVE':
        return 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
      case 'INACTIVE':
        return 'bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200'
      case 'PENDING':
        return 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200'
      case 'SUSPENDED':
        return 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200'
      default:
        return 'bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200'
    }
  }

  const tabs = [
    { id: 'profile', name: 'Profile', icon: UserIcon },
    { id: 'preferences', name: 'Preferences', icon: CogIcon },
    { id: 'certifications', name: 'Certifications', icon: AcademicCapIcon },
    { id: 'statistics', name: 'Statistics', icon: ChartBarIcon },
  ]

  return (
    <div className="space-y-6">
      <div className="card">
        <div className="card-header">
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">User Profile</h1>
          <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
            Manage your profile and account settings
          </p>
        </div>
        <div className="card-body">
          <div className="border-b border-gray-200 dark:border-gray-700">
            <nav className="-mb-px flex space-x-8">
              {tabs.map((tab) => (
                <button
                  key={tab.id}
                  onClick={() => setActiveTab(tab.id)}
                  className={`${
                    activeTab === tab.id
                      ? 'border-blue-500 text-blue-600'
                      : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                  } whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm flex items-center`}
                >
                  <tab.icon className="h-5 w-5 mr-2" />
                  {tab.name}
                </button>
              ))}
            </nav>
          </div>

          {activeTab === 'profile' && (
            <div className="mt-6">
              <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
                <div className="lg:col-span-1">
                  <div className="card">
                    <div className="card-body text-center">
                      <div className="mx-auto h-24 w-24 bg-gray-200 dark:bg-gray-700 rounded-full flex items-center justify-center mb-4">
                        <UserIcon className="h-12 w-12 text-gray-400" />
                      </div>
                      <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-2">
                        {userProfile.name}
                      </h3>
                      <p className="text-sm text-gray-600 dark:text-gray-400 mb-4">
                        {userProfile.email}
                      </p>
                      <div className="flex items-center justify-center space-x-2 mb-4">
                        {getRoleIcon(userProfile.role)}
                        <span className={`px-2 py-1 text-xs font-medium rounded-full ${getRoleColor(userProfile.role)}`}>
                          {userProfile.role.replace('_', ' ')}
                        </span>
                      </div>
                      <div className="flex items-center justify-center space-x-2">
                        <span className={`px-2 py-1 text-xs font-medium rounded-full ${getStatusColor(userProfile.status)}`}>
                          {userProfile.status}
                        </span>
                      </div>
                      <div className="mt-6 space-y-2 text-sm text-gray-600 dark:text-gray-400">
                        <div className="flex items-center justify-center">
                          <CalendarIcon className="h-4 w-4 mr-2" />
                          Joined {format(new Date(userProfile.createdAt), 'MMM yyyy')}
                        </div>
                        {userProfile.lastLoginAt && (
                          <div className="flex items-center justify-center">
                            <ClockIcon className="h-4 w-4 mr-2" />
                            Last login {format(new Date(userProfile.lastLoginAt), 'MMM dd, yyyy')}
                          </div>
                        )}
                      </div>
                    </div>
                  </div>
                </div>

                <div className="lg:col-span-2">
                  <div className="card">
                    <div className="card-header">
                      <h3 className="text-lg font-semibold text-gray-900 dark:text-white">Personal Information</h3>
                    </div>
                    <div className="card-body">
                      <form onSubmit={(e) => { e.preventDefault(); handleSaveProfile() }}>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                          <div>
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                              First Name
                            </label>
                            <input
                              type="text"
                              value={formData.firstName || userProfile.firstName}
                              onChange={(e) => handleInputChange('firstName', e.target.value)}
                              className="input"
                            />
                          </div>
                          <div>
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                              Last Name
                            </label>
                            <input
                              type="text"
                              value={formData.lastName || userProfile.lastName}
                              onChange={(e) => handleInputChange('lastName', e.target.value)}
                              className="input"
                            />
                          </div>
                        </div>

                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mt-6">
                          <div>
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                              Email Address
                            </label>
                            <input
                              type="email"
                              value={formData.email || userProfile.email}
                              onChange={(e) => handleInputChange('email', e.target.value)}
                              className="input"
                            />
                          </div>
                          <div>
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                              Phone Number
                            </label>
                            <input
                              type="tel"
                              value={formData.phone || userProfile.phone || ''}
                              onChange={(e) => handleInputChange('phone', e.target.value)}
                              className="input"
                            />
                          </div>
                        </div>

                        <div className="mt-6">
                          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                            Address
                          </label>
                          <input
                            type="text"
                            value={formData.address || userProfile.address || ''}
                            onChange={(e) => handleInputChange('address', e.target.value)}
                            className="input"
                          />
                        </div>

                        <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mt-6">
                          <div>
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                              City
                            </label>
                            <input
                              type="text"
                              value={formData.city || userProfile.city || ''}
                              onChange={(e) => handleInputChange('city', e.target.value)}
                              className="input"
                            />
                          </div>
                          <div>
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                              State
                            </label>
                            <input
                              type="text"
                              value={formData.state || userProfile.state || ''}
                              onChange={(e) => handleInputChange('state', e.target.value)}
                              className="input"
                            />
                          </div>
                          <div>
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                              ZIP Code
                            </label>
                            <input
                              type="text"
                              value={formData.zipCode || userProfile.zipCode || ''}
                              onChange={(e) => handleInputChange('zipCode', e.target.value)}
                              className="input"
                            />
                          </div>
                        </div>

                        <div className="mt-6">
                          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                            Country
                          </label>
                          <input
                            type="text"
                            value={formData.country || userProfile.country || ''}
                            onChange={(e) => handleInputChange('country', e.target.value)}
                            className="input"
                          />
                        </div>

                        <div className="flex justify-end space-x-3 mt-6">
                          <button
                            type="button"
                            onClick={() => setFormData({})}
                            className="btn-secondary"
                          >
                            Reset
                          </button>
                          <button
                            type="submit"
                            className="btn-primary"
                            disabled={updateProfileMutation.isLoading}
                          >
                            {updateProfileMutation.isLoading ? 'Saving...' : 'Save Changes'}
                          </button>
                        </div>
                      </form>
                    </div>
                  </div>

                  <div className="card mt-6">
                    <div className="card-header">
                      <h3 className="text-lg font-semibold text-gray-900 dark:text-white">Security</h3>
                    </div>
                    <div className="card-body">
                      <div className="flex items-center justify-between">
                        <div>
                          <h4 className="text-sm font-medium text-gray-900 dark:text-white">Password</h4>
                          <p className="text-sm text-gray-600 dark:text-gray-400">Update your password to keep your account secure</p>
                        </div>
                        <button
                          onClick={() => setShowPasswordModal(true)}
                          className="btn-outline"
                        >
                          <KeyIcon className="h-4 w-4 mr-2" />
                          Change Password
                        </button>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          )}

          {activeTab === 'preferences' && (
            <div className="mt-6">
              <div className="card">
                <div className="card-header">
                  <h3 className="text-lg font-semibold text-gray-900 dark:text-white">Application Preferences</h3>
                </div>
                <div className="card-body">
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                      <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                        Theme
                      </label>
                      <select
                        value={userProfile.preferences.theme}
                        onChange={(e) => handleInputChange('preferences', { ...userProfile.preferences, theme: e.target.value })}
                        className="input"
                      >
                        <option value="light">Light</option>
                        <option value="dark">Dark</option>
                        <option value="system">System</option>
                      </select>
                    </div>
                    <div>
                      <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                        Language
                      </label>
                      <select
                        value={userProfile.preferences.language}
                        onChange={(e) => handleInputChange('preferences', { ...userProfile.preferences, language: e.target.value })}
                        className="input"
                      >
                        <option value="en">English</option>
                        <option value="es">Spanish</option>
                        <option value="fr">French</option>
                        <option value="de">German</option>
                      </select>
                    </div>
                  </div>

                  <div className="mt-6">
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      Timezone
                    </label>
                    <select
                      value={userProfile.preferences.timezone}
                      onChange={(e) => handleInputChange('preferences', { ...userProfile.preferences, timezone: e.target.value })}
                      className="input"
                    >
                      <option value="UTC">UTC</option>
                      <option value="America/New_York">Eastern Time</option>
                      <option value="America/Chicago">Central Time</option>
                      <option value="America/Denver">Mountain Time</option>
                      <option value="America/Los_Angeles">Pacific Time</option>
                    </select>
                  </div>

                  <div className="mt-6">
                    <h4 className="text-sm font-medium text-gray-900 dark:text-white mb-4">Notifications</h4>
                    <div className="space-y-3">
                      <div className="flex items-center">
                        <input
                          type="checkbox"
                          checked={userProfile.preferences.notifications.email}
                          onChange={(e) => handleInputChange('preferences', {
                            ...userProfile.preferences,
                            notifications: { ...userProfile.preferences.notifications, email: e.target.checked }
                          })}
                          className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                        />
                        <label className="ml-2 block text-sm text-gray-700 dark:text-gray-300">
                          Email Notifications
                        </label>
                      </div>
                      <div className="flex items-center">
                        <input
                          type="checkbox"
                          checked={userProfile.preferences.notifications.push}
                          onChange={(e) => handleInputChange('preferences', {
                            ...userProfile.preferences,
                            notifications: { ...userProfile.preferences.notifications, push: e.target.checked }
                          })}
                          className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                        />
                        <label className="ml-2 block text-sm text-gray-700 dark:text-gray-300">
                          Push Notifications
                        </label>
                      </div>
                      <div className="flex items-center">
                        <input
                          type="checkbox"
                          checked={userProfile.preferences.notifications.sms}
                          onChange={(e) => handleInputChange('preferences', {
                            ...userProfile.preferences,
                            notifications: { ...userProfile.preferences.notifications, sms: e.target.checked }
                          })}
                          className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                        />
                        <label className="ml-2 block text-sm text-gray-700 dark:text-gray-300">
                          SMS Notifications
                        </label>
                      </div>
                    </div>
                  </div>

                  <div className="flex justify-end space-x-3 mt-6">
                    <button
                      onClick={() => setFormData({})}
                      className="btn-secondary"
                    >
                      Reset
                    </button>
                    <button
                      onClick={handleSaveProfile}
                      className="btn-primary"
                      disabled={updateProfileMutation.isLoading}
                    >
                      {updateProfileMutation.isLoading ? 'Saving...' : 'Save Preferences'}
                    </button>
                  </div>
                </div>
              </div>
            </div>
          )}

          {activeTab === 'certifications' && (
            <div className="mt-6">
              <div className="card">
                <div className="card-header">
                  <h3 className="text-lg font-semibold text-gray-900 dark:text-white">Certifications</h3>
                  <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
                    Your professional certifications and qualifications
                  </p>
                </div>
                <div className="card-body">
                  <div className="space-y-4">
                    {userProfile.certifications.map((cert) => (
                      <div key={cert.id} className="border border-gray-200 dark:border-gray-700 rounded-lg p-4">
                        <div className="flex items-start justify-between">
                          <div className="flex items-start">
                            <AcademicCapIcon className="h-6 w-6 text-blue-500 mr-3 mt-1" />
                            <div>
                              <h4 className="text-sm font-medium text-gray-900 dark:text-white">
                                {cert.name}
                              </h4>
                              <p className="text-sm text-gray-600 dark:text-gray-400">
                                Level: {cert.level}
                              </p>
                              <div className="flex items-center space-x-4 mt-2 text-xs text-gray-500 dark:text-gray-400">
                                <span>Issued: {format(new Date(cert.issuedAt), 'MMM dd, yyyy')}</span>
                                {cert.expiresAt && (
                                  <span>Expires: {format(new Date(cert.expiresAt), 'MMM dd, yyyy')}</span>
                                )}
                              </div>
                            </div>
                          </div>
                          <span className={`px-2 py-1 text-xs font-medium rounded-full ${
                            cert.status === 'ACTIVE' ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200' :
                            cert.status === 'EXPIRED' ? 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200' :
                            'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200'
                          }`}>
                            {cert.status}
                          </span>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
            </div>
          )}

          {activeTab === 'statistics' && (
            <div className="mt-6">
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
                <div className="card">
                  <div className="card-body">
                    <div className="flex items-center">
                      <CalendarIcon className="h-8 w-8 text-blue-500" />
                      <div className="ml-4">
                        <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Events Participated</p>
                        <p className="text-2xl font-semibold text-gray-900 dark:text-white">{userProfile.statistics.totalEvents}</p>
                      </div>
                    </div>
                  </div>
                </div>
                <div className="card">
                  <div className="card-body">
                    <div className="flex items-center">
                      <TrophyIcon className="h-8 w-8 text-yellow-500" />
                      <div className="ml-4">
                        <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Contests Judged</p>
                        <p className="text-2xl font-semibold text-gray-900 dark:text-white">{userProfile.statistics.totalContests}</p>
                      </div>
                    </div>
                  </div>
                </div>
                <div className="card">
                  <div className="card-body">
                    <div className="flex items-center">
                      <ChartBarIcon className="h-8 w-8 text-green-500" />
                      <div className="ml-4">
                        <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Scores Submitted</p>
                        <p className="text-2xl font-semibold text-gray-900 dark:text-white">{userProfile.statistics.totalScores}</p>
                      </div>
                    </div>
                  </div>
                </div>
                <div className="card">
                  <div className="card-body">
                    <div className="flex items-center">
                      <StarIcon className="h-8 w-8 text-purple-500" />
                      <div className="ml-4">
                        <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Average Score</p>
                        <p className="text-2xl font-semibold text-gray-900 dark:text-white">{userProfile.statistics.averageScore}</p>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <div className="card">
                <div className="card-header">
                  <h3 className="text-lg font-semibold text-gray-900 dark:text-white">Activity Summary</h3>
                </div>
                <div className="card-body">
                  <div className="text-center py-8">
                    <ClockIcon className="h-12 w-12 text-gray-400 mx-auto mb-4" />
                    <h4 className="text-lg font-medium text-gray-900 dark:text-white mb-2">Recent Activity</h4>
                    <p className="text-gray-600 dark:text-gray-400">
                      Last activity: {format(new Date(userProfile.statistics.lastActivity), 'MMM dd, yyyy HH:mm')}
                    </p>
                  </div>
                </div>
              </div>
            </div>
          )}
        </div>
      </div>

      {/* Change Password Modal */}
      {showPasswordModal && (
        <div className="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
          <div className="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white dark:bg-gray-800">
            <div className="mt-3">
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-lg font-medium text-gray-900 dark:text-white">
                  Change Password
                </h3>
                <button
                  onClick={() => setShowPasswordModal(false)}
                  className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
                >
                  <XMarkIcon className="h-6 w-6" />
                </button>
              </div>
              
              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                    Current Password
                  </label>
                  <div className="relative">
                    <input
                      type={showCurrentPassword ? 'text' : 'password'}
                      value={passwordData.currentPassword}
                      onChange={(e) => handlePasswordChange('currentPassword', e.target.value)}
                      className="input pr-10"
                    />
                    <button
                      type="button"
                      onClick={() => setShowCurrentPassword(!showCurrentPassword)}
                      className="absolute inset-y-0 right-0 pr-3 flex items-center"
                    >
                      {showCurrentPassword ? (
                        <EyeSlashIcon className="h-5 w-5 text-gray-400" />
                      ) : (
                        <EyeIcon className="h-5 w-5 text-gray-400" />
                      )}
                    </button>
                  </div>
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                    New Password
                  </label>
                  <div className="relative">
                    <input
                      type={showNewPassword ? 'text' : 'password'}
                      value={passwordData.newPassword}
                      onChange={(e) => handlePasswordChange('newPassword', e.target.value)}
                      className="input pr-10"
                    />
                    <button
                      type="button"
                      onClick={() => setShowNewPassword(!showNewPassword)}
                      className="absolute inset-y-0 right-0 pr-3 flex items-center"
                    >
                      {showNewPassword ? (
                        <EyeSlashIcon className="h-5 w-5 text-gray-400" />
                      ) : (
                        <EyeIcon className="h-5 w-5 text-gray-400" />
                      )}
                    </button>
                  </div>
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                    Confirm New Password
                  </label>
                  <div className="relative">
                    <input
                      type={showConfirmPassword ? 'text' : 'password'}
                      value={passwordData.confirmPassword}
                      onChange={(e) => handlePasswordChange('confirmPassword', e.target.value)}
                      className="input pr-10"
                    />
                    <button
                      type="button"
                      onClick={() => setShowConfirmPassword(!showConfirmPassword)}
                      className="absolute inset-y-0 right-0 pr-3 flex items-center"
                    >
                      {showConfirmPassword ? (
                        <EyeSlashIcon className="h-5 w-5 text-gray-400" />
                      ) : (
                        <EyeIcon className="h-5 w-5 text-gray-400" />
                      )}
                    </button>
                  </div>
                </div>
              </div>
              
              <div className="flex justify-end space-x-3 mt-6">
                <button
                  onClick={() => setShowPasswordModal(false)}
                  className="btn-secondary"
                >
                  Cancel
                </button>
                <button
                  onClick={handleChangePassword}
                  className="btn-primary"
                  disabled={changePasswordMutation.isLoading}
                >
                  {changePasswordMutation.isLoading ? 'Changing...' : 'Change Password'}
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}

export default ProfilePage
EOF

    cat > "$APP_DIR/frontend/src/pages/EmceePage.tsx" << 'EOF'
import React, { useState } from 'react'
import { useQuery, useMutation, useQueryClient } from 'react-query'
import { useAuth } from '../contexts/AuthContext'
import { eventsAPI, contestsAPI, categoriesAPI } from '../services/api'
import {
  DocumentTextIcon,
  PlusIcon,
  PencilIcon,
  TrashIcon,
  EyeIcon,
  MagnifyingGlassIcon,
  ClockIcon,
  CalendarIcon,
  UserIcon,
  ClipboardDocumentListIcon,
  SpeakerWaveIcon,
  MicrophoneIcon,
  PlayIcon,
  PauseIcon,
  StopIcon,
  DocumentDuplicateIcon,
  TagIcon,
  StarIcon,
  CheckCircleIcon,
  ExclamationTriangleIcon,
  InformationCircleIcon,
  XMarkIcon,
  ArrowDownTrayIcon,
  ArrowUpTrayIcon,
  CogIcon,
  BellIcon,
  MegaphoneIcon,
  PresentationChartLineIcon,
  ChartBarIcon,
  ClipboardDocumentCheckIcon
} from '@heroicons/react/24/outline'
import { format } from 'date-fns'

interface EmceeScript {
  id: string
  name: string
  description: string
  content: string
  type: 'WELCOME' | 'INTRO' | 'ANNOUNCEMENT' | 'AWARD' | 'CLOSING' | 'CUSTOM' | 'TRANSITION' | 'EMERGENCY' | 'BREAK'
  eventId?: string
  contestId?: string
  categoryId?: string
  duration: number
  isPublic: boolean
  tags: string[]
  usageCount: number
  createdBy: string
  createdAt: string
  updatedAt: string
  lastUsedAt?: string
  status: 'DRAFT' | 'ACTIVE' | 'ARCHIVED'
}

interface ScriptUsage {
  id: string
  scriptId: string
  eventId: string
  contestId?: string
  categoryId?: string
  usedBy: string
  usedAt: string
  duration: number
  notes?: string
}

const EmceePage: React.FC = () => {
  const { user } = useAuth()
  const [activeTab, setActiveTab] = useState('scripts')
  const [showCreateModal, setShowCreateModal] = useState(false)
  const [showEditModal, setShowEditModal] = useState(false)
  const [showPreviewModal, setShowPreviewModal] = useState(false)
  const [selectedScript, setSelectedScript] = useState<EmceeScript | null>(null)
  const [formData, setFormData] = useState<Partial<EmceeScript>>({})
  const [filters, setFilters] = useState({
    search: '',
    type: '',
    status: '',
    eventId: ''
  })
  const [isPlaying, setIsPlaying] = useState(false)
  const [currentTime, setCurrentTime] = useState(0)
  const queryClient = useQueryClient()

  // Fetch data for scripts
  const { data: events } = useQuery('events', () => eventsAPI.getAll().then((res: any) => res.data))
  const { data: contests } = useQuery('contests', () => contestsAPI.getAll().then((res: any) => res.data))
  const { data: categories } = useQuery('categories', () => categoriesAPI.getAll().then((res: any) => res.data))

  // Mock data for scripts
  const emceeScripts: EmceeScript[] = [
    {
      id: '1',
      name: 'Welcome Address - Spring Competition',
      description: 'Opening welcome speech for the Spring Competition event',
      content: 'Good evening, ladies and gentlemen! Welcome to the Spring Competition 2024. We are thrilled to have you here tonight for what promises to be an evening filled with incredible talent and unforgettable performances. Tonight, we will witness the dedication and artistry of our talented contestants as they showcase their skills in various categories. Let\'s give them all a warm round of applause!',
      type: 'WELCOME',
      eventId: '1',
      duration: 120,
      isPublic: true,
      tags: ['welcome', 'opening', 'spring', 'competition'],
      usageCount: 8,
      createdBy: 'admin@eventmanager.com',
      createdAt: '2024-01-01T00:00:00Z',
      updatedAt: '2024-01-15T10:30:00Z',
      lastUsedAt: '2024-01-15T10:30:00Z',
      status: 'ACTIVE'
    },
    {
      id: '2',
      name: 'Vocal Solo Introduction',
      description: 'Introduction for vocal solo performances',
      content: 'Next up, we have our vocal solo category. This is where we get to hear the beautiful voices of our talented singers. Each contestant will perform a piece of their choice, showcasing their vocal range, technique, and musical interpretation. Please welcome our first vocal soloist!',
      type: 'INTRO',
      contestId: '1',
      categoryId: '1',
      duration: 45,
      isPublic: true,
      tags: ['vocal', 'solo', 'introduction', 'singing'],
      usageCount: 15,
      createdBy: 'emcee@eventmanager.com',
      createdAt: '2024-01-05T00:00:00Z',
      updatedAt: '2024-01-12T14:20:00Z',
      lastUsedAt: '2024-01-12T14:20:00Z',
      status: 'ACTIVE'
    },
    {
      id: '3',
      name: 'Award Presentation - First Place',
      description: 'Script for presenting first place awards',
      content: 'And now, the moment we\'ve all been waiting for! The first place winner in the [Category Name] category has demonstrated exceptional skill, dedication, and artistry. Their performance tonight was truly outstanding and deserving of this recognition. Please join me in congratulating our first place winner!',
      type: 'AWARD',
      duration: 60,
      isPublic: false,
      tags: ['award', 'first-place', 'winner', 'recognition'],
      usageCount: 5,
      createdBy: 'organizer@eventmanager.com',
      createdAt: '2024-01-08T00:00:00Z',
      updatedAt: '2024-01-10T09:15:00Z',
      lastUsedAt: '2024-01-10T09:15:00Z',
      status: 'ACTIVE'
    },
    {
      id: '4',
      name: 'Intermission Announcement',
      description: 'Announcement for intermission break',
      content: 'We\'ll now take a 15-minute intermission. Please feel free to visit our refreshment stand, use the restrooms, or simply stretch your legs. We\'ll resume with the second half of our program in 15 minutes. Thank you for your patience!',
      type: 'BREAK',
      duration: 30,
      isPublic: true,
      tags: ['intermission', 'break', 'announcement'],
      usageCount: 12,
      createdBy: 'admin@eventmanager.com',
      createdAt: '2024-01-03T00:00:00Z',
      updatedAt: '2024-01-14T16:45:00Z',
      lastUsedAt: '2024-01-14T16:45:00Z',
      status: 'ACTIVE'
    },
    {
      id: '5',
      name: 'Closing Remarks',
      description: 'Closing speech for the event',
      content: 'What an incredible evening this has been! We\'ve witnessed some truly remarkable performances from all of our talented contestants. Each and every one of you should be proud of your dedication and hard work. Thank you to our judges, volunteers, and everyone who made this event possible. Until next time, goodnight and thank you for coming!',
      type: 'CLOSING',
      eventId: '1',
      duration: 90,
      isPublic: true,
      tags: ['closing', 'thank-you', 'farewell', 'event-end'],
      usageCount: 6,
      createdBy: 'admin@eventmanager.com',
      createdAt: '2024-01-01T00:00:00Z',
      updatedAt: '2024-01-15T10:30:00Z',
      lastUsedAt: '2024-01-15T10:30:00Z',
      status: 'ACTIVE'
    }
  ]

  const scriptUsage: ScriptUsage[] = [
    {
      id: '1',
      scriptId: '1',
      eventId: '1',
      usedBy: 'emcee@eventmanager.com',
      usedAt: '2024-01-15T10:30:00Z',
      duration: 125,
      notes: 'Used for Spring Competition opening'
    },
    {
      id: '2',
      scriptId: '2',
      eventId: '1',
      contestId: '1',
      categoryId: '1',
      usedBy: 'emcee@eventmanager.com',
      usedAt: '2024-01-15T11:15:00Z',
      duration: 42,
      notes: 'Vocal solo category introduction'
    }
  ]

  const filteredScripts = emceeScripts.filter(script => {
    const matchesSearch = script.name.toLowerCase().includes(filters.search.toLowerCase()) ||
                         script.description.toLowerCase().includes(filters.search.toLowerCase()) ||
                         script.content.toLowerCase().includes(filters.search.toLowerCase()) ||
                         script.tags.some(tag => tag.toLowerCase().includes(filters.search.toLowerCase()))
    const matchesType = !filters.type || script.type === filters.type
    const matchesStatus = !filters.status || script.status === filters.status
    const matchesEvent = !filters.eventId || script.eventId === filters.eventId

    return matchesSearch && matchesType && matchesStatus && matchesEvent
  })

  const handleCreateScript = () => {
    setFormData({
      name: '',
      description: '',
      content: '',
      type: 'WELCOME',
      duration: 60,
      isPublic: true,
      tags: [],
      status: 'DRAFT'
    })
    setShowCreateModal(true)
  }

  const handleEditScript = (script: EmceeScript) => {
    setSelectedScript(script)
    setFormData(script)
    setShowEditModal(true)
  }

  const handlePreviewScript = (script: EmceeScript) => {
    setSelectedScript(script)
    setShowPreviewModal(true)
  }

  const handleSaveScript = () => {
    // Mock save operation
    console.log('Saving script:', formData)
    setShowCreateModal(false)
    setShowEditModal(false)
    setFormData({})
    setSelectedScript(null)
  }

  const handleDeleteScript = (scriptId: string) => {
    if (confirm('Are you sure you want to delete this script?')) {
      // Mock delete operation
      console.log('Deleting script:', scriptId)
    }
  }

  const handleDuplicateScript = (script: EmceeScript) => {
    setFormData({
      ...script,
      name: `${script.name} (Copy)`,
      id: undefined
    })
    setShowCreateModal(true)
  }

  const addTag = (tag: string) => {
    if (tag && !formData.tags?.includes(tag)) {
      setFormData(prev => ({
        ...prev,
        tags: [...(prev.tags || []), tag]
      }))
    }
  }

  const removeTag = (tagToRemove: string) => {
    setFormData(prev => ({
      ...prev,
      tags: prev.tags?.filter(tag => tag !== tagToRemove)
    }))
  }

  const getTypeIcon = (type: string) => {
    switch (type) {
      case 'WELCOME':
        return <MegaphoneIcon className="h-5 w-5 text-blue-500" />
      case 'INTRO':
        return <MicrophoneIcon className="h-5 w-5 text-green-500" />
      case 'ANNOUNCEMENT':
        return <BellIcon className="h-5 w-5 text-yellow-500" />
      case 'AWARD':
        return <StarIcon className="h-5 w-5 text-purple-500" />
      case 'CLOSING':
        return <SpeakerWaveIcon className="h-5 w-5 text-red-500" />
      case 'CUSTOM':
        return <DocumentTextIcon className="h-5 w-5 text-gray-500" />
      case 'TRANSITION':
        return <ArrowDownTrayIcon className="h-5 w-5 text-indigo-500" />
      case 'EMERGENCY':
        return <ExclamationTriangleIcon className="h-5 w-5 text-red-500" />
      case 'BREAK':
        return <PauseIcon className="h-5 w-5 text-orange-500" />
      default:
        return <DocumentTextIcon className="h-5 w-5 text-gray-500" />
    }
  }

  const getTypeColor = (type: string) => {
    switch (type) {
      case 'WELCOME':
        return 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200'
      case 'INTRO':
        return 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
      case 'ANNOUNCEMENT':
        return 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200'
      case 'AWARD':
        return 'bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-200'
      case 'CLOSING':
        return 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200'
      case 'CUSTOM':
        return 'bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200'
      case 'TRANSITION':
        return 'bg-indigo-100 text-indigo-800 dark:bg-indigo-900 dark:text-indigo-200'
      case 'EMERGENCY':
        return 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200'
      case 'BREAK':
        return 'bg-orange-100 text-orange-800 dark:bg-orange-900 dark:text-orange-200'
      default:
        return 'bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200'
    }
  }

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'ACTIVE':
        return 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
      case 'DRAFT':
        return 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200'
      case 'ARCHIVED':
        return 'bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200'
      default:
        return 'bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200'
    }
  }

  const tabs = [
    { id: 'scripts', name: 'Scripts', icon: DocumentTextIcon },
    { id: 'usage', name: 'Usage History', icon: ClipboardDocumentListIcon },
    { id: 'analytics', name: 'Analytics', icon: ChartBarIcon },
  ]

  const canManageScripts = user?.role === 'ORGANIZER' || user?.role === 'BOARD' || user?.role === 'JUDGE'

  return (
    <div className="space-y-6">
      <div className="card">
        <div className="card-header">
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Emcee Scripts</h1>
          <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
            Manage emcee scripts and announcements for events
          </p>
        </div>
        <div className="card-body">
          <div className="border-b border-gray-200 dark:border-gray-700">
            <nav className="-mb-px flex space-x-8">
              {tabs.map((tab) => (
                <button
                  key={tab.id}
                  onClick={() => setActiveTab(tab.id)}
                  className={`${
                    activeTab === tab.id
                      ? 'border-blue-500 text-blue-600'
                      : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                  } whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm flex items-center`}
                >
                  <tab.icon className="h-5 w-5 mr-2" />
                  {tab.name}
                </button>
              ))}
            </nav>
          </div>

          {activeTab === 'scripts' && (
            <div className="mt-6">
              <div className="flex flex-col sm:flex-row gap-4 mb-6">
                <div className="flex-1">
                  <div className="relative">
                    <MagnifyingGlassIcon className="h-5 w-5 absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" />
                    <input
                      type="text"
                      placeholder="Search scripts..."
                      value={filters.search}
                      onChange={(e) => setFilters(prev => ({ ...prev, search: e.target.value }))}
                      className="input pl-10"
                    />
                  </div>
                </div>
                <select
                  value={filters.type}
                  onChange={(e) => setFilters(prev => ({ ...prev, type: e.target.value }))}
                  className="input"
                >
                  <option value="">All Types</option>
                  <option value="WELCOME">Welcome</option>
                  <option value="INTRO">Introduction</option>
                  <option value="ANNOUNCEMENT">Announcement</option>
                  <option value="AWARD">Award</option>
                  <option value="CLOSING">Closing</option>
                  <option value="CUSTOM">Custom</option>
                  <option value="TRANSITION">Transition</option>
                  <option value="EMERGENCY">Emergency</option>
                  <option value="BREAK">Break</option>
                </select>
                <select
                  value={filters.status}
                  onChange={(e) => setFilters(prev => ({ ...prev, status: e.target.value }))}
                  className="input"
                >
                  <option value="">All Status</option>
                  <option value="ACTIVE">Active</option>
                  <option value="DRAFT">Draft</option>
                  <option value="ARCHIVED">Archived</option>
                </select>
                {canManageScripts && (
                  <button
                    onClick={handleCreateScript}
                    className="btn-primary"
                  >
                    <PlusIcon className="h-5 w-5 mr-2" />
                    New Script
                  </button>
                )}
              </div>

              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                {filteredScripts.map((script) => (
                  <div key={script.id} className="card">
                    <div className="card-body">
                      <div className="flex items-start justify-between mb-3">
                        <div className="flex items-center">
                          {getTypeIcon(script.type)}
                          <h3 className="text-lg font-semibold text-gray-900 dark:text-white ml-2">
                            {script.name}
                          </h3>
                        </div>
                        <span className={`px-2 py-1 text-xs font-medium rounded-full ${getTypeColor(script.type)}`}>
                          {script.type}
                        </span>
                      </div>
                      <p className="text-sm text-gray-600 dark:text-gray-400 mb-4">
                        {script.description}
                      </p>
                      
                      <div className="space-y-2 mb-4">
                        <div className="flex items-center text-sm text-gray-600 dark:text-gray-400">
                          <ClockIcon className="h-4 w-4 mr-2" />
                          {script.duration} seconds
                        </div>
                        <div className="flex items-center text-sm text-gray-600 dark:text-gray-400">
                          <ArrowDownTrayIcon className="h-4 w-4 mr-2" />
                          Used {script.usageCount} times
                        </div>
                        {script.lastUsedAt && (
                          <div className="flex items-center text-sm text-gray-600 dark:text-gray-400">
                            <CalendarIcon className="h-4 w-4 mr-2" />
                            Last used {format(new Date(script.lastUsedAt), 'MMM dd, yyyy')}
                          </div>
                        )}
                      </div>

                      <div className="flex flex-wrap gap-1 mb-4">
                        {script.tags.map((tag) => (
                          <span key={tag} className="px-2 py-1 text-xs bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-400 rounded">
                            {tag}
                          </span>
                        ))}
                      </div>

                      <div className="flex items-center justify-between">
                        <span className={`px-2 py-1 text-xs font-medium rounded-full ${getStatusColor(script.status)}`}>
                          {script.status}
                        </span>
                        <div className="flex space-x-2">
                          <button
                            onClick={() => handlePreviewScript(script)}
                            className="text-blue-600 hover:text-blue-900 dark:text-blue-400 dark:hover:text-blue-300"
                            title="Preview"
                          >
                            <EyeIcon className="h-4 w-4" />
                          </button>
                          {canManageScripts && (
                            <>
                              <button
                                onClick={() => handleDuplicateScript(script)}
                                className="text-green-600 hover:text-green-900 dark:text-green-400 dark:hover:text-green-300"
                                title="Duplicate"
                              >
                                <DocumentDuplicateIcon className="h-4 w-4" />
                              </button>
                              <button
                                onClick={() => handleEditScript(script)}
                                className="text-yellow-600 hover:text-yellow-900 dark:text-yellow-400 dark:hover:text-yellow-300"
                                title="Edit"
                              >
                                <PencilIcon className="h-4 w-4" />
                              </button>
                              <button
                                onClick={() => handleDeleteScript(script.id)}
                                className="text-red-600 hover:text-red-900 dark:text-red-400 dark:hover:text-red-300"
                                title="Delete"
                              >
                                <TrashIcon className="h-4 w-4" />
                              </button>
                            </>
                          )}
                        </div>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}

          {activeTab === 'usage' && (
            <div className="mt-6">
              <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                  <thead className="bg-gray-50 dark:bg-gray-800">
                    <tr>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                        Script
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                        Event
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                        Used By
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                        Duration
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                        Used At
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                        Notes
                      </th>
                    </tr>
                  </thead>
                  <tbody className="bg-white dark:bg-gray-900 divide-y divide-gray-200 dark:divide-gray-700">
                    {scriptUsage.map((usage) => {
                      const script = emceeScripts.find(s => s.id === usage.scriptId)
                      return (
                        <tr key={usage.id}>
                          <td className="px-6 py-4 whitespace-nowrap">
                            <div className="text-sm font-medium text-gray-900 dark:text-white">
                              {script?.name || 'Unknown Script'}
                            </div>
                            <div className="text-sm text-gray-600 dark:text-gray-400">
                              {script?.type || 'Unknown Type'}
                            </div>
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-600 dark:text-gray-400">
                            Event {usage.eventId}
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-600 dark:text-gray-400">
                            {usage.usedBy}
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-600 dark:text-gray-400">
                            {usage.duration}s
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-600 dark:text-gray-400">
                            {format(new Date(usage.usedAt), 'MMM dd, yyyy HH:mm')}
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-600 dark:text-gray-400">
                            {usage.notes || '-'}
                          </td>
                        </tr>
                      )
                    })}
                  </tbody>
                </table>
              </div>
            </div>
          )}

          {activeTab === 'analytics' && (
            <div className="mt-6">
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
                <div className="card">
                  <div className="card-body">
                    <div className="flex items-center">
                      <DocumentTextIcon className="h-8 w-8 text-blue-500" />
                      <div className="ml-4">
                        <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Total Scripts</p>
                        <p className="text-2xl font-semibold text-gray-900 dark:text-white">{emceeScripts.length}</p>
                      </div>
                    </div>
                  </div>
                </div>
                <div className="card">
                  <div className="card-body">
                    <div className="flex items-center">
                      <ArrowDownTrayIcon className="h-8 w-8 text-green-500" />
                      <div className="ml-4">
                        <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Total Usage</p>
                        <p className="text-2xl font-semibold text-gray-900 dark:text-white">
                          {emceeScripts.reduce((sum, s) => sum + s.usageCount, 0)}
                        </p>
                      </div>
                    </div>
                  </div>
                </div>
                <div className="card">
                  <div className="card-body">
                    <div className="flex items-center">
                      <CheckCircleIcon className="h-8 w-8 text-green-500" />
                      <div className="ml-4">
                        <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Active Scripts</p>
                        <p className="text-2xl font-semibold text-gray-900 dark:text-white">
                          {emceeScripts.filter(s => s.status === 'ACTIVE').length}
                        </p>
                      </div>
                    </div>
                  </div>
                </div>
                <div className="card">
                  <div className="card-body">
                    <div className="flex items-center">
                      <ExclamationTriangleIcon className="h-8 w-8 text-yellow-500" />
                      <div className="ml-4">
                        <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Draft Scripts</p>
                        <p className="text-2xl font-semibold text-gray-900 dark:text-white">
                          {emceeScripts.filter(s => s.status === 'DRAFT').length}
                        </p>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <div className="card">
                  <div className="card-header">
                    <h3 className="text-lg font-semibold text-gray-900 dark:text-white">Script Types</h3>
                  </div>
                  <div className="card-body">
                    <div className="space-y-4">
                      {['WELCOME', 'INTRO', 'ANNOUNCEMENT', 'AWARD', 'CLOSING', 'CUSTOM', 'TRANSITION', 'EMERGENCY', 'BREAK'].map((type) => {
                        const count = emceeScripts.filter(s => s.type === type).length
                        return (
                          <div key={type} className="flex items-center justify-between">
                            <span className="text-sm text-gray-600 dark:text-gray-400 capitalize">{type.toLowerCase()}</span>
                            <div className="flex items-center">
                              <div className="w-32 bg-gray-200 dark:bg-gray-700 rounded-full h-2 mr-3">
                                <div 
                                  className="bg-blue-500 h-2 rounded-full" 
                                  style={{ width: `${(count / emceeScripts.length) * 100}%` }}
                                ></div>
                              </div>
                              <span className="text-sm font-medium text-gray-900 dark:text-white">{count}</span>
                            </div>
                          </div>
                        )
                      })}
                    </div>
                  </div>
                </div>

                <div className="card">
                  <div className="card-header">
                    <h3 className="text-lg font-semibold text-gray-900 dark:text-white">Most Used Scripts</h3>
                  </div>
                  <div className="card-body">
                    <div className="space-y-3">
                      {emceeScripts
                        .sort((a, b) => b.usageCount - a.usageCount)
                        .slice(0, 5)
                        .map((script) => (
                        <div key={script.id} className="flex items-center justify-between">
                          <div className="flex items-center">
                            {getTypeIcon(script.type)}
                            <div className="ml-3">
                              <p className="text-sm font-medium text-gray-900 dark:text-white">{script.name}</p>
                              <p className="text-xs text-gray-500 dark:text-gray-400">{script.type}</p>
                            </div>
                          </div>
                          <span className="text-sm font-medium text-gray-900 dark:text-white">{script.usageCount}</span>
                        </div>
                      ))}
                    </div>
                  </div>
                </div>
              </div>
            </div>
          )}
        </div>
      </div>

      {/* Create/Edit Script Modal */}
      {(showCreateModal || showEditModal) && (
        <div className="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
          <div className="relative top-20 mx-auto p-5 border w-full max-w-4xl shadow-lg rounded-md bg-white dark:bg-gray-800">
            <div className="mt-3">
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-lg font-medium text-gray-900 dark:text-white">
                  {showCreateModal ? 'Create New Script' : 'Edit Script'}
                </h3>
                <button
                  onClick={() => {
                    setShowCreateModal(false)
                    setShowEditModal(false)
                    setFormData({})
                    setSelectedScript(null)
                  }}
                  className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
                >
                  <XMarkIcon className="h-6 w-6" />
                </button>
              </div>
              
              <div className="space-y-6">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      Script Name *
                    </label>
                    <input
                      type="text"
                      value={formData.name || ''}
                      onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))}
                      className="input"
                      placeholder="Enter script name"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      Script Type *
                    </label>
                    <select
                      value={formData.type || 'WELCOME'}
                      onChange={(e) => setFormData(prev => ({ ...prev, type: e.target.value as any }))}
                      className="input"
                    >
                      <option value="WELCOME">Welcome</option>
                      <option value="INTRO">Introduction</option>
                      <option value="ANNOUNCEMENT">Announcement</option>
                      <option value="AWARD">Award</option>
                      <option value="CLOSING">Closing</option>
                      <option value="CUSTOM">Custom</option>
                      <option value="TRANSITION">Transition</option>
                      <option value="EMERGENCY">Emergency</option>
                      <option value="BREAK">Break</option>
                    </select>
                  </div>
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                    Description *
                  </label>
                  <textarea
                    value={formData.description || ''}
                    onChange={(e) => setFormData(prev => ({ ...prev, description: e.target.value }))}
                    className="input"
                    rows={2}
                    placeholder="Enter script description"
                  />
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                    Script Content *
                  </label>
                  <textarea
                    value={formData.content || ''}
                    onChange={(e) => setFormData(prev => ({ ...prev, content: e.target.value }))}
                    className="input"
                    rows={8}
                    placeholder="Enter script content..."
                  />
                </div>

                <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      Duration (seconds)
                    </label>
                    <input
                      type="number"
                      value={formData.duration || 60}
                      onChange={(e) => setFormData(prev => ({ ...prev, duration: parseInt(e.target.value) }))}
                      className="input"
                      min="1"
                      max="600"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      Status
                    </label>
                    <select
                      value={formData.status || 'DRAFT'}
                      onChange={(e) => setFormData(prev => ({ ...prev, status: e.target.value as any }))}
                      className="input"
                    >
                      <option value="DRAFT">Draft</option>
                      <option value="ACTIVE">Active</option>
                      <option value="ARCHIVED">Archived</option>
                    </select>
                  </div>
                  <div className="flex items-center">
                    <input
                      type="checkbox"
                      checked={formData.isPublic || false}
                      onChange={(e) => setFormData(prev => ({ ...prev, isPublic: e.target.checked }))}
                      className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                    />
                    <label className="ml-2 block text-sm text-gray-700 dark:text-gray-300">
                      Public Script
                    </label>
                  </div>
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                    Tags
                  </label>
                  <div className="flex flex-wrap gap-2 mb-2">
                    {formData.tags?.map((tag) => (
                      <span key={tag} className="px-2 py-1 text-xs bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 rounded flex items-center">
                        {tag}
                        <button
                          onClick={() => removeTag(tag)}
                          className="ml-1 text-blue-600 hover:text-blue-800"
                        >
                          <XMarkIcon className="h-3 w-3" />
                        </button>
                      </span>
                    ))}
                  </div>
                  <input
                    type="text"
                    placeholder="Add tag and press Enter"
                    onKeyPress={(e) => {
                      if (e.key === 'Enter') {
                        e.preventDefault()
                        addTag(e.currentTarget.value.trim())
                        e.currentTarget.value = ''
                      }
                    }}
                    className="input"
                  />
                </div>
              </div>
              
              <div className="flex justify-end space-x-3 mt-6">
                <button
                  onClick={() => {
                    setShowCreateModal(false)
                    setShowEditModal(false)
                    setFormData({})
                    setSelectedScript(null)
                  }}
                  className="btn-secondary"
                >
                  Cancel
                </button>
                <button
                  onClick={handleSaveScript}
                  className="btn-primary"
                >
                  {showCreateModal ? 'Create Script' : 'Save Changes'}
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Preview Script Modal */}
      {showPreviewModal && selectedScript && (
        <div className="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
          <div className="relative top-20 mx-auto p-5 border w-full max-w-2xl shadow-lg rounded-md bg-white dark:bg-gray-800">
            <div className="mt-3">
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-lg font-medium text-gray-900 dark:text-white">
                  Script Preview: {selectedScript.name}
                </h3>
                <button
                  onClick={() => setShowPreviewModal(false)}
                  className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
                >
                  <XMarkIcon className="h-6 w-6" />
                </button>
              </div>
              
              <div className="space-y-4">
                <div className="flex items-center space-x-4">
                  {getTypeIcon(selectedScript.type)}
                  <span className={`px-2 py-1 text-xs font-medium rounded-full ${getTypeColor(selectedScript.type)}`}>
                    {selectedScript.type}
                  </span>
                  <span className="text-sm text-gray-600 dark:text-gray-400">
                    {selectedScript.duration} seconds
                  </span>
                </div>
                
                <div className="bg-gray-50 dark:bg-gray-700 rounded-lg p-4">
                  <p className="text-gray-900 dark:text-white leading-relaxed">
                    {selectedScript.content}
                  </p>
                </div>
                
                <div className="flex items-center justify-between">
                  <div className="flex space-x-2">
                    <button
                      onClick={() => setIsPlaying(!isPlaying)}
                      className="btn-primary"
                    >
                      {isPlaying ? (
                        <PauseIcon className="h-4 w-4 mr-2" />
                      ) : (
                        <PlayIcon className="h-4 w-4 mr-2" />
                      )}
                      {isPlaying ? 'Pause' : 'Play'}
                    </button>
                    <button
                      onClick={() => setIsPlaying(false)}
                      className="btn-outline"
                    >
                      <StopIcon className="h-4 w-4 mr-2" />
                      Stop
                    </button>
                  </div>
                  <div className="text-sm text-gray-600 dark:text-gray-400">
                    Used {selectedScript.usageCount} times
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}

export default EmceePage
EOF

    cat > "$APP_DIR/frontend/src/pages/TemplatesPage.tsx" << 'EOF'
import React, { useState } from 'react'
import { useQuery, useMutation, useQueryClient } from 'react-query'
import { useAuth } from '../contexts/AuthContext'
import { categoriesAPI, contestsAPI } from '../services/api'
import {
  DocumentDuplicateIcon,
  PlusIcon,
  PencilIcon,
  TrashIcon,
  EyeIcon,
  MagnifyingGlassIcon,
  DocumentTextIcon,
  ClockIcon,
  CalendarIcon,
  UserIcon,
  ClipboardDocumentListIcon,
  CogIcon,
  XMarkIcon,
  CheckCircleIcon,
  ExclamationTriangleIcon,
  InformationCircleIcon,
  StarIcon,
  TagIcon,
  FolderIcon,
  DocumentIcon,
  ArrowDownTrayIcon,
  ArrowUpTrayIcon
} from '@heroicons/react/24/outline'
import { format } from 'date-fns'

interface CategoryTemplate {
  id: string
  name: string
  description: string
  categoryType: 'VOCAL' | 'INSTRUMENTAL' | 'DANCE' | 'SPEECH' | 'DRAMA' | 'OTHER'
  criteria: {
    id: string
    name: string
    description: string
    maxScore: number
    weight: number
    isRequired: boolean
  }[]
  maxContestants: number
  timeLimit: number
  isPublic: boolean
  tags: string[]
  usageCount: number
  createdBy: string
  createdAt: string
  updatedAt: string
}

interface TemplateUsage {
  id: string
  templateId: string
  contestId: string
  categoryId: string
  usedBy: string
  usedAt: string
  contestName: string
  categoryName: string
}

const TemplatesPage: React.FC = () => {
  const { user } = useAuth()
  const [activeTab, setActiveTab] = useState('templates')
  const [showCreateModal, setShowCreateModal] = useState(false)
  const [showEditModal, setShowEditModal] = useState(false)
  const [selectedTemplate, setSelectedTemplate] = useState<CategoryTemplate | null>(null)
  const [formData, setFormData] = useState<Partial<CategoryTemplate>>({})
  const [filters, setFilters] = useState({
    search: '',
    categoryType: '',
    tags: '',
    isPublic: ''
  })
  const queryClient = useQueryClient()

  // Mutations for template management
  const createTemplateMutation = useMutation(
    (data: any) => categoriesAPI.createCategory(data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['categoryTemplates'])
        setShowCreateModal(false)
        setFormData({})
      }
    }
  )

  const updateTemplateMutation = useMutation(
    ({ id, data }: { id: string; data: any }) => categoriesAPI.updateCategory(id, data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['categoryTemplates'])
        setShowEditModal(false)
        setFormData({})
      }
    }
  )

  const deleteTemplateMutation = useMutation(
    (id: string) => categoriesAPI.deleteCategory(id),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['categoryTemplates'])
      }
    }
  )
  const categoryTemplates: CategoryTemplate[] = [
    {
      id: '1',
      name: 'Vocal Solo - Classical',
      description: 'Template for classical vocal solo performances with traditional judging criteria',
      categoryType: 'VOCAL',
      criteria: [
        { id: '1', name: 'Technique', description: 'Vocal technique and control', maxScore: 25, weight: 1.0, isRequired: true },
        { id: '2', name: 'Musicality', description: 'Musical interpretation and expression', maxScore: 25, weight: 1.0, isRequired: true },
        { id: '3', name: 'Stage Presence', description: 'Performance and stage presence', maxScore: 20, weight: 0.8, isRequired: true },
        { id: '4', name: 'Song Choice', description: 'Appropriateness of song selection', maxScore: 15, weight: 0.6, isRequired: false },
        { id: '5', name: 'Overall Impact', description: 'Overall performance impact', maxScore: 15, weight: 0.6, isRequired: true }
      ],
      maxContestants: 20,
      timeLimit: 5,
      isPublic: true,
      tags: ['classical', 'vocal', 'solo', 'traditional'],
      usageCount: 15,
      createdBy: 'admin@eventmanager.com',
      createdAt: '2024-01-01T00:00:00Z',
      updatedAt: '2024-01-15T10:30:00Z'
    },
    {
      id: '2',
      name: 'Piano Solo - Contemporary',
      description: 'Template for contemporary piano solo performances',
      categoryType: 'INSTRUMENTAL',
      criteria: [
        { id: '6', name: 'Technical Skill', description: 'Piano technique and skill', maxScore: 30, weight: 1.0, isRequired: true },
        { id: '7', name: 'Musical Expression', description: 'Musical expression and interpretation', maxScore: 25, weight: 0.8, isRequired: true },
        { id: '8', name: 'Repertoire', description: 'Choice and difficulty of repertoire', maxScore: 20, weight: 0.7, isRequired: true },
        { id: '9', name: 'Stage Presence', description: 'Performance presence and communication', maxScore: 15, weight: 0.5, isRequired: false },
        { id: '10', name: 'Creativity', description: 'Creative interpretation and style', maxScore: 10, weight: 0.3, isRequired: false }
      ],
      maxContestants: 15,
      timeLimit: 8,
      isPublic: true,
      tags: ['piano', 'contemporary', 'solo', 'instrumental'],
      usageCount: 8,
      createdBy: 'judge@eventmanager.com',
      createdAt: '2024-01-05T00:00:00Z',
      updatedAt: '2024-01-10T14:20:00Z'
    },
    {
      id: '3',
      name: 'Dance Group - Modern',
      description: 'Template for modern dance group performances',
      categoryType: 'DANCE',
      criteria: [
        { id: '11', name: 'Choreography', description: 'Originality and creativity of choreography', maxScore: 25, weight: 1.0, isRequired: true },
        { id: '12', name: 'Technique', description: 'Dance technique and execution', maxScore: 25, weight: 1.0, isRequired: true },
        { id: '13', name: 'Synchronization', description: 'Group synchronization and timing', maxScore: 20, weight: 0.8, isRequired: true },
        { id: '14', name: 'Music', description: 'Music selection and interpretation', maxScore: 15, weight: 0.6, isRequired: true },
        { id: '15', name: 'Costume', description: 'Costume design and appropriateness', maxScore: 10, weight: 0.4, isRequired: false },
        { id: '16', name: 'Overall Impact', description: 'Overall performance impact', maxScore: 5, weight: 0.2, isRequired: true }
      ],
      maxContestants: 12,
      timeLimit: 6,
      isPublic: false,
      tags: ['dance', 'modern', 'group', 'choreography'],
      usageCount: 3,
      createdBy: 'organizer@eventmanager.com',
      createdAt: '2024-01-08T00:00:00Z',
      updatedAt: '2024-01-12T09:15:00Z'
    }
  ]

  const templateUsage: TemplateUsage[] = [
    {
      id: '1',
      templateId: '1',
      contestId: '1',
      categoryId: '1',
      usedBy: 'admin@eventmanager.com',
      usedAt: '2024-01-15T10:30:00Z',
      contestName: 'Spring Competition 2024',
      categoryName: 'Vocal Solo - Classical'
    },
    {
      id: '2',
      templateId: '2',
      contestId: '2',
      categoryId: '2',
      usedBy: 'judge@eventmanager.com',
      usedAt: '2024-01-14T15:45:00Z',
      contestName: 'Summer Music Festival',
      categoryName: 'Piano Solo - Contemporary'
    }
  ]

  const filteredTemplates = categoryTemplates.filter(template => {
    const matchesSearch = template.name.toLowerCase().includes(filters.search.toLowerCase()) ||
                         template.description.toLowerCase().includes(filters.search.toLowerCase()) ||
                         template.tags.some(tag => tag.toLowerCase().includes(filters.search.toLowerCase()))
    const matchesType = !filters.categoryType || template.categoryType === filters.categoryType
    const matchesTags = !filters.tags || template.tags.some(tag => tag.toLowerCase().includes(filters.tags.toLowerCase()))
    const matchesPublic = filters.isPublic === '' || 
                         (filters.isPublic === 'true' && template.isPublic) ||
                         (filters.isPublic === 'false' && !template.isPublic)

    return matchesSearch && matchesType && matchesTags && matchesPublic
  })

  const handleCreateTemplate = () => {
    setFormData({
      name: '',
      description: '',
      categoryType: 'VOCAL',
      criteria: [],
      maxContestants: 20,
      timeLimit: 5,
      isPublic: true,
      tags: []
    })
    setShowCreateModal(true)
  }

  const handleEditTemplate = (template: CategoryTemplate) => {
    setSelectedTemplate(template)
    setFormData(template)
    setShowEditModal(true)
  }

  const handleSaveTemplate = async () => {
    try {
      if (showCreateModal) {
        await createTemplateMutation.mutateAsync({
          name: formData.name,
          description: formData.description,
          isPublic: formData.isPublic || false
        })
      } else if (showEditModal && selectedTemplate) {
        await updateTemplateMutation.mutateAsync({
          id: selectedTemplate.id,
          data: {
            name: formData.name,
            description: formData.description,
            isPublic: formData.isPublic || false
          }
        })
      }
      
      setShowCreateModal(false)
      setShowEditModal(false)
      setFormData({})
      setSelectedTemplate(null)
    } catch (error) {
      console.error('Error saving template:', error)
    }
  }

  const handleDeleteTemplate = async (templateId: string) => {
    if (confirm('Are you sure you want to delete this template?')) {
      try {
        await deleteTemplateMutation.mutateAsync(templateId)
      } catch (error) {
        console.error('Error deleting template:', error)
        alert('Failed to delete template. Please try again.')
      }
    }
  }

  const handleDuplicateTemplate = (template: CategoryTemplate) => {
    setFormData({
      ...template,
      name: `${template.name} (Copy)`,
      id: undefined
    })
    setShowCreateModal(true)
  }

  const addCriteria = () => {
    const newCriteria = {
      id: Date.now().toString(),
      name: '',
      description: '',
      maxScore: 10,
      weight: 1.0,
      isRequired: false
    }
    setFormData(prev => ({
      ...prev,
      criteria: [...(prev.criteria || []), newCriteria]
    }))
  }

  const updateCriteria = (index: number, field: string, value: any) => {
    setFormData(prev => ({
      ...prev,
      criteria: prev.criteria?.map((criteria, i) => 
        i === index ? { ...criteria, [field]: value } : criteria
      )
    }))
  }

  const removeCriteria = (index: number) => {
    setFormData(prev => ({
      ...prev,
      criteria: prev.criteria?.filter((_, i) => i !== index)
    }))
  }

  const addTag = (tag: string) => {
    if (tag && !formData.tags?.includes(tag)) {
      setFormData(prev => ({
        ...prev,
        tags: [...(prev.tags || []), tag]
      }))
    }
  }

  const removeTag = (tagToRemove: string) => {
    setFormData(prev => ({
      ...prev,
      tags: prev.tags?.filter(tag => tag !== tagToRemove)
    }))
  }

  const tabs = [
    { id: 'templates', name: 'Templates', icon: DocumentTextIcon },
    { id: 'usage', name: 'Usage History', icon: ClipboardDocumentListIcon },
    { id: 'analytics', name: 'Analytics', icon: CogIcon },
  ]

  const canManageTemplates = user?.role === 'ORGANIZER' || user?.role === 'BOARD'

  return (
    <div className="space-y-6">
      <div className="card">
        <div className="card-header">
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Category Templates</h1>
          <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
            Create and manage reusable category templates for consistent judging
          </p>
        </div>
        <div className="card-body">
          <div className="border-b border-gray-200 dark:border-gray-700">
            <nav className="-mb-px flex space-x-8">
              {tabs.map((tab) => (
                <button
                  key={tab.id}
                  onClick={() => setActiveTab(tab.id)}
                  className={`${
                    activeTab === tab.id
                      ? 'border-blue-500 text-blue-600'
                      : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                  } whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm flex items-center`}
                >
                  <tab.icon className="h-5 w-5 mr-2" />
                  {tab.name}
                </button>
              ))}
            </nav>
          </div>

          {activeTab === 'templates' && (
            <div className="mt-6">
              <div className="flex flex-col sm:flex-row gap-4 mb-6">
                <div className="flex-1">
                  <div className="relative">
                    <MagnifyingGlassIcon className="h-5 w-5 absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" />
                    <input
                      type="text"
                      placeholder="Search templates..."
                      value={filters.search}
                      onChange={(e) => setFilters(prev => ({ ...prev, search: e.target.value }))}
                      className="input pl-10"
                    />
                  </div>
                </div>
                <select
                  value={filters.categoryType}
                  onChange={(e) => setFilters(prev => ({ ...prev, categoryType: e.target.value }))}
                  className="input"
                >
                  <option value="">All Types</option>
                  <option value="VOCAL">Vocal</option>
                  <option value="INSTRUMENTAL">Instrumental</option>
                  <option value="DANCE">Dance</option>
                  <option value="SPEECH">Speech</option>
                  <option value="DRAMA">Drama</option>
                  <option value="OTHER">Other</option>
                </select>
                <select
                  value={filters.isPublic}
                  onChange={(e) => setFilters(prev => ({ ...prev, isPublic: e.target.value }))}
                  className="input"
                >
                  <option value="">All Visibility</option>
                  <option value="true">Public</option>
                  <option value="false">Private</option>
                </select>
                {canManageTemplates && (
                  <button
                    onClick={handleCreateTemplate}
                    className="btn-primary"
                  >
                    <PlusIcon className="h-5 w-5 mr-2" />
                    New Template
                  </button>
                )}
              </div>

              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                {filteredTemplates.map((template) => (
                  <div key={template.id} className="card">
                    <div className="card-body">
                      <div className="flex items-start justify-between mb-3">
                        <div className="flex items-center">
                          {template.categoryType === 'VOCAL' && <UserIcon className="h-6 w-6 text-blue-500 mr-2" />}
                          {template.categoryType === 'INSTRUMENTAL' && <DocumentIcon className="h-6 w-6 text-green-500 mr-2" />}
                          {template.categoryType === 'DANCE' && <StarIcon className="h-6 w-6 text-purple-500 mr-2" />}
                          {template.categoryType === 'SPEECH' && <DocumentTextIcon className="h-6 w-6 text-orange-500 mr-2" />}
                          {template.categoryType === 'DRAMA' && <FolderIcon className="h-6 w-6 text-red-500 mr-2" />}
                          {template.categoryType === 'OTHER' && <TagIcon className="h-6 w-6 text-gray-500 mr-2" />}
                          <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                            {template.name}
                          </h3>
                        </div>
                        <span className={`px-2 py-1 text-xs font-medium rounded-full ${
                          template.isPublic 
                            ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
                            : 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200'
                        }`}>
                          {template.isPublic ? 'Public' : 'Private'}
                        </span>
                      </div>
                      <p className="text-sm text-gray-600 dark:text-gray-400 mb-4">
                        {template.description}
                      </p>
                      
                      <div className="space-y-2 mb-4">
                        <div className="flex items-center text-sm text-gray-600 dark:text-gray-400">
                          <ClipboardDocumentListIcon className="h-4 w-4 mr-2" />
                          {template.criteria.length} criteria
                        </div>
                        <div className="flex items-center text-sm text-gray-600 dark:text-gray-400">
                          <UserIcon className="h-4 w-4 mr-2" />
                          Max {template.maxContestants} contestants
                        </div>
                        <div className="flex items-center text-sm text-gray-600 dark:text-gray-400">
                          <ClockIcon className="h-4 w-4 mr-2" />
                          {template.timeLimit} min time limit
                        </div>
                        <div className="flex items-center text-sm text-gray-600 dark:text-gray-400">
                          <ArrowDownTrayIcon className="h-4 w-4 mr-2" />
                          Used {template.usageCount} times
                        </div>
                      </div>

                      <div className="flex flex-wrap gap-1 mb-4">
                        {template.tags.map((tag) => (
                          <span key={tag} className="px-2 py-1 text-xs bg-gray-100 dark:bg-gray-700 text-gray-600 dark:text-gray-400 rounded">
                            {tag}
                          </span>
                        ))}
                      </div>

                      <div className="flex items-center justify-between">
                        <div className="text-xs text-gray-500 dark:text-gray-400">
                          Created {format(new Date(template.createdAt), 'MMM dd, yyyy')}
                        </div>
                        <div className="flex space-x-2">
                          <button
                            onClick={() => handleEditTemplate(template)}
                            className="text-blue-600 hover:text-blue-900 dark:text-blue-400 dark:hover:text-blue-300"
                            title="View Details"
                          >
                            <EyeIcon className="h-4 w-4" />
                          </button>
                          {canManageTemplates && (
                            <>
                              <button
                                onClick={() => handleDuplicateTemplate(template)}
                                className="text-green-600 hover:text-green-900 dark:text-green-400 dark:hover:text-green-300"
                                title="Duplicate"
                              >
                                <DocumentDuplicateIcon className="h-4 w-4" />
                              </button>
                              <button
                                onClick={() => handleEditTemplate(template)}
                                className="text-yellow-600 hover:text-yellow-900 dark:text-yellow-400 dark:hover:text-yellow-300"
                                title="Edit"
                              >
                                <PencilIcon className="h-4 w-4" />
                              </button>
                              <button
                                onClick={() => handleDeleteTemplate(template.id)}
                                className="text-red-600 hover:text-red-900 dark:text-red-400 dark:hover:text-red-300"
                                title="Delete"
                              >
                                <TrashIcon className="h-4 w-4" />
                              </button>
                            </>
                          )}
                        </div>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}

          {activeTab === 'usage' && (
            <div className="mt-6">
              <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                  <thead className="bg-gray-50 dark:bg-gray-800">
                    <tr>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                        Template
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                        Contest
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                        Category
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                        Used By
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                        Used At
                      </th>
                    </tr>
                  </thead>
                  <tbody className="bg-white dark:bg-gray-900 divide-y divide-gray-200 dark:divide-gray-700">
                    {templateUsage.map((usage) => {
                      const template = categoryTemplates.find(t => t.id === usage.templateId)
                      return (
                        <tr key={usage.id}>
                          <td className="px-6 py-4 whitespace-nowrap">
                            <div className="text-sm font-medium text-gray-900 dark:text-white">
                              {template?.name || 'Unknown Template'}
                            </div>
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-600 dark:text-gray-400">
                            {usage.contestName}
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-600 dark:text-gray-400">
                            {usage.categoryName}
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-600 dark:text-gray-400">
                            {usage.usedBy}
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-600 dark:text-gray-400">
                            {format(new Date(usage.usedAt), 'MMM dd, yyyy HH:mm')}
                          </td>
                        </tr>
                      )
                    })}
                  </tbody>
                </table>
              </div>
            </div>
          )}

          {activeTab === 'analytics' && (
            <div className="mt-6">
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
                <div className="card">
                  <div className="card-body">
                    <div className="flex items-center">
                      <DocumentTextIcon className="h-8 w-8 text-blue-500" />
                      <div className="ml-4">
                        <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Total Templates</p>
                        <p className="text-2xl font-semibold text-gray-900 dark:text-white">{categoryTemplates.length}</p>
                      </div>
                    </div>
                  </div>
                </div>
                <div className="card">
                  <div className="card-body">
                    <div className="flex items-center">
                      <ArrowDownTrayIcon className="h-8 w-8 text-green-500" />
                      <div className="ml-4">
                        <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Total Usage</p>
                        <p className="text-2xl font-semibold text-gray-900 dark:text-white">
                          {categoryTemplates.reduce((sum, t) => sum + t.usageCount, 0)}
                        </p>
                      </div>
                    </div>
                  </div>
                </div>
                <div className="card">
                  <div className="card-body">
                    <div className="flex items-center">
                      <CheckCircleIcon className="h-8 w-8 text-green-500" />
                      <div className="ml-4">
                        <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Public Templates</p>
                        <p className="text-2xl font-semibold text-gray-900 dark:text-white">
                          {categoryTemplates.filter(t => t.isPublic).length}
                        </p>
                      </div>
                    </div>
                  </div>
                </div>
                <div className="card">
                  <div className="card-body">
                    <div className="flex items-center">
                      <ExclamationTriangleIcon className="h-8 w-8 text-yellow-500" />
                      <div className="ml-4">
                        <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Private Templates</p>
                        <p className="text-2xl font-semibold text-gray-900 dark:text-white">
                          {categoryTemplates.filter(t => !t.isPublic).length}
                        </p>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <div className="card">
                  <div className="card-header">
                    <h3 className="text-lg font-semibold text-gray-900 dark:text-white">Template Types</h3>
                  </div>
                  <div className="card-body">
                    <div className="space-y-4">
                      {['VOCAL', 'INSTRUMENTAL', 'DANCE', 'SPEECH', 'DRAMA', 'OTHER'].map((type) => {
                        const count = categoryTemplates.filter(t => t.categoryType === type).length
                        return (
                          <div key={type} className="flex items-center justify-between">
                            <span className="text-sm text-gray-600 dark:text-gray-400 capitalize">{type.toLowerCase()}</span>
                            <div className="flex items-center">
                              <div className="w-32 bg-gray-200 dark:bg-gray-700 rounded-full h-2 mr-3">
                                <div 
                                  className="bg-blue-500 h-2 rounded-full" 
                                  style={{ width: `${(count / categoryTemplates.length) * 100}%` }}
                                ></div>
                              </div>
                              <span className="text-sm font-medium text-gray-900 dark:text-white">{count}</span>
                            </div>
                          </div>
                        )
                      })}
                    </div>
                  </div>
                </div>

                <div className="card">
                  <div className="card-header">
                    <h3 className="text-lg font-semibold text-gray-900 dark:text-white">Most Used Templates</h3>
                  </div>
                  <div className="card-body">
                    <div className="space-y-3">
                      {categoryTemplates
                        .sort((a, b) => b.usageCount - a.usageCount)
                        .slice(0, 5)
                        .map((template) => (
                        <div key={template.id} className="flex items-center justify-between">
                          <div className="flex items-center">
                            <DocumentTextIcon className="h-5 w-5 text-gray-400 mr-3" />
                            <div>
                              <p className="text-sm font-medium text-gray-900 dark:text-white">{template.name}</p>
                              <p className="text-xs text-gray-500 dark:text-gray-400">{template.categoryType}</p>
                            </div>
                          </div>
                          <span className="text-sm font-medium text-gray-900 dark:text-white">{template.usageCount}</span>
                        </div>
                      ))}
                    </div>
                  </div>
                </div>
              </div>
            </div>
          )}
        </div>
      </div>

      {/* Create/Edit Template Modal */}
      {(showCreateModal || showEditModal) && (
        <div className="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
          <div className="relative top-20 mx-auto p-5 border w-full max-w-4xl shadow-lg rounded-md bg-white dark:bg-gray-800">
            <div className="mt-3">
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-lg font-medium text-gray-900 dark:text-white">
                  {showCreateModal ? 'Create New Template' : 'Edit Template'}
                </h3>
                <button
                  onClick={() => {
                    setShowCreateModal(false)
                    setShowEditModal(false)
                    setFormData({})
                    setSelectedTemplate(null)
                  }}
                  className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
                >
                  <XMarkIcon className="h-6 w-6" />
                </button>
              </div>
              
              <div className="space-y-6">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      Template Name *
                    </label>
                    <input
                      type="text"
                      value={formData.name || ''}
                      onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))}
                      className="input"
                      placeholder="Enter template name"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      Category Type *
                    </label>
                    <select
                      value={formData.categoryType || 'VOCAL'}
                      onChange={(e) => setFormData(prev => ({ ...prev, categoryType: e.target.value as any }))}
                      className="input"
                    >
                      <option value="VOCAL">Vocal</option>
                      <option value="INSTRUMENTAL">Instrumental</option>
                      <option value="DANCE">Dance</option>
                      <option value="SPEECH">Speech</option>
                      <option value="DRAMA">Drama</option>
                      <option value="OTHER">Other</option>
                    </select>
                  </div>
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                    Description *
                  </label>
                  <textarea
                    value={formData.description || ''}
                    onChange={(e) => setFormData(prev => ({ ...prev, description: e.target.value }))}
                    className="input"
                    rows={3}
                    placeholder="Enter template description"
                  />
                </div>

                <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      Max Contestants
                    </label>
                    <input
                      type="number"
                      value={formData.maxContestants || 20}
                      onChange={(e) => setFormData(prev => ({ ...prev, maxContestants: parseInt(e.target.value) }))}
                      className="input"
                      min="1"
                      max="100"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      Time Limit (minutes)
                    </label>
                    <input
                      type="number"
                      value={formData.timeLimit || 5}
                      onChange={(e) => setFormData(prev => ({ ...prev, timeLimit: parseInt(e.target.value) }))}
                      className="input"
                      min="1"
                      max="60"
                    />
                  </div>
                  <div className="flex items-center">
                    <input
                      type="checkbox"
                      checked={formData.isPublic || false}
                      onChange={(e) => setFormData(prev => ({ ...prev, isPublic: e.target.checked }))}
                      className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                    />
                    <label className="ml-2 block text-sm text-gray-700 dark:text-gray-300">
                      Public Template
                    </label>
                  </div>
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                    Tags
                  </label>
                  <div className="flex flex-wrap gap-2 mb-2">
                    {formData.tags?.map((tag) => (
                      <span key={tag} className="px-2 py-1 text-xs bg-blue-100 dark:bg-blue-900 text-blue-800 dark:text-blue-200 rounded flex items-center">
                        {tag}
                        <button
                          onClick={() => removeTag(tag)}
                          className="ml-1 text-blue-600 hover:text-blue-800"
                        >
                          <XMarkIcon className="h-3 w-3" />
                        </button>
                      </span>
                    ))}
                  </div>
                  <input
                    type="text"
                    placeholder="Add tag and press Enter"
                    onKeyPress={(e) => {
                      if (e.key === 'Enter') {
                        e.preventDefault()
                        addTag(e.currentTarget.value.trim())
                        e.currentTarget.value = ''
                      }
                    }}
                    className="input"
                  />
                </div>

                <div>
                  <div className="flex items-center justify-between mb-4">
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">
                      Judging Criteria *
                    </label>
                    <button
                      onClick={addCriteria}
                      className="btn-outline text-sm"
                    >
                      <PlusIcon className="h-4 w-4 mr-1" />
                      Add Criteria
                    </button>
                  </div>
                  <div className="space-y-4">
                    {formData.criteria?.map((criteria, index) => (
                      <div key={criteria.id} className="border border-gray-200 dark:border-gray-700 rounded-lg p-4">
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                          <div>
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                              Criteria Name *
                            </label>
                            <input
                              type="text"
                              value={criteria.name}
                              onChange={(e) => updateCriteria(index, 'name', e.target.value)}
                              className="input"
                              placeholder="Enter criteria name"
                            />
                          </div>
                          <div>
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                              Max Score *
                            </label>
                            <input
                              type="number"
                              value={criteria.maxScore}
                              onChange={(e) => updateCriteria(index, 'maxScore', parseInt(e.target.value))}
                              className="input"
                              min="1"
                              max="100"
                            />
                          </div>
                        </div>
                        <div>
                          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                            Description
                          </label>
                          <textarea
                            value={criteria.description}
                            onChange={(e) => updateCriteria(index, 'description', e.target.value)}
                            className="input"
                            rows={2}
                            placeholder="Enter criteria description"
                          />
                        </div>
                        <div className="flex items-center justify-between mt-4">
                          <div className="flex items-center space-x-4">
                            <div className="flex items-center">
                              <input
                                type="checkbox"
                                checked={criteria.isRequired}
                                onChange={(e) => updateCriteria(index, 'isRequired', e.target.checked)}
                                className="h-4 w-4 text-blue-600 focus:ring-blue-500 border-gray-300 rounded"
                              />
                              <label className="ml-2 block text-sm text-gray-700 dark:text-gray-300">
                                Required
                              </label>
                            </div>
                            <div>
                              <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                                Weight
                              </label>
                              <input
                                type="number"
                                value={criteria.weight}
                                onChange={(e) => updateCriteria(index, 'weight', parseFloat(e.target.value))}
                                className="input w-20"
                                min="0"
                                max="2"
                                step="0.1"
                              />
                            </div>
                          </div>
                          <button
                            onClick={() => removeCriteria(index)}
                            className="text-red-600 hover:text-red-900 dark:text-red-400 dark:hover:text-red-300"
                          >
                            <TrashIcon className="h-4 w-4" />
                          </button>
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              </div>
              
              <div className="flex justify-end space-x-3 mt-6">
                <button
                  onClick={() => {
                    setShowCreateModal(false)
                    setShowEditModal(false)
                    setFormData({})
                    setSelectedTemplate(null)
                  }}
                  className="btn-secondary"
                >
                  Cancel
                </button>
                <button
                  onClick={handleSaveTemplate}
                  className="btn-primary"
                >
                  {showCreateModal ? 'Create Template' : 'Save Changes'}
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}

export default TemplatesPage
EOF

    cat > "$APP_DIR/frontend/src/pages/ReportsPage.tsx" << 'EOF'
import React, { useState } from 'react'
import { useQuery } from 'react-query'
import { useAuth } from '../contexts/AuthContext'
import { eventsAPI, contestsAPI, categoriesAPI, resultsAPI, adminAPI } from '../services/api'
import {
  DocumentTextIcon,
  PrinterIcon,
  ArrowDownTrayIcon,
  CalendarIcon,
  ChartBarIcon,
  UserGroupIcon,
  TrophyIcon,
  ClipboardDocumentListIcon,
  MagnifyingGlassIcon,
  FunnelIcon,
  EyeIcon,
  DocumentArrowDownIcon,
  TableCellsIcon,
  PresentationChartLineIcon,
  DocumentChartBarIcon,
  ClipboardDocumentCheckIcon,
  ExclamationTriangleIcon,
  CheckCircleIcon,
  ClockIcon,
  XCircleIcon,
  InformationCircleIcon,
  EnvelopeIcon,
  XMarkIcon
} from '@heroicons/react/24/outline'
import { format } from 'date-fns'

interface ReportTemplate {
  id: string
  name: string
  description: string
  type: 'EVENT' | 'CONTEST' | 'CATEGORY' | 'USER' | 'SCORE' | 'CERTIFICATION' | 'AUDIT'
  format: 'PDF' | 'EXCEL' | 'CSV' | 'HTML'
  parameters: any[]
  isPublic: boolean
  createdAt: string
  updatedAt: string
}

interface ReportInstance {
  id: string
  templateId: string
  name: string
  status: 'PENDING' | 'GENERATING' | 'COMPLETED' | 'FAILED'
  parameters: any
  fileUrl?: string
  generatedAt?: string
  generatedBy: string
  createdAt: string
}

interface ReportData {
  summary: {
    totalContestants: number
    totalJudges: number
    totalCategories: number
    averageScore: number
    highestScore: number
    lowestScore: number
  }
  rankings: Array<{
    rank: number
    contestantId: string
    contestantName: string
    totalScore: number
    averageScore: number
    categoryScores: Array<{
      categoryId: string
      categoryName: string
      score: number
    }>
  }>
  categories: Array<{
    id: string
    name: string
    maxScore: number
    averageScore: number
    contestantCount: number
    criteria: Array<{
      id: string
      name: string
      maxScore: number
      averageScore: number
    }>
  }>
  judges: Array<{
    id: string
    name: string
    categoriesAssigned: number
    scoresSubmitted: number
    averageScore: number
  }>
}

const ReportsPage: React.FC = () => {
  const { user } = useAuth()
  const [activeTab, setActiveTab] = useState('templates')
  const [selectedTemplate, setSelectedTemplate] = useState<ReportTemplate | null>(null)
  const [showGenerateModal, setShowGenerateModal] = useState(false)
  const [reportParameters, setReportParameters] = useState<any>({})
  const [showEmailModal, setShowEmailModal] = useState(false)
  const [selectedReportInstance, setSelectedReportInstance] = useState<ReportInstance | null>(null)
  const [filters, setFilters] = useState({
    search: '',
    type: '',
    format: '',
    status: ''
  })

  // Fetch data for reports
  const { data: events } = useQuery('events', () => eventsAPI.getAll().then((res: any) => res.data))
  const { data: contests } = useQuery('contests', () => contestsAPI.getAll().then((res: any) => res.data))
  const { data: categories } = useQuery('categories', () => categoriesAPI.getAll().then((res: any) => res.data))
  const { data: results } = useQuery('results', () => resultsAPI.getAll().then((res: any) => res.data))
  const { data: adminStats } = useQuery('adminStats', () => adminAPI.getStats().then((res: any) => res.data))

  // Mock data for templates and instances
  const reportTemplates: ReportTemplate[] = [
    {
      id: '1',
      name: 'Event Summary Report',
      description: 'Comprehensive summary of an event including contests, participants, and results',
      type: 'EVENT',
      format: 'PDF',
      parameters: [
        { name: 'eventId', label: 'Event', type: 'select', required: true, options: events || [] },
        { name: 'includeContests', label: 'Include Contests', type: 'boolean', required: false },
        { name: 'includeParticipants', label: 'Include Participants', type: 'boolean', required: false },
        { name: 'includeResults', label: 'Include Results', type: 'boolean', required: false }
      ],
      isPublic: true,
      createdAt: '2024-01-01T00:00:00Z',
      updatedAt: '2024-01-01T00:00:00Z'
    }
  ]

  const reportInstances: ReportInstance[] = [
    {
      id: '1',
      templateId: '1',
      name: 'Event Summary - Spring Competition 2024',
      status: 'COMPLETED',
      parameters: { eventId: '1', includeContests: true, includeParticipants: true, includeResults: true },
      fileUrl: '/reports/event-summary-spring-2024.pdf',
      generatedAt: '2024-01-15T10:30:00Z',
      generatedBy: 'admin@eventmanager.com',
      createdAt: '2024-01-15T10:25:00Z'
    }
  ]

  const filteredTemplates = reportTemplates.filter(template => {
    const matchesSearch = template.name.toLowerCase().includes(filters.search.toLowerCase())
    const matchesType = !filters.type || template.type === filters.type
    const matchesFormat = !filters.format || template.format === filters.format
    const matchesPublic = user?.role === 'ORGANIZER' || user?.role === 'BOARD' || template.isPublic

    return matchesSearch && matchesType && matchesFormat && matchesPublic
  })

  const filteredInstances = reportInstances.filter(instance => {
    const template = reportTemplates.find(t => t.id === instance.templateId)
    const matchesSearch = instance.name.toLowerCase().includes(filters.search.toLowerCase())
    const matchesStatus = !filters.status || instance.status === filters.status
    const matchesType = !filters.type || template?.type === filters.type

    return matchesSearch && matchesStatus && matchesType
  })

  const handleGenerateReport = async (template: ReportTemplate) => {
    try {
      setSelectedTemplate(template)
      setReportParameters({})
      setShowGenerateModal(true)
      
      // Generate the report with parameters
      const response = await fetch('/api/reports/generate', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        },
        body: JSON.stringify({
          templateId: template.id,
          parameters: reportParameters,
          format: 'pdf'
        })
      })
      
      if (response.ok) {
        const blob = await response.blob()
        const url = window.URL.createObjectURL(blob)
        const a = document.createElement('a')
        a.href = url
        a.download = `${template.name}-report.pdf`
        a.click()
        window.URL.revokeObjectURL(url)
      } else {
        throw new Error('Failed to generate report')
      }
    } catch (error) {
      console.error('Error generating report:', error)
      alert('Failed to generate report. Please try again.')
    }
  }

  const handleParameterChange = (paramName: string, value: any) => {
    setReportParameters(prev => ({
      ...prev,
      [paramName]: value
    }))
  }

  const handleSubmitReport = () => {
    // Mock report generation
    console.log('Generating report:', selectedTemplate?.name, reportParameters)
    setShowGenerateModal(false)
    setSelectedTemplate(null)
    setReportParameters({})
  }

  const handleEmailReport = (instance: ReportInstance) => {
    setSelectedReportInstance(instance)
    setShowEmailModal(true)
  }

  const getStatusIcon = (status: string) => {
    switch (status) {
      case 'PENDING':
        return <ClockIcon className="h-5 w-5 text-yellow-500" />
      case 'GENERATING':
        return <ArrowDownTrayIcon className="h-5 w-5 text-blue-500" />
      case 'COMPLETED':
        return <CheckCircleIcon className="h-5 w-5 text-green-500" />
      case 'FAILED':
        return <XCircleIcon className="h-5 w-5 text-red-500" />
      default:
        return <InformationCircleIcon className="h-5 w-5 text-gray-500" />
    }
  }

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'PENDING':
        return 'text-yellow-600 bg-yellow-100 dark:text-yellow-400 dark:bg-yellow-900'
      case 'GENERATING':
        return 'text-blue-600 bg-blue-100 dark:text-blue-400 dark:bg-blue-900'
      case 'COMPLETED':
        return 'text-green-600 bg-green-100 dark:text-green-400 dark:bg-green-900'
      case 'FAILED':
        return 'text-red-600 bg-red-100 dark:text-red-400 dark:bg-red-900'
      default:
        return 'text-gray-600 bg-gray-100 dark:text-gray-400 dark:bg-gray-900'
    }
  }

  const tabs = [
    { id: 'templates', name: 'Report Templates', icon: DocumentTextIcon },
    { id: 'instances', name: 'Generated Reports', icon: ClipboardDocumentListIcon },
    { id: 'analytics', name: 'Report Analytics', icon: ChartBarIcon },
  ]

  return (
    <div className="space-y-6">
      <div className="card">
        <div className="card-header">
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">Reports Generation</h1>
          <p className="mt-1 text-sm text-gray-600 dark:text-gray-400">
            Generate and manage various reports for events, contests, and users
          </p>
        </div>
        <div className="card-body">
          <div className="border-b border-gray-200 dark:border-gray-700">
            <nav className="-mb-px flex space-x-8">
              {tabs.map((tab) => (
                <button
                  key={tab.id}
                  onClick={() => setActiveTab(tab.id)}
                  className={`${
                    activeTab === tab.id
                      ? 'border-blue-500 text-blue-600'
                      : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300'
                  } whitespace-nowrap py-2 px-1 border-b-2 font-medium text-sm flex items-center`}
                >
                  <tab.icon className="h-5 w-5 mr-2" />
                  {tab.name}
                </button>
              ))}
            </nav>
          </div>

          {activeTab === 'templates' && (
            <div className="mt-6">
              <div className="flex flex-col sm:flex-row gap-4 mb-6">
                <div className="flex-1">
                  <div className="relative">
                    <MagnifyingGlassIcon className="h-5 w-5 absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" />
                    <input
                      type="text"
                      placeholder="Search templates..."
                      value={filters.search}
                      onChange={(e) => setFilters(prev => ({ ...prev, search: e.target.value }))}
                      className="input pl-10"
                    />
                  </div>
                </div>
                <select
                  value={filters.type}
                  onChange={(e) => setFilters(prev => ({ ...prev, type: e.target.value }))}
                  className="input"
                >
                  <option value="">All Types</option>
                  <option value="EVENT">Event</option>
                  <option value="CONTEST">Contest</option>
                  <option value="CATEGORY">Category</option>
                  <option value="USER">User</option>
                  <option value="SCORE">Score</option>
                  <option value="CERTIFICATION">Certification</option>
                  <option value="AUDIT">Audit</option>
                </select>
                <select
                  value={filters.format}
                  onChange={(e) => setFilters(prev => ({ ...prev, format: e.target.value }))}
                  className="input"
                >
                  <option value="">All Formats</option>
                  <option value="PDF">PDF</option>
                  <option value="EXCEL">Excel</option>
                  <option value="CSV">CSV</option>
                  <option value="HTML">HTML</option>
                </select>
              </div>

              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                {filteredTemplates.map((template) => (
                  <div key={template.id} className="card">
                    <div className="card-body">
                      <div className="flex items-start justify-between mb-3">
                        <div className="flex items-center">
                          {template.type === 'EVENT' && <CalendarIcon className="h-6 w-6 text-blue-500 mr-2" />}
                          {template.type === 'CONTEST' && <TrophyIcon className="h-6 w-6 text-yellow-500 mr-2" />}
                          {template.type === 'CATEGORY' && <ClipboardDocumentCheckIcon className="h-6 w-6 text-green-500 mr-2" />}
                          {template.type === 'USER' && <UserGroupIcon className="h-6 w-6 text-purple-500 mr-2" />}
                          {template.type === 'SCORE' && <ChartBarIcon className="h-6 w-6 text-indigo-500 mr-2" />}
                          {template.type === 'CERTIFICATION' && <CheckCircleIcon className="h-6 w-6 text-green-500 mr-2" />}
                          {template.type === 'AUDIT' && <DocumentTextIcon className="h-6 w-6 text-red-500 mr-2" />}
                          <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                            {template.name}
                          </h3>
                        </div>
                        <span className={`px-2 py-1 text-xs font-medium rounded-full ${
                          template.format === 'PDF' ? 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200' :
                          template.format === 'EXCEL' ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200' :
                          template.format === 'CSV' ? 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200' :
                          'bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200'
                        }`}>
                          {template.format}
                        </span>
                      </div>
                      <p className="text-sm text-gray-600 dark:text-gray-400 mb-4">
                        {template.description}
                      </p>
                      <div className="flex items-center justify-between">
                        <span className={`text-xs px-2 py-1 rounded-full ${
                          template.isPublic 
                            ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
                            : 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200'
                        }`}>
                          {template.isPublic ? 'Public' : 'Restricted'}
                        </span>
                        <button
                          onClick={() => handleGenerateReport(template)}
                          className="btn-primary text-sm"
                        >
                          <DocumentArrowDownIcon className="h-4 w-4 mr-1" />
                          Generate
                        </button>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}

          {activeTab === 'instances' && (
            <div className="mt-6">
              <div className="flex flex-col sm:flex-row gap-4 mb-6">
                <div className="flex-1">
                  <div className="relative">
                    <MagnifyingGlassIcon className="h-5 w-5 absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" />
                    <input
                      type="text"
                      placeholder="Search reports..."
                      value={filters.search}
                      onChange={(e) => setFilters(prev => ({ ...prev, search: e.target.value }))}
                      className="input pl-10"
                    />
                  </div>
                </div>
                <select
                  value={filters.status}
                  onChange={(e) => setFilters(prev => ({ ...prev, status: e.target.value }))}
                  className="input"
                >
                  <option value="">All Status</option>
                  <option value="PENDING">Pending</option>
                  <option value="GENERATING">Generating</option>
                  <option value="COMPLETED">Completed</option>
                  <option value="FAILED">Failed</option>
                </select>
              </div>

              <div className="overflow-x-auto">
                <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                  <thead className="bg-gray-50 dark:bg-gray-800">
                    <tr>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                        Report Name
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                        Template
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                        Status
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                        Generated By
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                        Created
                      </th>
                      <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-400 uppercase tracking-wider">
                        Actions
                      </th>
                    </tr>
                  </thead>
                  <tbody className="bg-white dark:bg-gray-900 divide-y divide-gray-200 dark:divide-gray-700">
                    {filteredInstances.map((instance) => {
                      const template = reportTemplates.find(t => t.id === instance.templateId)
                      return (
                        <tr key={instance.id}>
                          <td className="px-6 py-4 whitespace-nowrap">
                            <div className="text-sm font-medium text-gray-900 dark:text-white">
                              {instance.name}
                            </div>
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap">
                            <div className="text-sm text-gray-600 dark:text-gray-400">
                              {template?.name || 'Unknown Template'}
                            </div>
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap">
                            <div className="flex items-center">
                              {getStatusIcon(instance.status)}
                              <span className={`ml-2 px-2 py-1 text-xs font-medium rounded-full ${getStatusColor(instance.status)}`}>
                                {instance.status}
                              </span>
                            </div>
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-600 dark:text-gray-400">
                            {instance.generatedBy}
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-600 dark:text-gray-400">
                            {format(new Date(instance.createdAt), 'MMM dd, yyyy HH:mm')}
                          </td>
                          <td className="px-6 py-4 whitespace-nowrap text-sm font-medium">
                            {instance.status === 'COMPLETED' && instance.fileUrl && (
                              <div className="flex space-x-2">
                                <button className="text-blue-600 hover:text-blue-900 dark:text-blue-400 dark:hover:text-blue-300">
                                  <EyeIcon className="h-4 w-4" />
                                </button>
                                <button className="text-green-600 hover:text-green-900 dark:text-green-400 dark:hover:text-green-300">
                                  <ArrowDownTrayIcon className="h-4 w-4" />
                                </button>
                                <button className="text-gray-600 hover:text-gray-900 dark:text-gray-400 dark:hover:text-gray-300">
                                  <PrinterIcon className="h-4 w-4" />
                                </button>
                                <button 
                                  onClick={() => handleEmailReport(instance)}
                                  className="text-purple-600 hover:text-purple-900 dark:text-purple-400 dark:hover:text-purple-300"
                                >
                                  <EnvelopeIcon className="h-4 w-4" />
                                </button>
                              </div>
                            )}
                            {instance.status === 'FAILED' && (
                              <button className="text-red-600 hover:text-red-900 dark:text-red-400 dark:hover:text-red-300">
                                <ExclamationTriangleIcon className="h-4 w-4" />
                              </button>
                            )}
                          </td>
                        </tr>
                      )
                    })}
                  </tbody>
                </table>
              </div>
            </div>
          )}

          {activeTab === 'analytics' && (
            <div className="mt-6">
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
                <div className="card">
                  <div className="card-body">
                    <div className="flex items-center">
                      <DocumentTextIcon className="h-8 w-8 text-blue-500" />
                      <div className="ml-4">
                        <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Total Templates</p>
                        <p className="text-2xl font-semibold text-gray-900 dark:text-white">{reportTemplates.length}</p>
                      </div>
                    </div>
                  </div>
                </div>
                <div className="card">
                  <div className="card-body">
                    <div className="flex items-center">
                      <ClipboardDocumentListIcon className="h-8 w-8 text-green-500" />
                      <div className="ml-4">
                        <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Generated Reports</p>
                        <p className="text-2xl font-semibold text-gray-900 dark:text-white">{reportInstances.length}</p>
                      </div>
                    </div>
                  </div>
                </div>
                <div className="card">
                  <div className="card-body">
                    <div className="flex items-center">
                      <CheckCircleIcon className="h-8 w-8 text-green-500" />
                      <div className="ml-4">
                        <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Completed</p>
                        <p className="text-2xl font-semibold text-gray-900 dark:text-white">
                          {reportInstances.filter(i => i.status === 'COMPLETED').length}
                        </p>
                      </div>
                    </div>
                  </div>
                </div>
                <div className="card">
                  <div className="card-body">
                    <div className="flex items-center">
                      <XCircleIcon className="h-8 w-8 text-red-500" />
                      <div className="ml-4">
                        <p className="text-sm font-medium text-gray-600 dark:text-gray-400">Failed</p>
                        <p className="text-2xl font-semibold text-gray-900 dark:text-white">
                          {reportInstances.filter(i => i.status === 'FAILED').length}
                        </p>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          )}
        </div>
      </div>

      {/* Generate Report Modal */}
      {showGenerateModal && selectedTemplate && (
        <div className="fixed inset-0 bg-gray-600 bg-opacity-50 overflow-y-auto h-full w-full z-50">
          <div className="relative top-20 mx-auto p-5 border w-96 shadow-lg rounded-md bg-white dark:bg-gray-800">
            <div className="mt-3">
              <div className="flex items-center justify-between mb-4">
                <h3 className="text-lg font-medium text-gray-900 dark:text-white">
                  Generate Report: {selectedTemplate.name}
                </h3>
                <button
                  onClick={() => setShowGenerateModal(false)}
                  className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
                >
                  <XCircleIcon className="h-6 w-6" />
                </button>
              </div>
              
              <div className="space-y-4">
                <p className="text-sm text-gray-600 dark:text-gray-400">
                  {selectedTemplate.description}
                </p>
                
                {selectedTemplate.parameters.map((param) => (
                  <div key={param.name}>
                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
                      {param.label} {param.required && <span className="text-red-500">*</span>}
                    </label>
                    {param.type === 'select' ? (
                      <select
                        value={reportParameters[param.name] || ''}
                        onChange={(e) => handleParameterChange(param.name, e.target.value)}
                        className="input"
                        required={param.required}
                      >
                        <option value="">Select {param.label}</option>
                        {param.options?.map((option: any) => (
                          <option key={option.id || option.value} value={option.id || option.value}>
                            {option.name || option.label}
                          </option>
                        ))}
                      </select>
                    ) : param.type === 'boolean' ? (
                      <label className="flex items-center">
                        <input
                          type="checkbox"
                          checked={reportParameters[param.name] || false}
                          onChange={(e) => handleParameterChange(param.name, e.target.checked)}
                          className="mr-2"
                        />
                        {param.label}
                      </label>
                    ) : (
                      <input
                        type={param.type === 'daterange' ? 'date' : 'text'}
                        value={reportParameters[param.name] || ''}
                        onChange={(e) => handleParameterChange(param.name, e.target.value)}
                        className="input"
                        required={param.required}
                      />
                    )}
                  </div>
                ))}
              </div>
              
              <div className="flex justify-end space-x-3 mt-6">
                <button
                  onClick={() => setShowGenerateModal(false)}
                  className="btn-secondary"
                >
                  Cancel
                </button>
                <button
                  onClick={handleSubmitReport}
                  className="btn-primary"
                >
                  <DocumentArrowDownIcon className="h-4 w-4 mr-2" />
                  Generate Report
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Email Report Modal */}
      {showEmailModal && selectedReportInstance && (
        <div className="modal">
          <div className="modal-overlay" onClick={() => setShowEmailModal(false)}></div>
          <div className="modal-content max-w-2xl">
            <div className="flex items-center justify-between mb-6">
              <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                Email Report: {selectedReportInstance.name}
              </h3>
              <button
                onClick={() => setShowEmailModal(false)}
                className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
              >
                <XMarkIcon className="h-6 w-6" />
              </button>
            </div>

            <EmailReportModal
              reportInstance={selectedReportInstance}
              onClose={() => setShowEmailModal(false)}
            />
          </div>
        </div>
      )}
    </div>
  )
}

interface EmailReportModalProps {
  reportInstance: ReportInstance
  onClose: () => void
}

const EmailReportModal: React.FC<EmailReportModalProps> = ({ reportInstance, onClose }) => {
  const [recipients, setRecipients] = useState<string[]>([])
  const [subject, setSubject] = useState(`Report: ${reportInstance.name}`)
  const [message, setMessage] = useState('')
  const [isSending, setIsSending] = useState(false)
  const [emailInput, setEmailInput] = useState('')

  const { data: users } = useQuery('users', () => api.get('/users').then((res: any) => res.data))

  const addRecipient = (email: string) => {
    if (email && !recipients.includes(email)) {
      setRecipients([...recipients, email])
      setEmailInput('')
    }
  }

  const removeRecipient = (email: string) => {
    setRecipients(recipients.filter(r => r !== email))
  }

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    if (recipients.length === 0) return

    setIsSending(true)
    try {
      await api.post(`/reports/${reportInstance.id}/email`, {
        recipients,
        subject,
        message,
      })
      onClose()
    } catch (error) {
      console.error('Error sending email:', error)
    } finally {
      setIsSending(false)
    }
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      {/* Recipients */}
      <div>
        <label className="label">Recipients</label>
        <div className="space-y-3">
          <div className="flex space-x-2">
            <input
              type="email"
              placeholder="Enter email address"
              value={emailInput}
              onChange={(e) => setEmailInput(e.target.value)}
              className="input flex-1"
            />
            <button
              type="button"
              onClick={() => addRecipient(emailInput)}
              className="btn-secondary"
            >
              Add
            </button>
          </div>
          
          {recipients.length > 0 && (
            <div className="flex flex-wrap gap-2">
              {recipients.map((email) => (
                <span
                  key={email}
                  className="inline-flex items-center px-3 py-1 rounded-full text-sm bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200"
                >
                  {email}
                  <button
                    type="button"
                    onClick={() => removeRecipient(email)}
                    className="ml-2 text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-200"
                  >
                    <XMarkIcon className="h-4 w-4" />
                  </button>
                </span>
              ))}
            </div>
          )}

          {/* Quick add users */}
          {users && (
            <div className="mt-2">
              <p className="text-sm text-gray-600 dark:text-gray-400 mb-2">Quick add users:</p>
              <div className="flex flex-wrap gap-2">
                {users.slice(0, 5).map((user: any) => (
                  <button
                    key={user.id}
                    type="button"
                    onClick={() => addRecipient(user.email)}
                    className="text-sm px-2 py-1 bg-gray-100 hover:bg-gray-200 dark:bg-gray-700 dark:hover:bg-gray-600 rounded"
                  >
                    {user.name} ({user.email})
                  </button>
                ))}
              </div>
            </div>
          )}
        </div>
      </div>

      {/* Subject */}
      <div>
        <label className="label">Subject</label>
        <input
          type="text"
          value={subject}
          onChange={(e) => setSubject(e.target.value)}
          className="input"
          required
        />
      </div>

      {/* Message */}
      <div>
        <label className="label">Message</label>
        <textarea
          value={message}
          onChange={(e) => setMessage(e.target.value)}
          rows={4}
          className="input"
          placeholder="Add a message to accompany the report..."
        />
      </div>

      {/* Actions */}
      <div className="flex justify-end space-x-3">
        <button
          type="button"
          onClick={onClose}
          className="btn-secondary"
        >
          Cancel
        </button>
        <button
          type="submit"
          disabled={recipients.length === 0 || isSending}
          className="btn-primary"
        >
          {isSending ? (
            <>
              <div className="loading-spinner h-4 w-4 mr-2"></div>
              Sending...
            </>
          ) : (
            <>
              <EnvelopeIcon className="h-4 w-4 mr-2" />
              Send Email
            </>
          )}
        </button>
      </div>
    </form>
  )
}

export default ReportsPage
EOF
    # Add DatabaseBrowser component
    cat > "$APP_DIR/frontend/src/components/DatabaseBrowser.tsx" << 'EOF'
import React, { useState, useEffect } from 'react'
import { useQuery, useMutation, useQueryClient } from 'react-query'
import { databaseBrowserAPI } from '../services/api'
import { useAuth } from '../contexts/AuthContext'
import {
  TableCellsIcon,
  PencilIcon,
  PlusIcon,
  TrashIcon,
  MagnifyingGlassIcon,
  CodeBracketIcon,
  EyeIcon,
  ArrowPathIcon,
  ExclamationTriangleIcon,
  CheckCircleIcon,
  XCircleIcon,
  InformationCircleIcon,
  DocumentTextIcon,
  ChartBarIcon,
  ServerIcon,
  CircleStackIcon,
  Cog6ToothIcon,
  PlayIcon,
  StopIcon,
  ArrowUpTrayIcon,
  ArrowDownTrayIcon,
  PrinterIcon,
  DocumentArrowDownIcon,
  DocumentArrowUpIcon,
  ClipboardDocumentIcon,
  ChevronRightIcon,
  FunnelIcon,
  AdjustmentsHorizontalIcon,
  Squares2X2Icon,
  ListBulletIcon,
  TableCellsIcon as TableIcon,
  CommandLineIcon,
  CpuChipIcon,
  KeyIcon,
  LinkIcon,
  TagIcon,
  CalendarIcon,
  ClockIcon,
  UserIcon,
  UsersIcon,
  BuildingOfficeIcon,
  HomeIcon,
  GlobeAltIcon,
  CloudIcon,
  ShieldCheckIcon,
  LockClosedIcon,
  EyeSlashIcon,
  EyeIcon as ViewIcon,
  PencilSquareIcon,
  DocumentDuplicateIcon,
  DocumentPlusIcon,
  DocumentMinusIcon,
  XMarkIcon,
  DocumentCheckIcon,
  DocumentIcon,
  FolderIcon,
  FolderOpenIcon,
  FolderPlusIcon,
  FolderMinusIcon,
  ArchiveBoxIcon,
  ArchiveBoxXMarkIcon,
  ArchiveBoxArrowDownIcon,
  InboxIcon,
  InboxArrowDownIcon,
  InboxStackIcon,
  QueueListIcon,
  Bars3Icon,
  Bars3BottomLeftIcon,
  Bars3BottomRightIcon,
  Bars4Icon,
  BarsArrowUpIcon,
  BarsArrowDownIcon,
  ArrowLeftIcon,
  ArrowRightIcon,
  Bars3CenterLeftIcon,
  Bars3BottomLeftIcon as Bars3BottomLeft,
  Bars3BottomRightIcon as Bars3BottomRight,
  Bars3CenterLeftIcon as Bars3CenterLeft,
  Bars4Icon as Bars4,
  BarsArrowUpIcon as BarsArrowUp,
  BarsArrowDownIcon as BarsArrowDown,
  ArrowLeftIcon as BarsArrowLeft,
  ArrowRightIcon as BarsArrowRight,
  QueueListIcon as QueueList,
  InboxStackIcon as InboxStack,
  InboxArrowDownIcon as InboxArrowDown,
  InboxIcon as Inbox,
  ArchiveBoxArrowDownIcon as ArchiveBoxArrowDown,
  ArchiveBoxXMarkIcon as ArchiveBoxXMark,
  ArchiveBoxIcon as ArchiveBox,
  FolderMinusIcon as FolderMinus,
  FolderPlusIcon as FolderPlus,
  FolderOpenIcon as FolderOpen,
  FolderIcon as Folder,
  DocumentCheckIcon as DocumentCheck,
  XMarkIcon as DocumentXMark,
  DocumentMinusIcon as DocumentMinus,
  DocumentPlusIcon as DocumentPlus,
  DocumentDuplicateIcon as DocumentDuplicate,
  PencilSquareIcon as PencilSquare,
  EyeIcon as View,
  EyeSlashIcon as EyeSlash,
  LockClosedIcon as LockClosed,
  ShieldCheckIcon as ShieldCheck,
  CloudIcon as Cloud,
  GlobeAltIcon as GlobeAlt,
  HomeIcon as Home,
  BuildingOfficeIcon as BuildingOffice,
  UsersIcon as Users,
  UserIcon as User,
  ClockIcon as Clock,
  CalendarIcon as Calendar,
  TagIcon as Tag,
  LinkIcon as Link,
  KeyIcon as Key,
  CircleStackIcon as CircleStack,
  CpuChipIcon as CpuChip,
  CommandLineIcon as Terminal,
  CommandLineIcon as CommandLine,
  TableCellsIcon as Table,
  ListBulletIcon as ListBullet,
  Squares2X2Icon as Squares2X2,
  AdjustmentsHorizontalIcon as AdjustmentsHorizontal,
  FunnelIcon as Funnel,
  ChevronRightIcon as ChevronRight,
  ChevronDownIcon as ChevronDown,
  XMarkIcon as XMark,
  ClipboardIcon as Clipboard,
  ClipboardDocumentListIcon as ClipboardDocumentList,
  ClipboardDocumentCheckIcon as ClipboardDocumentCheck,
  ClipboardDocumentIcon as ClipboardDocument,
  DocumentArrowUpIcon as DocumentArrowUp,
  DocumentArrowDownIcon as DocumentArrowDown,
  PrinterIcon as Printer,
  ArrowDownTrayIcon as ArrowDownTray,
  ArrowUpTrayIcon as ArrowUpTray,
  StopIcon as Stop,
  PlayIcon as Play,
  Cog6ToothIcon as Cog6Tooth,
  CircleStackIcon as Database,
  ServerIcon as Server,
  ChartBarIcon as ChartBar,
  DocumentTextIcon as DocumentText,
  InformationCircleIcon as InformationCircle,
  XCircleIcon as XCircle,
  CheckCircleIcon as CheckCircle,
  ExclamationTriangleIcon as ExclamationTriangle,
  ArrowPathIcon as ArrowPath,
  EyeIcon as Eye,
  CodeBracketIcon as CodeBracket,
  MagnifyingGlassIcon as MagnifyingGlass,
  TrashIcon as Trash,
  PlusIcon as Plus,
  PencilIcon as Pencil,
  TableCellsIcon as TableCells,
  TrophyIcon
} from '@heroicons/react/24/outline'

interface DatabaseTable {
  name: string
  type: string
  schema: string
  rowCount: number
  size: string
  lastModified: string
  columns: TableColumn[]
}

interface TableColumn {
  name: string
  type: string
  nullable: boolean
  defaultValue?: any
  isPrimaryKey: boolean
  isForeignKey: boolean
  foreignKeyTable?: string
  foreignKeyColumn?: string
  maxLength?: number
  precision?: number
  scale?: number
}

interface TableData {
  data: any[]
  totalCount: number
  page: number
  limit: number
  totalPages: number
  columns: TableColumn[]
}

interface QueryResult {
  data: any[]
  columns: string[]
  rowCount: number
  executionTime: number
  error?: string
}

const DatabaseBrowser: React.FC = () => {
  const { user } = useAuth()
  const queryClient = useQueryClient()
  
  const [activeTab, setActiveTab] = useState<'browse' | 'query' | 'schema'>('browse')
  const [selectedTable, setSelectedTable] = useState<string>('')
  const [currentPage, setCurrentPage] = useState(1)
  const [pageSize, setPageSize] = useState(50)
  const [searchTerm, setSearchTerm] = useState('')
  const [customQuery, setCustomQuery] = useState('')
  const [showInsertModal, setShowInsertModal] = useState(false)
  const [showEditModal, setShowEditModal] = useState(false)
  const [showDeleteModal, setShowDeleteModal] = useState(false)
  const [showQueryModal, setShowQueryModal] = useState(false)
  const [selectedRecord, setSelectedRecord] = useState<any>(null)
  const [editingRecord, setEditingRecord] = useState<any>({})
  const [queryResult, setQueryResult] = useState<QueryResult | null>(null)
  const [isExecutingQuery, setIsExecutingQuery] = useState(false)

  // Fetch tables
  const { data: tables, isLoading: tablesLoading } = useQuery(
    'database-tables',
    () => databaseBrowserAPI.getTables().then(res => res.data),
    {
      enabled: user?.role === 'ADMIN' || user?.role === 'ORGANIZER',
    }
  )

  // Fetch table data
  const { data: tableData, isLoading: dataLoading } = useQuery(
    ['table-data', selectedTable, currentPage, pageSize, searchTerm],
    () => databaseBrowserAPI.getTableData(selectedTable, currentPage, pageSize, searchTerm).then(res => res.data),
    {
      enabled: !!selectedTable,
    }
  )

  // Fetch table schema
  const { data: tableSchema, isLoading: schemaLoading } = useQuery(
    ['table-schema', selectedTable],
    () => databaseBrowserAPI.getTableSchema(selectedTable).then(res => res.data),
    {
      enabled: !!selectedTable,
    }
  )

  // Mutations
  const insertMutation = useMutation(
    (data: any) => databaseBrowserAPI.insertRecord(selectedTable, data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['table-data', selectedTable])
        setShowInsertModal(false)
        setEditingRecord({})
      },
    }
  )

  const updateMutation = useMutation(
    ({ id, data }: { id: string; data: any }) => databaseBrowserAPI.updateRecord(selectedTable, id, data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['table-data', selectedTable])
        setShowEditModal(false)
        setEditingRecord({})
        setSelectedRecord(null)
      },
    }
  )

  const deleteMutation = useMutation(
    (id: string) => databaseBrowserAPI.deleteRecord(selectedTable, id),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['table-data', selectedTable])
        setShowDeleteModal(false)
        setSelectedRecord(null)
      },
    }
  )

  const executeQueryMutation = useMutation(
    (query: string) => databaseBrowserAPI.executeQuery(query),
    {
      onSuccess: (result) => {
        setQueryResult(result.data)
        setIsExecutingQuery(false)
      },
      onError: (error: any) => {
        setQueryResult({
          data: [],
          columns: [],
          rowCount: 0,
          executionTime: 0,
          error: error.response?.data?.error || 'Query execution failed'
        })
        setIsExecutingQuery(false)
      },
    }
  )

  const handleTableSelect = (tableName: string) => {
    setSelectedTable(tableName)
    setCurrentPage(1)
    setSearchTerm('')
  }

  const handleInsert = () => {
    setEditingRecord({})
    setShowInsertModal(true)
  }

  const handleEdit = (record: any) => {
    setSelectedRecord(record)
    setEditingRecord({ ...record })
    setShowEditModal(true)
  }

  const handleDelete = (record: any) => {
    setSelectedRecord(record)
    setShowDeleteModal(true)
  }

  const handleExecuteQuery = () => {
    if (!customQuery.trim()) return
    
    setIsExecutingQuery(true)
    executeQueryMutation.mutate(customQuery)
  }

  const handleInsertSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    insertMutation.mutate(editingRecord)
  }

  const handleEditSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    if (selectedRecord) {
      updateMutation.mutate({ id: selectedRecord.id, data: editingRecord })
    }
  }

  const handleDeleteConfirm = () => {
    if (selectedRecord) {
      deleteMutation.mutate(selectedRecord.id)
    }
  }

  const getColumnType = (type: string) => {
    const typeMap: { [key: string]: string } = {
      'varchar': 'text',
      'text': 'textarea',
      'int': 'number',
      'bigint': 'number',
      'decimal': 'number',
      'float': 'number',
      'double': 'number',
      'boolean': 'checkbox',
      'date': 'date',
      'datetime': 'datetime-local',
      'timestamp': 'datetime-local',
      'time': 'time',
      'json': 'textarea',
      'uuid': 'text',
      'char': 'text',
      'tinyint': 'number',
      'smallint': 'number',
      'mediumint': 'number',
      'real': 'number',
      'numeric': 'number',
      'bit': 'checkbox',
      'year': 'number',
      'binary': 'text',
      'varbinary': 'text',
      'blob': 'textarea',
      'longblob': 'textarea',
      'mediumblob': 'textarea',
      'tinyblob': 'textarea',
      'enum': 'select',
      'set': 'text',
      'geometry': 'text',
      'point': 'text',
      'linestring': 'text',
      'polygon': 'text',
      'multipoint': 'text',
      'multilinestring': 'text',
      'multipolygon': 'text',
      'geometrycollection': 'text'
    }
    return typeMap[type.toLowerCase()] || 'text'
  }

  const formatValue = (value: any, type: string) => {
    if (value === null || value === undefined) return 'NULL'
    if (type.toLowerCase().includes('date') || type.toLowerCase().includes('time')) {
      return new Date(value).toLocaleString()
    }
    if (type.toLowerCase() === 'json') {
      return JSON.stringify(value, null, 2)
    }
    if (typeof value === 'boolean') {
      return value ? 'true' : 'false'
    }
    return String(value)
  }

  const getTableIcon = (tableName: string) => {
    if (tableName.includes('user')) return <UserIcon className="h-5 w-5" />
    if (tableName.includes('event')) return <CalendarIcon className="h-5 w-5" />
    if (tableName.includes('contest')) return <TrophyIcon className="h-5 w-5" />
    if (tableName.includes('score')) return <ChartBarIcon className="h-5 w-5" />
    if (tableName.includes('log')) return <DocumentTextIcon className="h-5 w-5" />
    if (tableName.includes('setting')) return <Cog6ToothIcon className="h-5 w-5" />
    return <TableCellsIcon className="h-5 w-5" />
  }

  const getTableColor = (tableName: string) => {
    if (tableName.includes('user')) return 'text-blue-600'
    if (tableName.includes('event')) return 'text-green-600'
    if (tableName.includes('contest')) return 'text-purple-600'
    if (tableName.includes('score')) return 'text-orange-600'
    if (tableName.includes('log')) return 'text-gray-600'
    if (tableName.includes('setting')) return 'text-indigo-600'
    return 'text-gray-600'
  }

  if (!user || (user.role !== 'ADMIN' && user.role !== 'ORGANIZER')) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="text-center">
          <ExclamationTriangleIcon className="h-12 w-12 text-yellow-500 mx-auto mb-4" />
          <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">
            Access Denied
          </h3>
          <p className="text-gray-600 dark:text-gray-400">
            You don't have permission to access the database browser.
          </p>
        </div>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">
            Database Browser
          </h1>
          <p className="text-gray-600 dark:text-gray-400">
            Browse, edit, and manage database tables and records
          </p>
        </div>
        <div className="flex items-center space-x-3">
          <button
            onClick={() => setShowQueryModal(true)}
            className="btn-primary"
          >
            <CodeBracketIcon className="h-4 w-4 mr-2" />
            Custom Query
          </button>
          {selectedTable && (
            <button
              onClick={handleInsert}
              className="btn-primary"
            >
              <PlusIcon className="h-4 w-4 mr-2" />
              Insert Record
            </button>
          )}
        </div>
      </div>

      {/* Tabs */}
      <div className="border-b border-gray-200 dark:border-gray-700">
        <nav className="-mb-px flex space-x-8">
          <button
            onClick={() => setActiveTab('browse')}
            className={`py-2 px-1 border-b-2 font-medium text-sm ${
              activeTab === 'browse'
                ? 'border-blue-500 text-blue-600 dark:text-blue-400'
                : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 dark:text-gray-400 dark:hover:text-gray-300'
            }`}
          >
            <TableCellsIcon className="h-4 w-4 mr-2 inline" />
            Browse Data
          </button>
          <button
            onClick={() => setActiveTab('schema')}
            className={`py-2 px-1 border-b-2 font-medium text-sm ${
              activeTab === 'schema'
                ? 'border-blue-500 text-blue-600 dark:text-blue-400'
                : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 dark:text-gray-400 dark:hover:text-gray-300'
            }`}
          >
            <Database className="h-4 w-4 mr-2 inline" />
            Schema
          </button>
          <button
            onClick={() => setActiveTab('query')}
            className={`py-2 px-1 border-b-2 font-medium text-sm ${
              activeTab === 'query'
                ? 'border-blue-500 text-blue-600 dark:text-blue-400'
                : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 dark:text-gray-400 dark:hover:text-gray-300'
            }`}
          >
            <CodeBracketIcon className="h-4 w-4 mr-2 inline" />
            Query Editor
          </button>
        </nav>
      </div>

      {/* Content */}
      {activeTab === 'browse' && (
        <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
          {/* Tables List */}
          <div className="lg:col-span-1">
            <div className="card">
              <div className="card-header">
                <h3 className="card-title">Tables</h3>
              </div>
              <div className="card-content">
                {tablesLoading ? (
                  <div className="flex items-center justify-center py-8">
                    <div className="loading-spinner h-8 w-8"></div>
                  </div>
                ) : (
                  <div className="space-y-2">
                    {tables?.map((table: DatabaseTable) => (
                      <button
                        key={table.name}
                        onClick={() => handleTableSelect(table.name)}
                        className={`w-full text-left p-3 rounded-lg border transition-colors ${
                          selectedTable === table.name
                            ? 'bg-blue-50 border-blue-200 dark:bg-blue-900/20 dark:border-blue-800'
                            : 'bg-white border-gray-200 hover:bg-gray-50 dark:bg-gray-800 dark:border-gray-700 dark:hover:bg-gray-700'
                        }`}
                      >
                        <div className="flex items-center justify-between">
                          <div className="flex items-center space-x-3">
                            <div className={getTableColor(table.name)}>
                              {getTableIcon(table.name)}
                            </div>
                            <div>
                              <div className="font-medium text-gray-900 dark:text-white">
                                {table.name}
                              </div>
                              <div className="text-sm text-gray-500 dark:text-gray-400">
                                {table.rowCount.toLocaleString()} rows
                              </div>
                            </div>
                          </div>
                          <div className="text-xs text-gray-400">
                            {table.size}
                          </div>
                        </div>
                      </button>
                    ))}
                  </div>
                )}
              </div>
            </div>
          </div>

          {/* Table Data */}
          <div className="lg:col-span-3">
            {selectedTable ? (
              <div className="card">
                <div className="card-header">
                  <div className="flex items-center justify-between">
                    <div>
                      <h3 className="card-title">{selectedTable}</h3>
                      <p className="card-description">
                        {tableData?.totalCount.toLocaleString()} total records
                      </p>
                    </div>
                    <div className="flex items-center space-x-3">
                      <div className="relative">
                        <MagnifyingGlassIcon className="h-4 w-4 absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" />
                        <input
                          type="text"
                          placeholder="Search records..."
                          value={searchTerm}
                          onChange={(e) => setSearchTerm(e.target.value)}
                          className="input pl-10 w-64"
                        />
                      </div>
                      <select
                        value={pageSize}
                        onChange={(e) => setPageSize(Number(e.target.value))}
                        className="input w-20"
                      >
                        <option value={25}>25</option>
                        <option value={50}>50</option>
                        <option value={100}>100</option>
                        <option value={200}>200</option>
                      </select>
                    </div>
                  </div>
                </div>
                <div className="card-content">
                  {dataLoading ? (
                    <div className="flex items-center justify-center py-8">
                      <div className="loading-spinner h-8 w-8"></div>
                    </div>
                  ) : (
                    <div className="overflow-x-auto">
                      <table className="table">
                        <thead className="table-header">
                          <tr className="table-row">
                            {tableData?.columns.map((column) => (
                              <th key={column.name} className="table-head">
                                <div className="flex items-center space-x-2">
                                  <span>{column.name}</span>
                                  {column.isPrimaryKey && (
                                    <KeyIcon className="h-3 w-3 text-yellow-500" />
                                  )}
                                  {column.isForeignKey && (
                                    <LinkIcon className="h-3 w-3 text-blue-500" />
                                  )}
                                </div>
                              </th>
                            ))}
                            <th className="table-head">Actions</th>
                          </tr>
                        </thead>
                        <tbody className="table-body">
                          {tableData?.data.map((record, index) => (
                            <tr key={index} className="table-row">
                              {tableData.columns.map((column) => (
                                <td key={column.name} className="table-cell">
                                  <div className="max-w-xs truncate" title={formatValue(record[column.name], column.type)}>
                                    {formatValue(record[column.name], column.type)}
                                  </div>
                                </td>
                              ))}
                              <td className="table-cell">
                                <div className="flex items-center space-x-2">
                                  <button
                                    onClick={() => handleEdit(record)}
                                    className="text-blue-600 hover:text-blue-900 dark:text-blue-400 dark:hover:text-blue-300"
                                  >
                                    <PencilIcon className="h-4 w-4" />
                                  </button>
                                  <button
                                    onClick={() => handleDelete(record)}
                                    className="text-red-600 hover:text-red-900 dark:text-red-400 dark:hover:text-red-300"
                                  >
                                    <TrashIcon className="h-4 w-4" />
                                  </button>
                                </div>
                              </td>
                            </tr>
                          ))}
                        </tbody>
                      </table>
                    </div>
                  )}
                </div>
                {tableData && tableData.totalPages > 1 && (
                  <div className="card-footer">
                    <div className="flex items-center justify-between">
                      <div className="text-sm text-gray-500 dark:text-gray-400">
                        Showing {((currentPage - 1) * pageSize) + 1} to {Math.min(currentPage * pageSize, tableData.totalCount)} of {tableData.totalCount} records
                      </div>
                      <div className="flex items-center space-x-2">
                        <button
                          onClick={() => setCurrentPage(Math.max(1, currentPage - 1))}
                          disabled={currentPage === 1}
                          className="btn-secondary btn-sm"
                        >
                          Previous
                        </button>
                        <span className="text-sm text-gray-500 dark:text-gray-400">
                          Page {currentPage} of {tableData.totalPages}
                        </span>
                        <button
                          onClick={() => setCurrentPage(Math.min(tableData.totalPages, currentPage + 1))}
                          disabled={currentPage === tableData.totalPages}
                          className="btn-secondary btn-sm"
                        >
                          Next
                        </button>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            ) : (
              <div className="card">
                <div className="card-content">
                  <div className="text-center py-12">
                    <TableCellsIcon className="h-12 w-12 text-gray-400 mx-auto mb-4" />
                    <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">
                      Select a Table
                    </h3>
                    <p className="text-gray-600 dark:text-gray-400">
                      Choose a table from the list to view and edit its data.
                    </p>
                  </div>
                </div>
              </div>
            )}
          </div>
        </div>
      )}

      {activeTab === 'schema' && selectedTable && (
        <div className="card">
          <div className="card-header">
            <h3 className="card-title">Schema: {selectedTable}</h3>
          </div>
          <div className="card-content">
            {schemaLoading ? (
              <div className="flex items-center justify-center py-8">
                <div className="loading-spinner h-8 w-8"></div>
              </div>
            ) : (
              <div className="overflow-x-auto">
                <table className="table">
                  <thead className="table-header">
                    <tr className="table-row">
                      <th className="table-head">Column</th>
                      <th className="table-head">Type</th>
                      <th className="table-head">Nullable</th>
                      <th className="table-head">Default</th>
                      <th className="table-head">Primary Key</th>
                      <th className="table-head">Foreign Key</th>
                      <th className="table-head">Max Length</th>
                    </tr>
                  </thead>
                  <tbody className="table-body">
                    {tableSchema?.columns.map((column) => (
                      <tr key={column.name} className="table-row">
                        <td className="table-cell font-medium">{column.name}</td>
                        <td className="table-cell">
                          <code className="bg-gray-100 dark:bg-gray-800 px-2 py-1 rounded text-sm">
                            {column.type}
                          </code>
                        </td>
                        <td className="table-cell">
                          {column.nullable ? (
                            <span className="text-green-600 dark:text-green-400">Yes</span>
                          ) : (
                            <span className="text-red-600 dark:text-red-400">No</span>
                          )}
                        </td>
                        <td className="table-cell">
                          {column.defaultValue !== null ? (
                            <code className="bg-gray-100 dark:bg-gray-800 px-2 py-1 rounded text-sm">
                              {String(column.defaultValue)}
                            </code>
                          ) : (
                            <span className="text-gray-400">NULL</span>
                          )}
                        </td>
                        <td className="table-cell">
                          {column.isPrimaryKey ? (
                            <KeyIcon className="h-4 w-4 text-yellow-500" />
                          ) : (
                            <span className="text-gray-400">-</span>
                          )}
                        </td>
                        <td className="table-cell">
                          {column.isForeignKey ? (
                            <div className="flex items-center space-x-1">
                              <LinkIcon className="h-4 w-4 text-blue-500" />
                              <span className="text-sm">
                                {column.foreignKeyTable}.{column.foreignKeyColumn}
                              </span>
                            </div>
                          ) : (
                            <span className="text-gray-400">-</span>
                          )}
                        </td>
                        <td className="table-cell">
                          {column.maxLength ? (
                            <span className="text-sm">{column.maxLength}</span>
                          ) : (
                            <span className="text-gray-400">-</span>
                          )}
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            )}
          </div>
        </div>
      )}

      {activeTab === 'query' && (
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          {/* Query Editor */}
          <div className="card">
            <div className="card-header">
              <h3 className="card-title">Query Editor</h3>
            </div>
            <div className="card-content">
              <textarea
                value={customQuery}
                onChange={(e) => setCustomQuery(e.target.value)}
                placeholder="Enter your SQL query here..."
                className="input h-64 font-mono text-sm"
              />
              <div className="mt-4 flex items-center justify-between">
                <div className="text-sm text-gray-500 dark:text-gray-400">
                  {customQuery.length} characters
                </div>
                <button
                  onClick={handleExecuteQuery}
                  disabled={!customQuery.trim() || isExecutingQuery}
                  className="btn-primary"
                >
                  {isExecutingQuery ? (
                    <>
                      <div className="loading-spinner h-4 w-4 mr-2"></div>
                      Executing...
                    </>
                  ) : (
                    <>
                      <PlayIcon className="h-4 w-4 mr-2" />
                      Execute Query
                    </>
                  )}
                </button>
              </div>
            </div>
          </div>

          {/* Query Results */}
          <div className="card">
            <div className="card-header">
              <h3 className="card-title">Query Results</h3>
            </div>
            <div className="card-content">
              {queryResult ? (
                <div className="space-y-4">
                  {queryResult.error ? (
                    <div className="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-4">
                      <div className="flex items-center space-x-2">
                        <ExclamationTriangleIcon className="h-5 w-5 text-red-500" />
                        <span className="text-red-700 dark:text-red-400 font-medium">
                          Query Error
                        </span>
                      </div>
                      <p className="text-red-600 dark:text-red-300 mt-2">
                        {queryResult.error}
                      </p>
                    </div>
                  ) : (
                    <>
                      <div className="flex items-center justify-between">
                        <div className="text-sm text-gray-500 dark:text-gray-400">
                          {queryResult.rowCount} rows returned in {queryResult.executionTime}ms
                        </div>
                        <div className="flex items-center space-x-2">
                          <button className="btn-secondary btn-sm">
                            <ArrowDownTrayIcon className="h-4 w-4 mr-1" />
                            Export
                          </button>
                          <button className="btn-secondary btn-sm">
                            <PrinterIcon className="h-4 w-4 mr-1" />
                            Print
                          </button>
                        </div>
                      </div>
                      <div className="overflow-x-auto">
                        <table className="table">
                          <thead className="table-header">
                            <tr className="table-row">
                              {queryResult.columns.map((column) => (
                                <th key={column} className="table-head">
                                  {column}
                                </th>
                              ))}
                            </tr>
                          </thead>
                          <tbody className="table-body">
                            {queryResult.data.map((row, index) => (
                              <tr key={index} className="table-row">
                                {queryResult.columns.map((column) => (
                                  <td key={column} className="table-cell">
                                    <div className="max-w-xs truncate">
                                      {formatValue(row[column], 'text')}
                                    </div>
                                  </td>
                                ))}
                              </tr>
                            ))}
                          </tbody>
                        </table>
                      </div>
                    </>
                  )}
                </div>
              ) : (
                <div className="text-center py-12">
                  <CodeBracketIcon className="h-12 w-12 text-gray-400 mx-auto mb-4" />
                  <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">
                    No Query Executed
                  </h3>
                  <p className="text-gray-600 dark:text-gray-400">
                    Enter a SQL query and click "Execute Query" to see results.
                  </p>
                </div>
              )}
            </div>
          </div>
        </div>
      )}

      {/* Insert Modal */}
      {showInsertModal && (
        <div className="modal">
          <div className="modal-overlay" onClick={() => setShowInsertModal(false)}></div>
          <div className="modal-content max-w-4xl">
            <div className="flex items-center justify-between mb-6">
              <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                Insert New Record: {selectedTable}
              </h3>
              <button
                onClick={() => setShowInsertModal(false)}
                className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
              >
                <XMarkIcon className="h-6 w-6" />
              </button>
            </div>
            <form onSubmit={handleInsertSubmit} className="space-y-4">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {tableSchema?.columns.map((column) => (
                  <div key={column.name}>
                    <label className="label">
                      {column.name}
                      {column.isPrimaryKey && (
                        <span className="text-yellow-500 ml-1">*</span>
                      )}
                      {!column.nullable && !column.isPrimaryKey && (
                        <span className="text-red-500 ml-1">*</span>
                      )}
                    </label>
                    {getColumnType(column.type) === 'textarea' ? (
                      <textarea
                        value={editingRecord[column.name] || ''}
                        onChange={(e) => setEditingRecord({
                          ...editingRecord,
                          [column.name]: e.target.value
                        })}
                        className="input"
                        rows={3}
                        placeholder={column.defaultValue ? String(column.defaultValue) : ''}
                      />
                    ) : getColumnType(column.type) === 'checkbox' ? (
                      <input
                        type="checkbox"
                        checked={editingRecord[column.name] || false}
                        onChange={(e) => setEditingRecord({
                          ...editingRecord,
                          [column.name]: e.target.checked
                        })}
                        className="input"
                      />
                    ) : (
                      <input
                        type={getColumnType(column.type)}
                        value={editingRecord[column.name] || ''}
                        onChange={(e) => setEditingRecord({
                          ...editingRecord,
                          [column.name]: e.target.value
                        })}
                        className="input"
                        placeholder={column.defaultValue ? String(column.defaultValue) : ''}
                      />
                    )}
                    <div className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                      Type: {column.type}
                      {column.maxLength && ` (max: ${column.maxLength})`}
                    </div>
                  </div>
                ))}
              </div>
              <div className="flex justify-end space-x-3">
                <button
                  type="button"
                  onClick={() => setShowInsertModal(false)}
                  className="btn-secondary"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  disabled={insertMutation.isLoading}
                  className="btn-primary"
                >
                  {insertMutation.isLoading ? (
                    <>
                      <div className="loading-spinner h-4 w-4 mr-2"></div>
                      Inserting...
                    </>
                  ) : (
                    <>
                      <PlusIcon className="h-4 w-4 mr-2" />
                      Insert Record
                    </>
                  )}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}

      {/* Edit Modal */}
      {showEditModal && selectedRecord && (
        <div className="modal">
          <div className="modal-overlay" onClick={() => setShowEditModal(false)}></div>
          <div className="modal-content max-w-4xl">
            <div className="flex items-center justify-between mb-6">
              <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                Edit Record: {selectedTable}
              </h3>
              <button
                onClick={() => setShowEditModal(false)}
                className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
              >
                <XMarkIcon className="h-6 w-6" />
              </button>
            </div>
            <form onSubmit={handleEditSubmit} className="space-y-4">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                {tableSchema?.columns.map((column) => (
                  <div key={column.name}>
                    <label className="label">
                      {column.name}
                      {column.isPrimaryKey && (
                        <span className="text-yellow-500 ml-1">*</span>
                      )}
                      {!column.nullable && !column.isPrimaryKey && (
                        <span className="text-red-500 ml-1">*</span>
                      )}
                    </label>
                    {getColumnType(column.type) === 'textarea' ? (
                      <textarea
                        value={editingRecord[column.name] || ''}
                        onChange={(e) => setEditingRecord({
                          ...editingRecord,
                          [column.name]: e.target.value
                        })}
                        className="input"
                        rows={3}
                      />
                    ) : getColumnType(column.type) === 'checkbox' ? (
                      <input
                        type="checkbox"
                        checked={editingRecord[column.name] || false}
                        onChange={(e) => setEditingRecord({
                          ...editingRecord,
                          [column.name]: e.target.checked
                        })}
                        className="input"
                      />
                    ) : (
                      <input
                        type={getColumnType(column.type)}
                        value={editingRecord[column.name] || ''}
                        onChange={(e) => setEditingRecord({
                          ...editingRecord,
                          [column.name]: e.target.value
                        })}
                        className="input"
                      />
                    )}
                    <div className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                      Type: {column.type}
                      {column.maxLength && ` (max: ${column.maxLength})`}
                    </div>
                  </div>
                ))}
              </div>
              <div className="flex justify-end space-x-3">
                <button
                  type="button"
                  onClick={() => setShowEditModal(false)}
                  className="btn-secondary"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  disabled={updateMutation.isLoading}
                  className="btn-primary"
                >
                  {updateMutation.isLoading ? (
                    <>
                      <div className="loading-spinner h-4 w-4 mr-2"></div>
                      Updating...
                    </>
                  ) : (
                    <>
                      <PencilIcon className="h-4 w-4 mr-2" />
                      Update Record
                    </>
                  )}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}

      {/* Delete Modal */}
      {showDeleteModal && selectedRecord && (
        <div className="modal">
          <div className="modal-overlay" onClick={() => setShowDeleteModal(false)}></div>
          <div className="modal-content">
            <div className="flex items-center justify-between mb-6">
              <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                Delete Record
              </h3>
              <button
                onClick={() => setShowDeleteModal(false)}
                className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
              >
                <XMarkIcon className="h-6 w-6" />
              </button>
            </div>
            <div className="space-y-4">
              <div className="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-4">
                <div className="flex items-center space-x-2">
                  <ExclamationTriangleIcon className="h-5 w-5 text-red-500" />
                  <span className="text-red-700 dark:text-red-400 font-medium">
                    Warning
                  </span>
                </div>
                <p className="text-red-600 dark:text-red-300 mt-2">
                  This action cannot be undone. The record will be permanently deleted from the database.
                </p>
              </div>
              <div className="bg-gray-50 dark:bg-gray-800 rounded-lg p-4">
                <h4 className="font-medium text-gray-900 dark:text-white mb-2">
                  Record Details:
                </h4>
                <div className="space-y-1">
                  {Object.entries(selectedRecord).map(([key, value]) => (
                    <div key={key} className="flex justify-between text-sm">
                      <span className="font-medium text-gray-600 dark:text-gray-400">
                        {key}:
                      </span>
                      <span className="text-gray-900 dark:text-white">
                        {formatValue(value, 'text')}
                      </span>
                    </div>
                  ))}
                </div>
              </div>
              <div className="flex justify-end space-x-3">
                <button
                  onClick={() => setShowDeleteModal(false)}
                  className="btn-secondary"
                >
                  Cancel
                </button>
                <button
                  onClick={handleDeleteConfirm}
                  disabled={deleteMutation.isLoading}
                  className="btn-destructive"
                >
                  {deleteMutation.isLoading ? (
                    <>
                      <div className="loading-spinner h-4 w-4 mr-2"></div>
                      Deleting...
                    </>
                  ) : (
                    <>
                      <TrashIcon className="h-4 w-4 mr-2" />
                      Delete Record
                    </>
                  )}
                </button>
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}

export default DatabaseBrowser
EOF

    # Add EmceeScripts component to admin and board pages
    # Update AdminPage to include EmceeScripts
    # Add EmceeScripts tab to AdminPage
    if ! grep -q "Emcee Scripts" "$APP_DIR/frontend/src/pages/AdminPage.tsx" 2>/dev/null; then
        sed -i '/const tabs = \[/a\    { id: "emcee-scripts", name: "Emcee Scripts", icon: DocumentTextIcon, component: EmceeScripts },' "$APP_DIR/frontend/src/pages/AdminPage.tsx" 2>/dev/null || true
    fi
    
    # Update BoardPage to include EmceeScripts
    # Add EmceeScripts tab to BoardPage
    if ! grep -q "Emcee Scripts" "$APP_DIR/frontend/src/pages/BoardPage.tsx" 2>/dev/null; then
        sed -i '/const tabs = \[/a\    { id: "emcee-scripts", name: "Emcee Scripts", icon: DocumentTextIcon, component: EmceeScripts },' "$APP_DIR/frontend/src/pages/BoardPage.tsx" 2>/dev/null || true
    fi

    # Update WinnersPage with certification progress and role-based visibility
    cat > "$APP_DIR/frontend/src/pages/WinnersPage.tsx" << 'EOF'
import React, { useState } from 'react'
import { useQuery } from 'react-query'
import { useAuth } from '../contexts/AuthContext'
import { winnersAPI } from '../services/api'
import {
  TrophyIcon,
  CheckCircleIcon,
  XCircleIcon,
  ClockIcon,
  ExclamationTriangleIcon,
  EyeIcon,
  PrinterIcon,
  DocumentTextIcon,
  UserGroupIcon,
  StarIcon,
  ShieldCheckIcon,
  LockClosedIcon,
  MagnifyingGlassIcon,
  FunnelIcon,
  ArrowDownTrayIcon,
  ShareIcon,
  CalendarIcon,
  ChartBarIcon,
  InformationCircleIcon,
  XMarkIcon,
  ChevronDownIcon,
  ChevronRightIcon
} from '@heroicons/react/24/outline'

interface Winner {
  id: string
  contestantId: string
  contestantName: string
  contestantNumber?: string
  categoryId: string
  categoryName: string
  contestId: string
  contestName: string
  eventId: string
  eventName: string
  rank: number
  totalScore: number
  averageScore: number
  isCertified: boolean
  certificationStatus: 'PENDING' | 'IN_PROGRESS' | 'CERTIFIED' | 'REJECTED'
  certificationProgress: {
    judge: boolean
    tallyMaster: boolean
    auditor: boolean
    board: boolean
  }
  certifiedAt?: string
  certifiedBy?: string
  rejectionReason?: string
  createdAt: string
  updatedAt: string
}

interface CertificationProgress {
  totalSteps: number
  completedSteps: number
  currentStep: string
  canDisplay: boolean
  requiredSignatures: string[]
  completedSignatures: string[]
}

const WinnersPage: React.FC = () => {
  const { user } = useAuth()
  const [selectedEvent, setSelectedEvent] = useState<string>('')
  const [selectedContest, setSelectedContest] = useState<string>('')
  const [selectedCategory, setSelectedCategory] = useState<string>('')
  const [showDetails, setShowDetails] = useState<boolean>(false)
  const [selectedWinner, setSelectedWinner] = useState<Winner | null>(null)

  // Fetch events
  const { data: events } = useQuery('events', () => 
    fetch('/api/events').then(res => res.json())
  )

  // Fetch contests
  const { data: contests } = useQuery(['contests', selectedEvent], () => 
    fetch(`/api/contests?eventId=${selectedEvent}`).then(res => res.json()),
    { enabled: !!selectedEvent }
  )

  // Fetch categories
  const { data: categories } = useQuery(['categories', selectedContest], () => 
    fetch(`/api/categories?contestId=${selectedContest}`).then(res => res.json()),
    { enabled: !!selectedContest }
  )

  // Fetch winners
  const { data: winners, isLoading } = useQuery(
    ['winners', selectedEvent, selectedContest, selectedCategory],
    () => winnersAPI.getWinners({
      eventId: selectedEvent,
      contestId: selectedContest,
      categoryId: selectedCategory
    }).then(res => res.data),
    { enabled: !!(selectedEvent && selectedContest && selectedCategory) }
  )

  const getCertificationProgress = (winner: Winner): CertificationProgress => {
    const progress = winner.certificationProgress
    const totalSteps = 4 // judge, tallyMaster, auditor, board
    const completedSteps = Object.values(progress).filter(Boolean).length
    
    const requiredSignatures = ['Judge', 'Tally Master', 'Auditor', 'Board']
    const completedSignatures = Object.entries(progress)
      .filter(([_, completed]) => completed)
      .map(([key, _]) => {
        switch (key) {
          case 'judge': return 'Judge'
          case 'tallyMaster': return 'Tally Master'
          case 'auditor': return 'Auditor'
          case 'board': return 'Board'
          default: return key
        }
      })

    const canDisplay = user?.role === 'ADMIN' || user?.role === 'BOARD' || 
                      (user?.role === 'EMCEE' && progress.board)

    return {
      totalSteps,
      completedSteps,
      currentStep: completedSteps === totalSteps ? 'COMPLETED' : 'IN_PROGRESS',
      canDisplay,
      requiredSignatures,
      completedSignatures
    }
  }

  const getRankIcon = (rank: number) => {
    switch (rank) {
      case 1: return <TrophyIcon className="h-6 w-6 text-yellow-500" />
      case 2: return <StarIcon className="h-6 w-6 text-gray-400" />
      case 3: return <StarIcon className="h-6 w-6 text-amber-600" />
      default: return <StarIcon className="h-6 w-6 text-blue-500" />
    }
  }

  const getRankColor = (rank: number) => {
    switch (rank) {
      case 1: return 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200'
      case 2: return 'bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200'
      case 3: return 'bg-amber-100 text-amber-800 dark:bg-amber-900 dark:text-amber-200'
      default: return 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200'
    }
  }

  const getCertificationStatus = (progress: CertificationProgress) => {
    if (progress.completedSteps === progress.totalSteps) {
      return {
        icon: <CheckCircleIcon className="h-5 w-5 text-green-500" />,
        text: 'Fully Certified',
        color: 'text-green-600 dark:text-green-400'
      }
    } else if (progress.completedSteps > 0) {
      return {
        icon: <ClockIcon className="h-5 w-5 text-yellow-500" />,
        text: `${progress.completedSteps}/${progress.totalSteps} Certified`,
        color: 'text-yellow-600 dark:text-yellow-400'
      }
    } else {
      return {
        icon: <ExclamationTriangleIcon className="h-5 w-5 text-red-500" />,
        text: 'Not Certified',
        color: 'text-red-600 dark:text-red-400'
      }
    }
  }

  const canViewWinners = () => {
    if (!user) return false
    if (user.role === 'ADMIN' || user.role === 'BOARD') return true
    if (user.role === 'EMCEE') {
      // Emcee can only see winners after board certification
      return winners?.some((winner: Winner) => 
        winner.certificationProgress.board
      ) || false
    }
    return false
  }

  const handlePrintWinners = () => {
    window.print()
  }

  const handleExportWinners = () => {
    if (!winners) return
    
    const csvContent = [
      ['Rank', 'Contestant', 'Category', 'Total Score', 'Average Score', 'Certification Status'],
      ...winners.map((winner: Winner) => {
        const progress = getCertificationProgress(winner)
        const status = getCertificationStatus(progress)
        return [
          winner.rank,
          winner.contestantName,
          winner.categoryName,
          winner.totalScore.toFixed(2),
          winner.averageScore.toFixed(2),
          status.text
        ]
      })
    ].map(row => row.join(',')).join('\n')

    const blob = new Blob([csvContent], { type: 'text/csv' })
    const url = window.URL.createObjectURL(blob)
    const a = document.createElement('a')
    a.href = url
    a.download = `winners-${selectedEvent}-${selectedContest}-${selectedCategory}.csv`
    a.click()
    window.URL.revokeObjectURL(url)
  }

  if (!canViewWinners()) {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="text-center">
          <LockClosedIcon className="h-12 w-12 text-yellow-500 mx-auto mb-4" />
          <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">
            Winners Not Available
          </h3>
          <p className="text-gray-600 dark:text-gray-400">
            {user?.role === 'EMCEE' 
              ? 'Winners will be displayed after board certification is complete.'
              : 'You don\'t have permission to view winners.'}
          </p>
        </div>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">
            Winners
          </h1>
          <p className="text-gray-600 dark:text-gray-400">
            View contest winners and certification status
          </p>
        </div>
        <div className="flex items-center space-x-3">
          <button
            onClick={handleExportWinners}
            disabled={!winners || winners.length === 0}
            className="btn-secondary"
          >
            <ArrowDownTrayIcon className="h-4 w-4 mr-2" />
            Export
          </button>
          <button
            onClick={handlePrintWinners}
            disabled={!winners || winners.length === 0}
            className="btn-primary"
          >
            <PrinterIcon className="h-4 w-4 mr-2" />
            Print
          </button>
        </div>
      </div>

      {/* Filters */}
      <div className="card">
        <div className="card-header">
          <h3 className="card-title">Filter Winners</h3>
        </div>
        <div className="card-content">
          <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
            <div>
              <label className="label">Event</label>
              <select
                value={selectedEvent}
                onChange={(e) => {
                  setSelectedEvent(e.target.value)
                  setSelectedContest('')
                  setSelectedCategory('')
                }}
                className="input"
              >
                <option value="">Select Event</option>
                {events?.map((event: any) => (
                  <option key={event.id} value={event.id}>
                    {event.name}
                  </option>
                ))}
              </select>
            </div>
            <div>
              <label className="label">Contest</label>
              <select
                value={selectedContest}
                onChange={(e) => {
                  setSelectedContest(e.target.value)
                  setSelectedCategory('')
                }}
                className="input"
                disabled={!selectedEvent}
              >
                <option value="">Select Contest</option>
                {contests?.map((contest: any) => (
                  <option key={contest.id} value={contest.id}>
                    {contest.name}
                  </option>
                ))}
              </select>
            </div>
            <div>
              <label className="label">Category</label>
              <select
                value={selectedCategory}
                onChange={(e) => setSelectedCategory(e.target.value)}
                className="input"
                disabled={!selectedContest}
              >
                <option value="">Select Category</option>
                {categories?.map((category: any) => (
                  <option key={category.id} value={category.id}>
                    {category.name}
                  </option>
                ))}
              </select>
            </div>
          </div>
        </div>
      </div>

      {/* Winners List */}
      {selectedEvent && selectedContest && selectedCategory && (
        <div className="card">
          <div className="card-header">
            <div className="flex items-center justify-between">
              <div>
                <h3 className="card-title">Winners</h3>
                <p className="card-description">
                  {winners?.length || 0} winners found
                </p>
              </div>
              <div className="flex items-center space-x-2">
                <div className="text-sm text-gray-500 dark:text-gray-400">
                  Certification Status:
                </div>
                <div className="flex items-center space-x-4">
                  <div className="flex items-center space-x-1">
                    <CheckCircleIcon className="h-4 w-4 text-green-500" />
                    <span className="text-sm">Certified</span>
                  </div>
                  <div className="flex items-center space-x-1">
                    <ClockIcon className="h-4 w-4 text-yellow-500" />
                    <span className="text-sm">Partial</span>
                  </div>
                  <div className="flex items-center space-x-1">
                    <ExclamationTriangleIcon className="h-4 w-4 text-red-500" />
                    <span className="text-sm">Pending</span>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div className="card-content">
            {isLoading ? (
              <div className="flex items-center justify-center py-8">
                <div className="loading-spinner h-8 w-8"></div>
              </div>
            ) : winners && winners.length > 0 ? (
              <div className="space-y-4">
                {winners.map((winner: Winner) => {
                  const progress = getCertificationProgress(winner)
                  const status = getCertificationStatus(progress)
                  
                  return (
                    <div
                      key={winner.id}
                      className={`border rounded-lg p-4 transition-colors ${
                        progress.canDisplay 
                          ? 'bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700' 
                          : 'bg-gray-50 dark:bg-gray-900 border-gray-300 dark:border-gray-600 opacity-75'
                      }`}
                    >
                      <div className="flex items-center justify-between">
                        <div className="flex items-center space-x-4">
                          <div className="flex items-center space-x-2">
                            {getRankIcon(winner.rank)}
                            <span className={`px-3 py-1 rounded-full text-sm font-medium ${getRankColor(winner.rank)}`}>
                              #{winner.rank}
                            </span>
                          </div>
                          <div>
                            <h4 className="font-medium text-gray-900 dark:text-white">
                              {winner.contestantName}
                              {winner.contestantNumber && (
                                <span className="text-sm text-gray-500 dark:text-gray-400 ml-2">
                                  (#{winner.contestantNumber})
                                </span>
                              )}
                            </h4>
                            <p className="text-sm text-gray-600 dark:text-gray-400">
                              {winner.categoryName} - {winner.contestName}
                            </p>
                          </div>
                        </div>
                        <div className="flex items-center space-x-6">
                          <div className="text-right">
                            <div className="text-lg font-semibold text-gray-900 dark:text-white">
                              {winner.totalScore.toFixed(2)}
                            </div>
                            <div className="text-sm text-gray-500 dark:text-gray-400">
                              Avg: {winner.averageScore.toFixed(2)}
                            </div>
                          </div>
                          <div className="flex items-center space-x-2">
                            {status.icon}
                            <span className={`text-sm font-medium ${status.color}`}>
                              {status.text}
                            </span>
                          </div>
                          <button
                            onClick={() => {
                              setSelectedWinner(winner)
                              setShowDetails(true)
                            }}
                            className="text-blue-600 hover:text-blue-900 dark:text-blue-400 dark:hover:text-blue-300"
                          >
                            <EyeIcon className="h-5 w-5" />
                          </button>
                        </div>
                      </div>
                      
                      {/* Certification Progress */}
                      <div className="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700">
                        <div className="flex items-center justify-between mb-2">
                          <span className="text-sm font-medium text-gray-700 dark:text-gray-300">
                            Certification Progress
                          </span>
                          <span className="text-sm text-gray-500 dark:text-gray-400">
                            {progress.completedSteps}/{progress.totalSteps} signatures
                          </span>
                        </div>
                        <div className="flex items-center space-x-4">
                          {progress.requiredSignatures.map((signature) => {
                            const isCompleted = progress.completedSignatures.includes(signature)
                            return (
                              <div
                                key={signature}
                                className={`flex items-center space-x-1 ${
                                  isCompleted ? 'text-green-600 dark:text-green-400' : 'text-gray-400'
                                }`}
                              >
                                {isCompleted ? (
                                  <CheckCircleIcon className="h-4 w-4" />
                                ) : (
                                  <ClockIcon className="h-4 w-4" />
                                )}
                                <span className="text-sm">{signature}</span>
                              </div>
                            )
                          })}
                        </div>
                        {!progress.canDisplay && user?.role === 'EMCEE' && (
                          <div className="mt-2 p-2 bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded">
                            <div className="flex items-center space-x-2">
                              <InformationCircleIcon className="h-4 w-4 text-yellow-600" />
                              <span className="text-sm text-yellow-700 dark:text-yellow-300">
                                Winner will be displayed after board certification
                              </span>
                            </div>
                          </div>
                        )}
                      </div>
                    </div>
                  )
                })}
              </div>
            ) : (
              <div className="text-center py-12">
                <TrophyIcon className="h-12 w-12 text-gray-400 mx-auto mb-4" />
                <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">
                  No Winners Found
                </h3>
                <p className="text-gray-600 dark:text-gray-400">
                  Select an event, contest, and category to view winners.
                </p>
              </div>
            )}
          </div>
        </div>
      )}

      {/* Winner Details Modal */}
      {showDetails && selectedWinner && (
        <div className="modal">
          <div className="modal-overlay" onClick={() => setShowDetails(false)}></div>
          <div className="modal-content max-w-2xl">
            <div className="flex items-center justify-between mb-6">
              <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                Winner Details
              </h3>
              <button
                onClick={() => setShowDetails(false)}
                className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
              >
                <XMarkIcon className="h-6 w-6" />
              </button>
            </div>
            
            <div className="space-y-6">
              {/* Winner Info */}
              <div className="bg-gray-50 dark:bg-gray-800 rounded-lg p-4">
                <div className="flex items-center space-x-4">
                  {getRankIcon(selectedWinner.rank)}
                  <div>
                    <h4 className="text-lg font-semibold text-gray-900 dark:text-white">
                      {selectedWinner.contestantName}
                    </h4>
                    <p className="text-gray-600 dark:text-gray-400">
                      {selectedWinner.categoryName} - {selectedWinner.contestName}
                    </p>
                  </div>
                </div>
                <div className="mt-4 grid grid-cols-2 gap-4">
                  <div>
                    <span className="text-sm text-gray-500 dark:text-gray-400">Rank:</span>
                    <div className="font-semibold">#{selectedWinner.rank}</div>
                  </div>
                  <div>
                    <span className="text-sm text-gray-500 dark:text-gray-400">Total Score:</span>
                    <div className="font-semibold">{selectedWinner.totalScore.toFixed(2)}</div>
                  </div>
                  <div>
                    <span className="text-sm text-gray-500 dark:text-gray-400">Average Score:</span>
                    <div className="font-semibold">{selectedWinner.averageScore.toFixed(2)}</div>
                  </div>
                  <div>
                    <span className="text-sm text-gray-500 dark:text-gray-400">Contestant Number:</span>
                    <div className="font-semibold">{selectedWinner.contestantNumber || 'N/A'}</div>
                  </div>
                </div>
              </div>

              {/* Certification Details */}
              <div className="bg-gray-50 dark:bg-gray-800 rounded-lg p-4">
                <h5 className="font-semibold text-gray-900 dark:text-white mb-3">
                  Certification Status
                </h5>
                {(() => {
                  const progress = getCertificationProgress(selectedWinner)
                  const status = getCertificationStatus(progress)
                  
                  return (
                    <div className="space-y-3">
                      <div className="flex items-center space-x-2">
                        {status.icon}
                        <span className={`font-medium ${status.color}`}>
                          {status.text}
                        </span>
                      </div>
                      
                      <div className="space-y-2">
                        {progress.requiredSignatures.map((signature) => {
                          const isCompleted = progress.completedSignatures.includes(signature)
                          return (
                            <div
                              key={signature}
                              className={`flex items-center justify-between p-2 rounded ${
                                isCompleted 
                                  ? 'bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800' 
                                  : 'bg-gray-100 dark:bg-gray-700 border border-gray-200 dark:border-gray-600'
                              }`}
                            >
                              <span className="text-sm font-medium">{signature}</span>
                              {isCompleted ? (
                                <CheckCircleIcon className="h-4 w-4 text-green-500" />
                              ) : (
                                <ClockIcon className="h-4 w-4 text-gray-400" />
                              )}
                            </div>
                          )
                        })}
                      </div>
                      
                      {selectedWinner.certifiedAt && (
                        <div className="text-sm text-gray-500 dark:text-gray-400">
                          Certified on: {new Date(selectedWinner.certifiedAt).toLocaleString()}
                          {selectedWinner.certifiedBy && (
                            <span> by {selectedWinner.certifiedBy}</span>
                          )}
                        </div>
                      )}
                    </div>
                  )
                })()}
              </div>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}

export default WinnersPage
EOF

    # Add CategoryEditor component
    cat > "$APP_DIR/frontend/src/components/CategoryEditor.tsx" << 'EOF'
import React, { useState } from 'react'
import { useQuery, useMutation, useQueryClient } from 'react-query'
import { useAuth } from '../contexts/AuthContext'
import { categoriesAPI } from '../services/api'
import {
  PlusIcon,
  PencilIcon,
  TrashIcon,
  CheckCircleIcon,
  XCircleIcon,
  ClockIcon,
  ExclamationTriangleIcon,
  MagnifyingGlassIcon,
  EyeIcon,
  XMarkIcon,
  DocumentTextIcon,
  StarIcon,
  AdjustmentsHorizontalIcon,
  InformationCircleIcon,
  CheckIcon,
  XMarkIcon as XIcon
} from '@heroicons/react/24/outline'

interface Category {
  id: string
  name: string
  description?: string
  contestId: string
  contestName: string
  eventId: string
  eventName: string
  criteria: Criterion[]
  createdAt: string
  updatedAt: string
}

interface Criterion {
  id: string
  name: string
  description?: string
  maxScore: number
  minScore?: number
  timeLimit?: number
  isRequired: boolean
  order: number
  categoryId: string
  createdAt: string
  updatedAt: string
}

interface CreateCategoryData {
  name: string
  description?: string
  contestId: string
}

interface CreateCriterionData {
  name: string
  description?: string
  maxScore: number
  minScore?: number
  timeLimit?: number
  isRequired: boolean
  order: number
  categoryId: string
}

const CategoryEditor: React.FC = () => {
  const { user } = useAuth()
  const queryClient = useQueryClient()
  const [selectedEvent, setSelectedEvent] = useState<string>('')
  const [selectedContest, setSelectedContest] = useState<string>('')
  const [showCreateCategoryModal, setShowCreateCategoryModal] = useState<boolean>(false)
  const [showEditCategoryModal, setShowEditCategoryModal] = useState<boolean>(false)
  const [showCreateCriterionModal, setShowCreateCriterionModal] = useState<boolean>(false)
  const [showEditCriterionModal, setShowEditCriterionModal] = useState<boolean>(false)
  const [selectedCategory, setSelectedCategory] = useState<Category | null>(null)
  const [selectedCriterion, setSelectedCriterion] = useState<Criterion | null>(null)
  const [searchTerm, setSearchTerm] = useState<string>('')

  // Fetch events
  const { data: events } = useQuery('events', () => 
    fetch('/api/events').then(res => res.json())
  )

  // Fetch contests
  const { data: contests } = useQuery(['contests', selectedEvent], () => 
    fetch(`/api/contests?eventId=${selectedEvent}`).then(res => res.json()),
    { enabled: !!selectedEvent }
  )

  // Fetch categories
  const { data: categories, isLoading } = useQuery(
    ['categories', selectedContest, searchTerm],
    () => categoriesAPI.getCategories({
      contestId: selectedContest,
      search: searchTerm
    }).then(res => res.data),
    { enabled: !!selectedContest }
  )

  // Create category mutation
  const createCategoryMutation = useMutation(
    (data: CreateCategoryData) => categoriesAPI.createCategory(data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('categories')
        setShowCreateCategoryModal(false)
      }
    }
  )

  // Update category mutation
  const updateCategoryMutation = useMutation(
    ({ id, data }: { id: string; data: Partial<Category> }) => 
      categoriesAPI.updateCategory(id, data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('categories')
        setShowEditCategoryModal(false)
        setSelectedCategory(null)
      }
    }
  )

  // Delete category mutation
  const deleteCategoryMutation = useMutation(
    (id: string) => categoriesAPI.deleteCategory(id),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('categories')
      }
    }
  )

  // Create criterion mutation
  const createCriterionMutation = useMutation(
    (data: CreateCriterionData) => categoriesAPI.createCriterion(data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('categories')
        setShowCreateCriterionModal(false)
      }
    }
  )

  // Update criterion mutation
  const updateCriterionMutation = useMutation(
    ({ id, data }: { id: string; data: Partial<Criterion> }) => 
      categoriesAPI.updateCriterion(id, data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('categories')
        setShowEditCriterionModal(false)
        setSelectedCriterion(null)
      }
    }
  )

  // Delete criterion mutation
  const deleteCriterionMutation = useMutation(
    (id: string) => categoriesAPI.deleteCriterion(id),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('categories')
      }
    }
  )

  const canManageCategories = () => {
    return user?.role === 'ADMIN' || user?.role === 'BOARD' || user?.role === 'ORGANIZER'
  }

  const handleCreateCategory = (data: CreateCategoryData) => {
    createCategoryMutation.mutate(data)
  }

  const handleUpdateCategory = (id: string, data: Partial<Category>) => {
    updateCategoryMutation.mutate({ id, data })
  }

  const handleDeleteCategory = (id: string) => {
    if (window.confirm('Are you sure you want to delete this category? This will also delete all criteria.')) {
      deleteCategoryMutation.mutate(id)
    }
  }

  const handleCreateCriterion = (data: CreateCriterionData) => {
    createCriterionMutation.mutate(data)
  }

  const handleUpdateCriterion = (id: string, data: Partial<Criterion>) => {
    updateCriterionMutation.mutate({ id, data })
  }

  const handleDeleteCriterion = (id: string) => {
    if (window.confirm('Are you sure you want to delete this criterion?')) {
      deleteCriterionMutation.mutate(id)
    }
  }

  const filteredCategories = categories?.filter((category: Category) => {
    const matchesSearch = category.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                         category.description?.toLowerCase().includes(searchTerm.toLowerCase())
    return matchesSearch
  }) || []

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">
            Category Editor
          </h1>
          <p className="text-gray-600 dark:text-gray-400">
            Manage contest categories and scoring criteria
          </p>
        </div>
        {canManageCategories() && (
          <button
            onClick={() => setShowCreateCategoryModal(true)}
            className="btn-primary"
            disabled={!selectedContest}
          >
            <PlusIcon className="h-4 w-4 mr-2" />
            New Category
          </button>
        )}
      </div>

      {/* Filters */}
      <div className="card">
        <div className="card-header">
          <h3 className="card-title">Filter Categories</h3>
        </div>
        <div className="card-content">
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <label className="label">Event</label>
              <select
                value={selectedEvent}
                onChange={(e) => {
                  setSelectedEvent(e.target.value)
                  setSelectedContest('')
                }}
                className="input"
              >
                <option value="">Select Event</option>
                {events?.map((event: any) => (
                  <option key={event.id} value={event.id}>
                    {event.name}
                  </option>
                ))}
              </select>
            </div>
            <div>
              <label className="label">Contest</label>
              <select
                value={selectedContest}
                onChange={(e) => setSelectedContest(e.target.value)}
                className="input"
                disabled={!selectedEvent}
              >
                <option value="">Select Contest</option>
                {contests?.map((contest: any) => (
                  <option key={contest.id} value={contest.id}>
                    {contest.name}
                  </option>
                ))}
              </select>
            </div>
          </div>
          <div className="mt-4">
            <div className="relative">
              <MagnifyingGlassIcon className="h-5 w-5 absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" />
              <input
                type="text"
                placeholder="Search categories..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="input pl-10"
              />
            </div>
          </div>
        </div>
      </div>

      {/* Categories List */}
      {selectedEvent && selectedContest && (
        <div className="card">
          <div className="card-header">
            <div className="flex items-center justify-between">
              <div>
                <h3 className="card-title">Categories</h3>
                <p className="card-description">
                  {filteredCategories.length} categories found
                </p>
              </div>
            </div>
          </div>
          <div className="card-content">
            {isLoading ? (
              <div className="flex items-center justify-center py-8">
                <div className="loading-spinner h-8 w-8"></div>
              </div>
            ) : filteredCategories.length > 0 ? (
              <div className="space-y-4">
                {filteredCategories.map((category: Category) => (
                  <div
                    key={category.id}
                    className="border rounded-lg p-4 bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700"
                  >
                    <div className="flex items-center justify-between">
                      <div className="flex-1">
                        <div className="flex items-center space-x-3">
                          <h4 className="font-medium text-gray-900 dark:text-white">
                            {category.name}
                          </h4>
                          <span className="text-sm text-gray-500 dark:text-gray-400">
                            ({category.criteria.length} criteria)
                          </span>
                        </div>
                        {category.description && (
                          <p className="text-sm text-gray-600 dark:text-gray-400 mt-1">
                            {category.description}
                          </p>
                        )}
                      </div>
                      <div className="flex items-center space-x-2">
                        <button
                          onClick={() => {
                            setSelectedCategory(category)
                            setShowEditCategoryModal(true)
                          }}
                          className="text-blue-600 hover:text-blue-900 dark:text-blue-400 dark:hover:text-blue-300"
                        >
                          <EyeIcon className="h-5 w-5" />
                        </button>
                        {canManageCategories() && (
                          <>
                            <button
                              onClick={() => {
                                setSelectedCategory(category)
                                setShowEditCategoryModal(true)
                              }}
                              className="text-green-600 hover:text-green-900 dark:text-green-400 dark:hover:text-green-300"
                            >
                              <PencilIcon className="h-5 w-5" />
                            </button>
                            <button
                              onClick={() => handleDeleteCategory(category.id)}
                              className="text-red-600 hover:text-red-900 dark:text-red-400 dark:hover:text-red-300"
                            >
                              <TrashIcon className="h-5 w-5" />
                            </button>
                          </>
                        )}
                      </div>
                    </div>
                    
                    {/* Criteria List */}
                    <div className="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700">
                      <div className="flex items-center justify-between mb-3">
                        <h5 className="font-medium text-gray-700 dark:text-gray-300">
                          Criteria
                        </h5>
                        {canManageCategories() && (
                          <button
                            onClick={() => {
                              setSelectedCategory(category)
                              setShowCreateCriterionModal(true)
                            }}
                            className="text-sm text-blue-600 hover:text-blue-900 dark:text-blue-400 dark:hover:text-blue-300"
                          >
                            <PlusIcon className="h-4 w-4 mr-1" />
                            Add Criterion
                          </button>
                        )}
                      </div>
                      {category.criteria.length > 0 ? (
                        <div className="space-y-2">
                          {category.criteria
                            .sort((a, b) => a.order - b.order)
                            .map((criterion: Criterion) => (
                            <div
                              key={criterion.id}
                              className="flex items-center justify-between p-3 bg-gray-50 dark:bg-gray-700 rounded-lg"
                            >
                              <div className="flex-1">
                                <div className="flex items-center space-x-3">
                                  <span className="text-sm font-medium text-gray-900 dark:text-white">
                                    {criterion.name}
                                  </span>
                                  <span className="text-xs text-gray-500 dark:text-gray-400">
                                    Max: {criterion.maxScore}
                                    {criterion.minScore && `, Min: ${criterion.minScore}`}
                                    {criterion.timeLimit && `, Time: ${criterion.timeLimit}s`}
                                  </span>
                                  {criterion.isRequired && (
                                    <span className="text-xs bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200 px-2 py-1 rounded">
                                      Required
                                    </span>
                                  )}
                                </div>
                                {criterion.description && (
                                  <p className="text-xs text-gray-600 dark:text-gray-400 mt-1">
                                    {criterion.description}
                                  </p>
                                )}
                              </div>
                              {canManageCategories() && (
                                <div className="flex items-center space-x-1">
                                  <button
                                    onClick={() => {
                                      setSelectedCriterion(criterion)
                                      setShowEditCriterionModal(true)
                                    }}
                                    className="text-green-600 hover:text-green-900 dark:text-green-400 dark:hover:text-green-300"
                                  >
                                    <PencilIcon className="h-4 w-4" />
                                  </button>
                                  <button
                                    onClick={() => handleDeleteCriterion(criterion.id)}
                                    className="text-red-600 hover:text-red-900 dark:text-red-400 dark:hover:text-red-300"
                                  >
                                    <TrashIcon className="h-4 w-4" />
                                  </button>
                                </div>
                              )}
                            </div>
                          ))}
                        </div>
                      ) : (
                        <div className="text-center py-4 text-gray-500 dark:text-gray-400">
                          <DocumentTextIcon className="h-8 w-8 mx-auto mb-2" />
                          <p className="text-sm">No criteria defined</p>
                        </div>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            ) : (
              <div className="text-center py-12">
                <DocumentTextIcon className="h-12 w-12 text-gray-400 mx-auto mb-4" />
                <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">
                  No Categories Found
                </h3>
                <p className="text-gray-600 dark:text-gray-400">
                  Select an event and contest to view categories.
                </p>
              </div>
            )}
          </div>
        </div>
      )}

      {/* Create Category Modal */}
      {showCreateCategoryModal && (
        <div className="modal">
          <div className="modal-overlay" onClick={() => setShowCreateCategoryModal(false)}></div>
          <div className="modal-content">
            <div className="flex items-center justify-between mb-6">
              <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                Create Category
              </h3>
              <button
                onClick={() => setShowCreateCategoryModal(false)}
                className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
              >
                <XMarkIcon className="h-6 w-6" />
              </button>
            </div>
            
            <form onSubmit={(e) => {
              e.preventDefault()
              const formData = new FormData(e.target as HTMLFormElement)
              handleCreateCategory({
                name: formData.get('name') as string,
                description: formData.get('description') as string,
                contestId: selectedContest
              })
            }}>
              <div className="space-y-4">
                <div>
                  <label className="label">Name</label>
                  <input
                    name="name"
                    type="text"
                    className="input"
                    required
                    placeholder="Category name"
                  />
                </div>
                <div>
                  <label className="label">Description</label>
                  <textarea
                    name="description"
                    rows={3}
                    className="input"
                    placeholder="Optional description"
                  />
                </div>
              </div>
              
              <div className="flex items-center justify-end space-x-3 mt-6">
                <button
                  type="button"
                  onClick={() => setShowCreateCategoryModal(false)}
                  className="btn-secondary"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  disabled={createCategoryMutation.isLoading}
                  className="btn-primary"
                >
                  {createCategoryMutation.isLoading ? 'Creating...' : 'Create Category'}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}

      {/* Edit Category Modal */}
      {showEditCategoryModal && selectedCategory && (
        <div className="modal">
          <div className="modal-overlay" onClick={() => setShowEditCategoryModal(false)}></div>
          <div className="modal-content">
            <div className="flex items-center justify-between mb-6">
              <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                Edit Category
              </h3>
              <button
                onClick={() => setShowEditCategoryModal(false)}
                className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
              >
                <XMarkIcon className="h-6 w-6" />
              </button>
            </div>
            
            <form onSubmit={(e) => {
              e.preventDefault()
              const formData = new FormData(e.target as HTMLFormElement)
              handleUpdateCategory(selectedCategory.id, {
                name: formData.get('name') as string,
                description: formData.get('description') as string
              })
            }}>
              <div className="space-y-4">
                <div>
                  <label className="label">Name</label>
                  <input
                    name="name"
                    type="text"
                    className="input"
                    defaultValue={selectedCategory.name}
                    required
                  />
                </div>
                <div>
                  <label className="label">Description</label>
                  <textarea
                    name="description"
                    rows={3}
                    className="input"
                    defaultValue={selectedCategory.description}
                  />
                </div>
              </div>
              
              <div className="flex items-center justify-end space-x-3 mt-6">
                <button
                  type="button"
                  onClick={() => setShowEditCategoryModal(false)}
                  className="btn-secondary"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  disabled={updateCategoryMutation.isLoading}
                  className="btn-primary"
                >
                  {updateCategoryMutation.isLoading ? 'Updating...' : 'Update Category'}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}

      {/* Create Criterion Modal */}
      {showCreateCriterionModal && selectedCategory && (
        <div className="modal">
          <div className="modal-overlay" onClick={() => setShowCreateCriterionModal(false)}></div>
          <div className="modal-content">
            <div className="flex items-center justify-between mb-6">
              <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                Create Criterion
              </h3>
              <button
                onClick={() => setShowCreateCriterionModal(false)}
                className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
              >
                <XMarkIcon className="h-6 w-6" />
              </button>
            </div>
            
            <form onSubmit={(e) => {
              e.preventDefault()
              const formData = new FormData(e.target as HTMLFormElement)
              handleCreateCriterion({
                name: formData.get('name') as string,
                description: formData.get('description') as string,
                maxScore: Number(formData.get('maxScore')),
                minScore: formData.get('minScore') ? Number(formData.get('minScore')) : undefined,
                timeLimit: formData.get('timeLimit') ? Number(formData.get('timeLimit')) : undefined,
                isRequired: formData.get('isRequired') === 'on',
                order: selectedCategory.criteria.length + 1,
                categoryId: selectedCategory.id
              })
            }}>
              <div className="space-y-4">
                <div>
                  <label className="label">Name</label>
                  <input
                    name="name"
                    type="text"
                    className="input"
                    required
                    placeholder="Criterion name"
                  />
                </div>
                <div>
                  <label className="label">Description</label>
                  <textarea
                    name="description"
                    rows={3}
                    className="input"
                    placeholder="Optional description"
                  />
                </div>
                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <label className="label">Max Score</label>
                    <input
                      name="maxScore"
                      type="number"
                      className="input"
                      required
                      min="1"
                      placeholder="100"
                    />
                  </div>
                  <div>
                    <label className="label">Min Score (Optional)</label>
                    <input
                      name="minScore"
                      type="number"
                      className="input"
                      min="0"
                      placeholder="0"
                    />
                  </div>
                </div>
                <div>
                  <label className="label">Time Limit (Optional)</label>
                  <input
                    name="timeLimit"
                    type="number"
                    className="input"
                    min="1"
                    placeholder="Seconds"
                  />
                </div>
                <div className="flex items-center">
                  <input
                    name="isRequired"
                    type="checkbox"
                    className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                  />
                  <label className="ml-2 text-sm text-gray-700 dark:text-gray-300">
                    Required criterion
                  </label>
                </div>
              </div>
              
              <div className="flex items-center justify-end space-x-3 mt-6">
                <button
                  type="button"
                  onClick={() => setShowCreateCriterionModal(false)}
                  className="btn-secondary"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  disabled={createCriterionMutation.isLoading}
                  className="btn-primary"
                >
                  {createCriterionMutation.isLoading ? 'Creating...' : 'Create Criterion'}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}

      {/* Edit Criterion Modal */}
      {showEditCriterionModal && selectedCriterion && (
        <div className="modal">
          <div className="modal-overlay" onClick={() => setShowEditCriterionModal(false)}></div>
          <div className="modal-content">
            <div className="flex items-center justify-between mb-6">
              <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                Edit Criterion
              </h3>
              <button
                onClick={() => setShowEditCriterionModal(false)}
                className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
              >
                <XMarkIcon className="h-6 w-6" />
              </button>
            </div>
            
            <form onSubmit={(e) => {
              e.preventDefault()
              const formData = new FormData(e.target as HTMLFormElement)
              handleUpdateCriterion(selectedCriterion.id, {
                name: formData.get('name') as string,
                description: formData.get('description') as string,
                maxScore: Number(formData.get('maxScore')),
                minScore: formData.get('minScore') ? Number(formData.get('minScore')) : undefined,
                timeLimit: formData.get('timeLimit') ? Number(formData.get('timeLimit')) : undefined,
                isRequired: formData.get('isRequired') === 'on'
              })
            }}>
              <div className="space-y-4">
                <div>
                  <label className="label">Name</label>
                  <input
                    name="name"
                    type="text"
                    className="input"
                    defaultValue={selectedCriterion.name}
                    required
                  />
                </div>
                <div>
                  <label className="label">Description</label>
                  <textarea
                    name="description"
                    rows={3}
                    className="input"
                    defaultValue={selectedCriterion.description}
                  />
                </div>
                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <label className="label">Max Score</label>
                    <input
                      name="maxScore"
                      type="number"
                      className="input"
                      defaultValue={selectedCriterion.maxScore}
                      required
                      min="1"
                    />
                  </div>
                  <div>
                    <label className="label">Min Score (Optional)</label>
                    <input
                      name="minScore"
                      type="number"
                      className="input"
                      defaultValue={selectedCriterion.minScore}
                      min="0"
                    />
                  </div>
                </div>
                <div>
                  <label className="label">Time Limit (Optional)</label>
                  <input
                    name="timeLimit"
                    type="number"
                    className="input"
                    defaultValue={selectedCriterion.timeLimit}
                    min="1"
                  />
                </div>
                <div className="flex items-center">
                  <input
                    name="isRequired"
                    type="checkbox"
                    className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                    defaultChecked={selectedCriterion.isRequired}
                  />
                  <label className="ml-2 text-sm text-gray-700 dark:text-gray-300">
                    Required criterion
                  </label>
                </div>
              </div>
              
              <div className="flex items-center justify-end space-x-3 mt-6">
                <button
                  type="button"
                  onClick={() => setShowEditCriterionModal(false)}
                  className="btn-secondary"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  disabled={updateCriterionMutation.isLoading}
                  className="btn-primary"
                >
                  {updateCriterionMutation.isLoading ? 'Updating...' : 'Update Criterion'}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}
    </div>
  )
}

export default CategoryEditor
EOF

    # Add EventTemplatePage
    cat > "$APP_DIR/frontend/src/pages/EventTemplatePage.tsx" << 'EOF'
import React, { useState } from 'react'
import { useQuery, useMutation, useQueryClient } from 'react-query'
import { useAuth } from '../contexts/AuthContext'
import { eventTemplatesAPI } from '../services/api'
import {
  PlusIcon,
  PencilIcon,
  TrashIcon,
  DocumentDuplicateIcon,
  DocumentTextIcon,
  CalendarIcon,
  ClockIcon,
  UserGroupIcon,
  MagnifyingGlassIcon,
  EyeIcon,
  XMarkIcon,
  CheckCircleIcon,
  ExclamationTriangleIcon,
  InformationCircleIcon,
  ArrowDownTrayIcon,
  ArrowUpTrayIcon
} from '@heroicons/react/24/outline'

interface EventTemplate {
  id: string
  name: string
  description?: string
  eventData: {
    name: string
    startDate: string
    endDate: string
    description?: string
    contests: Array<{
      name: string
      description?: string
      categories: Array<{
        name: string
        description?: string
        criteria: Array<{
          name: string
          description?: string
          maxScore: number
          minScore?: number
          timeLimit?: number
          isRequired: boolean
          order: number
        }>
      }>
    }>
  }
  isPublic: boolean
  createdBy: string
  createdByName: string
  createdAt: string
  updatedAt: string
}

interface CreateEventTemplateData {
  name: string
  description?: string
  eventData: any
  isPublic: boolean
}

const EventTemplatePage: React.FC = () => {
  const { user } = useAuth()
  const queryClient = useQueryClient()
  const [showCreateModal, setShowCreateModal] = useState<boolean>(false)
  const [showEditModal, setShowEditModal] = useState<boolean>(false)
  const [showCreateFromTemplateModal, setShowCreateFromTemplateModal] = useState<boolean>(false)
  const [selectedTemplate, setSelectedTemplate] = useState<EventTemplate | null>(null)
  const [searchTerm, setSearchTerm] = useState<string>('')
  const [filterPublic, setFilterPublic] = useState<boolean>(false)

  // Fetch templates
  const { data: templates, isLoading } = useQuery(
    ['eventTemplates', searchTerm, filterPublic],
    () => eventTemplatesAPI.getTemplates({
      search: searchTerm,
      isPublic: filterPublic
    }).then(res => res.data)
  )

  // Create template mutation
  const createTemplateMutation = useMutation(
    (data: CreateEventTemplateData) => eventTemplatesAPI.createTemplate(data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('eventTemplates')
        setShowCreateModal(false)
      }
    }
  )

  // Update template mutation
  const updateTemplateMutation = useMutation(
    ({ id, data }: { id: string; data: Partial<EventTemplate> }) => 
      eventTemplatesAPI.updateTemplate(id, data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('eventTemplates')
        setShowEditModal(false)
        setSelectedTemplate(null)
      }
    }
  )

  // Delete template mutation
  const deleteTemplateMutation = useMutation(
    (id: string) => eventTemplatesAPI.deleteTemplate(id),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('eventTemplates')
      }
    }
  )

  // Create event from template mutation
  const createEventFromTemplateMutation = useMutation(
    ({ templateId, eventData }: { templateId: string; eventData: any }) => 
      eventTemplatesAPI.createEventFromTemplate(templateId, eventData),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('events')
        setShowCreateFromTemplateModal(false)
        setSelectedTemplate(null)
      }
    }
  )

  const canManageTemplates = () => {
    return user?.role === 'ADMIN' || user?.role === 'BOARD' || user?.role === 'ORGANIZER'
  }

  const handleCreateTemplate = (data: CreateEventTemplateData) => {
    createTemplateMutation.mutate(data)
  }

  const handleUpdateTemplate = (id: string, data: Partial<EventTemplate>) => {
    updateTemplateMutation.mutate({ id, data })
  }

  const handleDeleteTemplate = (id: string) => {
    if (window.confirm('Are you sure you want to delete this template?')) {
      deleteTemplateMutation.mutate(id)
    }
  }

  const handleCreateEventFromTemplate = (templateId: string, eventData: any) => {
    createEventFromTemplateMutation.mutate({ templateId, eventData })
  }

  const filteredTemplates = templates?.filter((template: EventTemplate) => {
    const matchesSearch = template.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                         template.description?.toLowerCase().includes(searchTerm.toLowerCase()) ||
                         template.eventData.name.toLowerCase().includes(searchTerm.toLowerCase())
    const matchesPublic = !filterPublic || template.isPublic
    return matchesSearch && matchesPublic
  }) || []

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">
            Event Templates
          </h1>
          <p className="text-gray-600 dark:text-gray-400">
            Manage event templates for quick event creation
          </p>
        </div>
        {canManageTemplates() && (
          <button
            onClick={() => setShowCreateModal(true)}
            className="btn-primary"
          >
            <PlusIcon className="h-4 w-4 mr-2" />
            New Template
          </button>
        )}
      </div>

      {/* Filters */}
      <div className="card">
        <div className="card-header">
          <h3 className="card-title">Filter Templates</h3>
        </div>
        <div className="card-content">
          <div className="flex items-center space-x-4">
            <div className="flex-1">
              <div className="relative">
                <MagnifyingGlassIcon className="h-5 w-5 absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" />
                <input
                  type="text"
                  placeholder="Search templates..."
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                  className="input pl-10"
                />
              </div>
            </div>
            <div className="flex items-center">
              <input
                type="checkbox"
                id="filterPublic"
                checked={filterPublic}
                onChange={(e) => setFilterPublic(e.target.checked)}
                className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
              />
              <label htmlFor="filterPublic" className="ml-2 text-sm text-gray-700 dark:text-gray-300">
                Public templates only
              </label>
            </div>
          </div>
        </div>
      </div>

      {/* Templates List */}
      <div className="card">
        <div className="card-header">
          <div className="flex items-center justify-between">
            <div>
              <h3 className="card-title">Templates</h3>
              <p className="card-description">
                {filteredTemplates.length} templates found
              </p>
            </div>
          </div>
        </div>
        <div className="card-content">
          {isLoading ? (
            <div className="flex items-center justify-center py-8">
              <div className="loading-spinner h-8 w-8"></div>
            </div>
          ) : filteredTemplates.length > 0 ? (
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
              {filteredTemplates.map((template: EventTemplate) => (
                <div
                  key={template.id}
                  className="border rounded-lg p-4 bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700 hover:shadow-md transition-shadow"
                >
                  <div className="flex items-start justify-between mb-3">
                    <div className="flex-1">
                      <h4 className="font-medium text-gray-900 dark:text-white mb-1">
                        {template.name}
                      </h4>
                      <p className="text-sm text-gray-600 dark:text-gray-400">
                        {template.eventData.name}
                      </p>
                    </div>
                    <div className="flex items-center space-x-1">
                      {template.isPublic ? (
                        <span className="text-xs bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200 px-2 py-1 rounded">
                          Public
                        </span>
                      ) : (
                        <span className="text-xs bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200 px-2 py-1 rounded">
                          Private
                        </span>
                      )}
                    </div>
                  </div>
                  
                  {template.description && (
                    <p className="text-sm text-gray-600 dark:text-gray-400 mb-3">
                      {template.description}
                    </p>
                  )}
                  
                  <div className="space-y-2 mb-4">
                    <div className="flex items-center text-sm text-gray-500 dark:text-gray-400">
                      <CalendarIcon className="h-4 w-4 mr-2" />
                      <span>
                        {new Date(template.eventData.startDate).toLocaleDateString()} - 
                        {new Date(template.eventData.endDate).toLocaleDateString()}
                      </span>
                    </div>
                    <div className="flex items-center text-sm text-gray-500 dark:text-gray-400">
                      <UserGroupIcon className="h-4 w-4 mr-2" />
                      <span>{template.eventData.contests.length} contests</span>
                    </div>
                    <div className="flex items-center text-sm text-gray-500 dark:text-gray-400">
                      <DocumentTextIcon className="h-4 w-4 mr-2" />
                      <span>
                        {template.eventData.contests.reduce((total: number, contest: any) => 
                          total + contest.categories.length, 0
                        )} categories
                      </span>
                    </div>
                  </div>
                  
                  <div className="flex items-center justify-between pt-3 border-t border-gray-200 dark:border-gray-700">
                    <div className="text-xs text-gray-500 dark:text-gray-400">
                      Created by {template.createdByName}
                    </div>
                    <div className="flex items-center space-x-2">
                      <button
                        onClick={() => {
                          setSelectedTemplate(template)
                          setShowCreateFromTemplateModal(true)
                        }}
                        className="text-blue-600 hover:text-blue-900 dark:text-blue-400 dark:hover:text-blue-300"
                        title="Create Event from Template"
                      >
                        <DocumentDuplicateIcon className="h-4 w-4" />
                      </button>
                      <button
                        onClick={() => {
                          setSelectedTemplate(template)
                          setShowEditModal(true)
                        }}
                        className="text-green-600 hover:text-green-900 dark:text-green-400 dark:hover:text-green-300"
                        title="View Details"
                      >
                        <EyeIcon className="h-4 w-4" />
                      </button>
                      {canManageTemplates() && (
                        <>
                          <button
                            onClick={() => {
                              setSelectedTemplate(template)
                              setShowEditModal(true)
                            }}
                            className="text-yellow-600 hover:text-yellow-900 dark:text-yellow-400 dark:hover:text-yellow-300"
                            title="Edit Template"
                          >
                            <PencilIcon className="h-4 w-4" />
                          </button>
                          <button
                            onClick={() => handleDeleteTemplate(template.id)}
                            className="text-red-600 hover:text-red-900 dark:text-red-400 dark:hover:text-red-300"
                            title="Delete Template"
                          >
                            <TrashIcon className="h-4 w-4" />
                          </button>
                        </>
                      )}
                    </div>
                  </div>
                </div>
              ))}
            </div>
          ) : (
            <div className="text-center py-12">
              <DocumentTextIcon className="h-12 w-12 text-gray-400 mx-auto mb-4" />
              <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">
                No Templates Found
              </h3>
              <p className="text-gray-600 dark:text-gray-400">
                {canManageTemplates() 
                  ? 'Create your first event template to get started.'
                  : 'No templates are available.'}
              </p>
            </div>
          )}
        </div>
      </div>

      {/* Create Template Modal */}
      {showCreateModal && (
        <div className="modal">
          <div className="modal-overlay" onClick={() => setShowCreateModal(false)}></div>
          <div className="modal-content max-w-4xl">
            <div className="flex items-center justify-between mb-6">
              <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                Create Event Template
              </h3>
              <button
                onClick={() => setShowCreateModal(false)}
                className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
              >
                <XMarkIcon className="h-6 w-6" />
              </button>
            </div>
            
            <form onSubmit={(e) => {
              e.preventDefault()
              const formData = new FormData(e.target as HTMLFormElement)
              handleCreateTemplate({
                name: formData.get('name') as string,
                description: formData.get('description') as string,
                eventData: JSON.parse(formData.get('eventData') as string),
                isPublic: formData.get('isPublic') === 'on'
              })
            }}>
              <div className="space-y-4">
                <div>
                  <label className="label">Template Name</label>
                  <input
                    name="name"
                    type="text"
                    className="input"
                    required
                    placeholder="Template name"
                  />
                </div>
                <div>
                  <label className="label">Description</label>
                  <textarea
                    name="description"
                    rows={3}
                    className="input"
                    placeholder="Optional description"
                  />
                </div>
                <div>
                  <label className="label">Event Data (JSON)</label>
                  <textarea
                    name="eventData"
                    rows={10}
                    className="input font-mono text-sm"
                    required
                    placeholder="Paste event data JSON here..."
                  />
                </div>
                <div className="flex items-center">
                  <input
                    name="isPublic"
                    type="checkbox"
                    className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                  />
                  <label className="ml-2 text-sm text-gray-700 dark:text-gray-300">
                    Make this template public
                  </label>
                </div>
              </div>
              
              <div className="flex items-center justify-end space-x-3 mt-6">
                <button
                  type="button"
                  onClick={() => setShowCreateModal(false)}
                  className="btn-secondary"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  disabled={createTemplateMutation.isLoading}
                  className="btn-primary"
                >
                  {createTemplateMutation.isLoading ? 'Creating...' : 'Create Template'}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}

      {/* Edit Template Modal */}
      {showEditModal && selectedTemplate && (
        <div className="modal">
          <div className="modal-overlay" onClick={() => setShowEditModal(false)}></div>
          <div className="modal-content max-w-4xl">
            <div className="flex items-center justify-between mb-6">
              <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                Template Details
              </h3>
              <button
                onClick={() => setShowEditModal(false)}
                className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
              >
                <XMarkIcon className="h-6 w-6" />
              </button>
            </div>
            
            <div className="space-y-6">
              {/* Template Info */}
              <div className="bg-gray-50 dark:bg-gray-800 rounded-lg p-4">
                <h4 className="font-semibold text-gray-900 dark:text-white mb-2">
                  {selectedTemplate.name}
                </h4>
                {selectedTemplate.description && (
                  <p className="text-gray-600 dark:text-gray-400 mb-3">
                    {selectedTemplate.description}
                  </p>
                )}
                <div className="grid grid-cols-2 gap-4 text-sm">
                  <div>
                    <span className="text-gray-500 dark:text-gray-400">Event:</span>
                    <div className="font-medium">{selectedTemplate.eventData.name}</div>
                  </div>
                  <div>
                    <span className="text-gray-500 dark:text-gray-400">Visibility:</span>
                    <div className="font-medium">
                      {selectedTemplate.isPublic ? 'Public' : 'Private'}
                    </div>
                  </div>
                  <div>
                    <span className="text-gray-500 dark:text-gray-400">Created:</span>
                    <div className="font-medium">
                      {new Date(selectedTemplate.createdAt).toLocaleDateString()}
                    </div>
                  </div>
                  <div>
                    <span className="text-gray-500 dark:text-gray-400">Created by:</span>
                    <div className="font-medium">{selectedTemplate.createdByName}</div>
                  </div>
                </div>
              </div>

              {/* Event Details */}
              <div className="bg-gray-50 dark:bg-gray-800 rounded-lg p-4">
                <h5 className="font-semibold text-gray-900 dark:text-white mb-3">
                  Event Details
                </h5>
                <div className="space-y-3">
                  <div>
                    <span className="text-sm text-gray-500 dark:text-gray-400">Name:</span>
                    <div className="font-medium">{selectedTemplate.eventData.name}</div>
                  </div>
                  <div>
                    <span className="text-sm text-gray-500 dark:text-gray-400">Dates:</span>
                    <div className="font-medium">
                      {new Date(selectedTemplate.eventData.startDate).toLocaleDateString()} - 
                      {new Date(selectedTemplate.eventData.endDate).toLocaleDateString()}
                    </div>
                  </div>
                  {selectedTemplate.eventData.description && (
                    <div>
                      <span className="text-sm text-gray-500 dark:text-gray-400">Description:</span>
                      <div className="font-medium">{selectedTemplate.eventData.description}</div>
                    </div>
                  )}
                </div>
              </div>

              {/* Contests */}
              <div className="bg-gray-50 dark:bg-gray-800 rounded-lg p-4">
                <h5 className="font-semibold text-gray-900 dark:text-white mb-3">
                  Contests ({selectedTemplate.eventData.contests.length})
                </h5>
                <div className="space-y-3">
                  {selectedTemplate.eventData.contests.map((contest: any, index: number) => (
                    <div key={index} className="border-l-4 border-blue-500 pl-3">
                      <div className="font-medium">{contest.name}</div>
                      {contest.description && (
                        <div className="text-sm text-gray-600 dark:text-gray-400">
                          {contest.description}
                        </div>
                      )}
                      <div className="text-sm text-gray-500 dark:text-gray-400 mt-1">
                        {contest.categories.length} categories
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Create Event from Template Modal */}
      {showCreateFromTemplateModal && selectedTemplate && (
        <div className="modal">
          <div className="modal-overlay" onClick={() => setShowCreateFromTemplateModal(false)}></div>
          <div className="modal-content">
            <div className="flex items-center justify-between mb-6">
              <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                Create Event from Template
              </h3>
              <button
                onClick={() => setShowCreateFromTemplateModal(false)}
                className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
              >
                <XMarkIcon className="h-6 w-6" />
              </button>
            </div>
            
            <form onSubmit={(e) => {
              e.preventDefault()
              const formData = new FormData(e.target as HTMLFormElement)
              handleCreateEventFromTemplate(selectedTemplate.id, {
                name: formData.get('name') as string,
                startDate: formData.get('startDate') as string,
                endDate: formData.get('endDate') as string,
                description: formData.get('description') as string
              })
            }}>
              <div className="space-y-4">
                <div>
                  <label className="label">Event Name</label>
                  <input
                    name="name"
                    type="text"
                    className="input"
                    defaultValue={selectedTemplate.eventData.name}
                    required
                  />
                </div>
                <div className="grid grid-cols-2 gap-4">
                  <div>
                    <label className="label">Start Date</label>
                    <input
                      name="startDate"
                      type="date"
                      className="input"
                      defaultValue={selectedTemplate.eventData.startDate.split('T')[0]}
                      required
                    />
                  </div>
                  <div>
                    <label className="label">End Date</label>
                    <input
                      name="endDate"
                      type="date"
                      className="input"
                      defaultValue={selectedTemplate.eventData.endDate.split('T')[0]}
                      required
                    />
                  </div>
                </div>
                <div>
                  <label className="label">Description</label>
                  <textarea
                    name="description"
                    rows={3}
                    className="input"
                    defaultValue={selectedTemplate.eventData.description}
                  />
                </div>
              </div>
              
              <div className="flex items-center justify-end space-x-3 mt-6">
                <button
                  type="button"
                  onClick={() => setShowCreateFromTemplateModal(false)}
                  className="btn-secondary"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  disabled={createEventFromTemplateMutation.isLoading}
                  className="btn-primary"
                >
                  {createEventFromTemplateMutation.isLoading ? 'Creating...' : 'Create Event'}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}
    </div>
  )
}

export default EventTemplatePage
EOF

    # Add PasswordStrengthMeter component
    cat > "$APP_DIR/frontend/src/components/PasswordStrengthMeter.tsx" << 'EOF'
import React, { useState, useEffect } from 'react'
import { useQuery } from 'react-query'
import {
  CheckCircleIcon,
  XCircleIcon,
  ExclamationTriangleIcon,
  EyeIcon,
  EyeSlashIcon,
  LockClosedIcon,
  ShieldCheckIcon,
  InformationCircleIcon
} from '@heroicons/react/24/outline'

interface PasswordPolicy {
  minLength: number
  requireUppercase: boolean
  requireLowercase: boolean
  requireNumbers: boolean
  requireSpecialChars: boolean
  maxLength?: number
  preventCommonPasswords: boolean
  preventUserInfo: boolean
}

interface PasswordStrengthMeterProps {
  password: string
  onPasswordChange: (password: string) => void
  showPolicy?: boolean
  className?: string
  disabled?: boolean
  placeholder?: string
  name?: string
  id?: string
  policy?: PasswordPolicy
}

const PasswordStrengthMeter: React.FC<PasswordStrengthMeterProps> = ({
  password,
  onPasswordChange,
  showPolicy = true,
  className = '',
  disabled = false,
  placeholder = 'Enter password',
  name = 'password',
  id = 'password',
  policy
}) => {
  const [showPassword, setShowPassword] = useState<boolean>(false)
  const [passwordPolicy, setPasswordPolicy] = useState<PasswordPolicy>(policy || {
    minLength: 8,
    requireUppercase: true,
    requireLowercase: true,
    requireNumbers: true,
    requireSpecialChars: true,
    maxLength: 128,
    preventCommonPasswords: true,
    preventUserInfo: true
  })

  // Fetch password policy from API
  const { data: apiPasswordPolicy } = useQuery('passwordPolicy', () => 
    fetch('/api/settings/password-policy').then(res => res.json()).catch(() => null)
  )

  // Use API policy if available, otherwise use prop or default
  const currentPolicy = apiPasswordPolicy || policy || passwordPolicy

  useEffect(() => {
    if (apiPasswordPolicy) {
      setPasswordPolicy(apiPasswordPolicy)
    }
  }, [apiPasswordPolicy])

  const checkPasswordStrength = (pwd: string) => {
    const checks = {
      length: pwd.length >= currentPolicy.minLength && (!currentPolicy.maxLength || pwd.length <= currentPolicy.maxLength),
      uppercase: !currentPolicy.requireUppercase || /[A-Z]/.test(pwd),
      lowercase: !currentPolicy.requireLowercase || /[a-z]/.test(pwd),
      numbers: !currentPolicy.requireNumbers || /\d/.test(pwd),
      specialChars: !currentPolicy.requireSpecialChars || /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(pwd),
      notCommon: !currentPolicy.preventCommonPasswords || !isCommonPassword(pwd),
      notUserInfo: !currentPolicy.preventUserInfo || !containsUserInfo(pwd)
    }

    const passedChecks = Object.values(checks).filter(Boolean).length
    const totalChecks = Object.keys(checks).length

    return {
      checks,
      score: Math.round((passedChecks / totalChecks) * 100),
      strength: getStrengthLevel(passedChecks, totalChecks)
    }
  }

  const isCommonPassword = (pwd: string) => {
    const commonPasswords = [
      'password', '123456', '123456789', 'qwerty', 'abc123', 'password123',
      'admin', 'letmein', 'welcome', 'monkey', '1234567890', 'dragon',
      'master', 'hello', 'freedom', 'whatever', 'qazwsx', 'trustno1'
    ]
    return commonPasswords.includes(pwd.toLowerCase())
  }

  const containsUserInfo = (pwd: string) => {
    // This would typically check against user's name, email, etc.
    // For now, we'll just check for common patterns
    return false
  }

  const getStrengthLevel = (passed: number, total: number) => {
    const percentage = (passed / total) * 100
    if (percentage < 40) return 'weak'
    if (percentage < 70) return 'medium'
    if (percentage < 90) return 'strong'
    return 'very-strong'
  }

  const getStrengthColor = (strength: string) => {
    switch (strength) {
      case 'weak': return 'text-red-600 dark:text-red-400'
      case 'medium': return 'text-yellow-600 dark:text-yellow-400'
      case 'strong': return 'text-blue-600 dark:text-blue-400'
      case 'very-strong': return 'text-green-600 dark:text-green-400'
      default: return 'text-gray-600 dark:text-gray-400'
    }
  }

  const getStrengthBgColor = (strength: string) => {
    switch (strength) {
      case 'weak': return 'bg-red-500'
      case 'medium': return 'bg-yellow-500'
      case 'strong': return 'bg-blue-500'
      case 'very-strong': return 'bg-green-500'
      default: return 'bg-gray-500'
    }
  }

  const strength = checkPasswordStrength(password)

  return (
    <div className={`space-y-3 ${className}`}>
      {/* Password Input */}
      <div className="relative">
        <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
          <LockClosedIcon className="h-5 w-5 text-gray-400" />
        </div>
        <input
          type={showPassword ? 'text' : 'password'}
          id={id}
          name={name}
          value={password}
          onChange={(e) => onPasswordChange(e.target.value)}
          className={`input pl-10 pr-10 ${disabled ? 'opacity-50 cursor-not-allowed' : ''}`}
          placeholder={placeholder}
          disabled={disabled}
        />
        <button
          type="button"
          className="absolute inset-y-0 right-0 pr-3 flex items-center"
          onClick={() => setShowPassword(!showPassword)}
          disabled={disabled}
        >
          {showPassword ? (
            <EyeSlashIcon className="h-5 w-5 text-gray-400 hover:text-gray-600" />
          ) : (
            <EyeIcon className="h-5 w-5 text-gray-400 hover:text-gray-600" />
          )}
        </button>
      </div>

      {/* Strength Meter */}
      {password && (
        <div className="space-y-2">
          <div className="flex items-center justify-between">
            <span className="text-sm font-medium text-gray-700 dark:text-gray-300">
              Password Strength
            </span>
            <span className={`text-sm font-medium ${getStrengthColor(strength.strength)}`}>
              {strength.strength.replace('-', ' ').replace(/\b\w/g, l => l.toUpperCase())}
            </span>
          </div>
          <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2">
            <div
              className={`h-2 rounded-full transition-all duration-300 ${getStrengthBgColor(strength.strength)}`}
              style={{ width: `${strength.score}%` }}
            />
          </div>
        </div>
      )}

      {/* Policy Requirements */}
      {showPolicy && password && (
        <div className="space-y-2">
          <div className="flex items-center space-x-2">
            <ShieldCheckIcon className="h-4 w-4 text-gray-500" />
            <span className="text-sm font-medium text-gray-700 dark:text-gray-300">
              Password Requirements
            </span>
          </div>
          <div className="space-y-1">
            <div className="flex items-center space-x-2">
              {strength.checks.length ? (
                <CheckCircleIcon className="h-4 w-4 text-green-500" />
              ) : (
                <XCircleIcon className="h-4 w-4 text-red-500" />
              )}
              <span className={`text-sm ${strength.checks.length ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}`}>
                At least {policy.minLength} characters
                {policy.maxLength && ` (max ${policy.maxLength})`}
              </span>
            </div>
            
            {policy.requireUppercase && (
              <div className="flex items-center space-x-2">
                {strength.checks.uppercase ? (
                  <CheckCircleIcon className="h-4 w-4 text-green-500" />
                ) : (
                  <XCircleIcon className="h-4 w-4 text-red-500" />
                )}
                <span className={`text-sm ${strength.checks.uppercase ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}`}>
                  Contains uppercase letter
                </span>
              </div>
            )}
            
            {policy.requireLowercase && (
              <div className="flex items-center space-x-2">
                {strength.checks.lowercase ? (
                  <CheckCircleIcon className="h-4 w-4 text-green-500" />
                ) : (
                  <XCircleIcon className="h-4 w-4 text-red-500" />
                )}
                <span className={`text-sm ${strength.checks.lowercase ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}`}>
                  Contains lowercase letter
                </span>
              </div>
            )}
            
            {policy.requireNumbers && (
              <div className="flex items-center space-x-2">
                {strength.checks.numbers ? (
                  <CheckCircleIcon className="h-4 w-4 text-green-500" />
                ) : (
                  <XCircleIcon className="h-4 w-4 text-red-500" />
                )}
                <span className={`text-sm ${strength.checks.numbers ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}`}>
                  Contains number
                </span>
              </div>
            )}
            
            {policy.requireSpecialChars && (
              <div className="flex items-center space-x-2">
                {strength.checks.specialChars ? (
                  <CheckCircleIcon className="h-4 w-4 text-green-500" />
                ) : (
                  <XCircleIcon className="h-4 w-4 text-red-500" />
                )}
                <span className={`text-sm ${strength.checks.specialChars ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'}`}>
                  Contains special character
                </span>
              </div>
            )}
            
            {policy.preventCommonPasswords && (
              <div className="flex items-center space-x-2">
                {strength.checks.notCommon ? (
                  <CheckCircleIcon className="h-4 w-4 text-green-500" />
                ) : (
                  <ExclamationTriangleIcon className="h-4 w-4 text-yellow-500" />
                )}
                <span className={`text-sm ${strength.checks.notCommon ? 'text-green-600 dark:text-green-400' : 'text-yellow-600 dark:text-yellow-400'}`}>
                  Not a common password
                </span>
              </div>
            )}
            
            {policy.preventUserInfo && (
              <div className="flex items-center space-x-2">
                {strength.checks.notUserInfo ? (
                  <CheckCircleIcon className="h-4 w-4 text-green-500" />
                ) : (
                  <ExclamationTriangleIcon className="h-4 w-4 text-yellow-500" />
                )}
                <span className={`text-sm ${strength.checks.notUserInfo ? 'text-green-600 dark:text-green-400' : 'text-yellow-600 dark:text-yellow-400'}`}>
                  Doesn't contain personal information
                </span>
              </div>
            )}
          </div>
        </div>
      )}

      {/* Security Tips */}
      {password && strength.score < 70 && (
        <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-3">
          <div className="flex items-start space-x-2">
            <InformationCircleIcon className="h-5 w-5 text-blue-600 dark:text-blue-400 mt-0.5" />
            <div className="text-sm text-blue-700 dark:text-blue-300">
              <p className="font-medium mb-1">Security Tips:</p>
              <ul className="list-disc list-inside space-y-1">
                <li>Use a combination of letters, numbers, and symbols</li>
                <li>Avoid using personal information like names or birthdays</li>
                <li>Consider using a passphrase instead of a single word</li>
                <li>Don't reuse passwords across different accounts</li>
              </ul>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}

export default PasswordStrengthMeter
EOF

    # Update UsersPage with enhanced user management
    cat > "$APP_DIR/frontend/src/pages/UsersPage.tsx" << 'EOF'
import React, { useState } from 'react'
import { useQuery, useMutation, useQueryClient } from 'react-query'
import { useAuth } from '../contexts/AuthContext'
import { usersAPI } from '../services/api'
import PasswordStrengthMeter from '../components/PasswordStrengthMeter'
import {
  PlusIcon,
  PencilIcon,
  TrashIcon,
  EyeIcon,
  XMarkIcon,
  CheckCircleIcon,
  XCircleIcon,
  ClockIcon,
  ExclamationTriangleIcon,
  MagnifyingGlassIcon,
  FunnelIcon,
  UserGroupIcon,
  UserIcon,
  CalendarIcon,
  ShieldCheckIcon,
  LockClosedIcon,
  EnvelopeIcon,
  PhoneIcon,
  MapPinIcon,
  IdentificationIcon,
  AcademicCapIcon,
  BriefcaseIcon,
  ClipboardDocumentListIcon,
  DocumentTextIcon,
  Cog6ToothIcon,
  ArrowDownTrayIcon,
  ArrowUpTrayIcon,
  CheckIcon,
  XMarkIcon as XIcon
} from '@heroicons/react/24/outline'

interface User {
  id: string
  name: string
  email: string
  role: 'ADMIN' | 'BOARD' | 'ORGANIZER' | 'JUDGE' | 'TALLY_MASTER' | 'AUDITOR' | 'EMCEE' | 'CONTESTANT'
  isActive: boolean
  lastLogin?: string
  createdAt: string
  updatedAt: string
  // Role-specific fields
  phone?: string
  address?: string
  emergencyContact?: string
  emergencyPhone?: string
  bio?: string
  experience?: string
  specialties?: string[]
  certifications?: string[]
  preferredName?: string
  pronouns?: string
  // Judge-specific fields
  judgeNumber?: string
  judgeLevel?: string
  judgeExperience?: number
  // Contestant-specific fields
  contestantNumber?: string
  age?: number
  parentGuardian?: string
  parentPhone?: string
  school?: string
  grade?: string
}

interface CreateUserData {
  name: string
  email: string
  password: string
  role: string
  phone?: string
  address?: string
  emergencyContact?: string
  emergencyPhone?: string
  bio?: string
  experience?: string
  specialties?: string[]
  certifications?: string[]
  preferredName?: string
  pronouns?: string
  judgeNumber?: string
  judgeLevel?: string
  judgeExperience?: number
  contestantNumber?: string
  age?: number
  parentGuardian?: string
  parentPhone?: string
  school?: string
  grade?: string
}

const UsersPage: React.FC = () => {
  const { user } = useAuth()
  const queryClient = useQueryClient()
  const [showCreateModal, setShowCreateModal] = useState<boolean>(false)
  const [showEditModal, setShowEditModal] = useState<boolean>(false)
  const [showBulkModal, setShowBulkModal] = useState<boolean>(false)
  const [selectedUser, setSelectedUser] = useState<User | null>(null)
  const [searchTerm, setSearchTerm] = useState<string>('')
  const [roleFilter, setRoleFilter] = useState<string>('')
  const [statusFilter, setStatusFilter] = useState<string>('')
  const [selectedUsers, setSelectedUsers] = useState<string[]>([])
  const [password, setPassword] = useState<string>('')

  // Fetch users
  const { data: users, isLoading } = useQuery(
    ['users', searchTerm, roleFilter, statusFilter],
    () => usersAPI.getUsers({
      search: searchTerm,
      role: roleFilter,
      isActive: statusFilter === 'active' ? true : statusFilter === 'inactive' ? false : undefined
    }).then(res => res.data)
  )

  // Create user mutation
  const createUserMutation = useMutation(
    (data: CreateUserData) => usersAPI.createUser(data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('users')
        setShowCreateModal(false)
        setPassword('')
      }
    }
  )

  // Update user mutation
  const updateUserMutation = useMutation(
    ({ id, data }: { id: string; data: Partial<User> }) => 
      usersAPI.updateUser(id, data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('users')
        setShowEditModal(false)
        setSelectedUser(null)
      }
    }
  )

  // Delete user mutation
  const deleteUserMutation = useMutation(
    (id: string) => usersAPI.deleteUser(id),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('users')
      }
    }
  )

  // Bulk delete mutation
  const bulkDeleteMutation = useMutation(
    (ids: string[]) => usersAPI.bulkDeleteUsers(ids),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('users')
        setSelectedUsers([])
        setShowBulkModal(false)
      }
    }
  )

  const canManageUsers = () => {
    return user?.role === 'ADMIN' || user?.role === 'BOARD' || user?.role === 'ORGANIZER'
  }

  const handleCreateUser = (data: CreateUserData) => {
    createUserMutation.mutate({ ...data, password })
  }

  const handleUpdateUser = (id: string, data: Partial<User>) => {
    updateUserMutation.mutate({ id, data })
  }

  const handleDeleteUser = (id: string) => {
    if (window.confirm('Are you sure you want to delete this user?')) {
      deleteUserMutation.mutate(id)
    }
  }

  const handleBulkDelete = () => {
    if (window.confirm(`Are you sure you want to delete ${selectedUsers.length} users?`)) {
      bulkDeleteMutation.mutate(selectedUsers)
    }
  }

  const handleSelectUser = (userId: string) => {
    setSelectedUsers(prev => 
      prev.includes(userId) 
        ? prev.filter(id => id !== userId)
        : [...prev, userId]
    )
  }

  const handleSelectAll = () => {
    if (selectedUsers.length === filteredUsers.length) {
      setSelectedUsers([])
    } else {
      setSelectedUsers(filteredUsers.map((user: User) => user.id))
    }
  }

  const getRoleIcon = (role: string) => {
    switch (role) {
      case 'ADMIN': return <Cog6ToothIcon className="h-5 w-5 text-red-500" />
      case 'BOARD': return <ShieldCheckIcon className="h-5 w-5 text-blue-500" />
      case 'ORGANIZER': return <BriefcaseIcon className="h-5 w-5 text-green-500" />
      case 'JUDGE': return <AcademicCapIcon className="h-5 w-5 text-purple-500" />
      case 'TALLY_MASTER': return <ClipboardDocumentListIcon className="h-5 w-5 text-orange-500" />
      case 'AUDITOR': return <DocumentTextIcon className="h-5 w-5 text-indigo-500" />
      case 'EMCEE': return <UserIcon className="h-5 w-5 text-pink-500" />
      case 'CONTESTANT': return <UserGroupIcon className="h-5 w-5 text-teal-500" />
      default: return <UserIcon className="h-5 w-5 text-gray-500" />
    }
  }

  const getRoleColor = (role: string) => {
    switch (role) {
      case 'ADMIN': return 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200'
      case 'BOARD': return 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200'
      case 'ORGANIZER': return 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
      case 'JUDGE': return 'bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-200'
      case 'TALLY_MASTER': return 'bg-orange-100 text-orange-800 dark:bg-orange-900 dark:text-orange-200'
      case 'AUDITOR': return 'bg-indigo-100 text-indigo-800 dark:bg-indigo-900 dark:text-indigo-200'
      case 'EMCEE': return 'bg-pink-100 text-pink-800 dark:bg-pink-900 dark:text-pink-200'
      case 'CONTESTANT': return 'bg-teal-100 text-teal-800 dark:bg-teal-900 dark:text-teal-200'
      default: return 'bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200'
    }
  }

  const filteredUsers = users?.filter((user: User) => {
    const matchesSearch = user.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                         user.email.toLowerCase().includes(searchTerm.toLowerCase()) ||
                         user.preferredName?.toLowerCase().includes(searchTerm.toLowerCase())
    const matchesRole = !roleFilter || user.role === roleFilter
    const matchesStatus = !statusFilter || 
                         (statusFilter === 'active' && user.isActive) ||
                         (statusFilter === 'inactive' && !user.isActive)
    return matchesSearch && matchesRole && matchesStatus
  }) || []

  const getRoleSpecificFields = (role: string) => {
    switch (role) {
      case 'JUDGE':
        return (
          <>
            <div>
              <label className="label">Judge Number</label>
              <input name="judgeNumber" type="text" className="input" placeholder="J001" />
            </div>
            <div>
              <label className="label">Judge Level</label>
              <select name="judgeLevel" className="input">
                <option value="">Select Level</option>
                <option value="NOVICE">Novice</option>
                <option value="INTERMEDIATE">Intermediate</option>
                <option value="ADVANCED">Advanced</option>
                <option value="EXPERT">Expert</option>
              </select>
            </div>
            <div>
              <label className="label">Years of Experience</label>
              <input name="judgeExperience" type="number" className="input" min="0" />
            </div>
          </>
        )
      case 'CONTESTANT':
        return (
          <>
            <div>
              <label className="label">Contestant Number</label>
              <input name="contestantNumber" type="text" className="input" placeholder="C001" />
            </div>
            <div>
              <label className="label">Age</label>
              <input name="age" type="number" className="input" min="1" max="100" />
            </div>
            <div>
              <label className="label">Parent/Guardian</label>
              <input name="parentGuardian" type="text" className="input" />
            </div>
            <div>
              <label className="label">Parent Phone</label>
              <input name="parentPhone" type="tel" className="input" />
            </div>
            <div>
              <label className="label">School</label>
              <input name="school" type="text" className="input" />
            </div>
            <div>
              <label className="label">Grade</label>
              <input name="grade" type="text" className="input" />
            </div>
          </>
        )
      default:
        return null
    }
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">
            User Management
          </h1>
          <p className="text-gray-600 dark:text-gray-400">
            Manage users, roles, and permissions
          </p>
        </div>
        <div className="flex items-center space-x-3">
          {canManageUsers() && selectedUsers.length > 0 && (
            <button
              onClick={() => setShowBulkModal(true)}
              className="btn-secondary"
            >
              <TrashIcon className="h-4 w-4 mr-2" />
              Delete Selected ({selectedUsers.length})
            </button>
          )}
          {canManageUsers() && (
            <button
              onClick={() => setShowCreateModal(true)}
              className="btn-primary"
            >
              <PlusIcon className="h-4 w-4 mr-2" />
              New User
            </button>
          )}
        </div>
      </div>

      {/* Filters */}
      <div className="card">
        <div className="card-header">
          <h3 className="card-title">Filter Users</h3>
        </div>
        <div className="card-content">
          <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
            <div>
              <label className="label">Search</label>
              <div className="relative">
                <MagnifyingGlassIcon className="h-5 w-5 absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" />
                <input
                  type="text"
                  placeholder="Search users..."
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                  className="input pl-10"
                />
              </div>
            </div>
            <div>
              <label className="label">Role</label>
              <select
                value={roleFilter}
                onChange={(e) => setRoleFilter(e.target.value)}
                className="input"
              >
                <option value="">All Roles</option>
                <option value="ADMIN">Admin</option>
                <option value="BOARD">Board</option>
                <option value="ORGANIZER">Organizer</option>
                <option value="JUDGE">Judge</option>
                <option value="TALLY_MASTER">Tally Master</option>
                <option value="AUDITOR">Auditor</option>
                <option value="EMCEE">Emcee</option>
                <option value="CONTESTANT">Contestant</option>
              </select>
            </div>
            <div>
              <label className="label">Status</label>
              <select
                value={statusFilter}
                onChange={(e) => setStatusFilter(e.target.value)}
                className="input"
              >
                <option value="">All Status</option>
                <option value="active">Active</option>
                <option value="inactive">Inactive</option>
              </select>
            </div>
            <div className="flex items-end">
              <button
                onClick={() => {
                  setSearchTerm('')
                  setRoleFilter('')
                  setStatusFilter('')
                }}
                className="btn-secondary w-full"
              >
                Clear Filters
              </button>
            </div>
          </div>
        </div>
      </div>

      {/* Users List */}
      <div className="card">
        <div className="card-header">
          <div className="flex items-center justify-between">
            <div>
              <h3 className="card-title">Users</h3>
              <p className="card-description">
                {filteredUsers.length} users found
              </p>
            </div>
            {canManageUsers() && filteredUsers.length > 0 && (
              <div className="flex items-center space-x-2">
                <input
                  type="checkbox"
                  checked={selectedUsers.length === filteredUsers.length}
                  onChange={handleSelectAll}
                  className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                />
                <span className="text-sm text-gray-600 dark:text-gray-400">
                  Select All
                </span>
              </div>
            )}
          </div>
        </div>
        <div className="card-content">
          {isLoading ? (
            <div className="flex items-center justify-center py-8">
              <div className="loading-spinner h-8 w-8"></div>
            </div>
          ) : filteredUsers.length > 0 ? (
            <div className="space-y-4">
              {filteredUsers.map((user: User) => (
                <div
                  key={user.id}
                  className={`border rounded-lg p-4 transition-colors ${
                    selectedUsers.includes(user.id)
                      ? 'bg-blue-50 dark:bg-blue-900/20 border-blue-200 dark:border-blue-800'
                      : 'bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700'
                  }`}
                >
                  <div className="flex items-center justify-between">
                    <div className="flex items-center space-x-4">
                      {canManageUsers() && (
                        <input
                          type="checkbox"
                          checked={selectedUsers.includes(user.id)}
                          onChange={() => handleSelectUser(user.id)}
                          className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                        />
                      )}
                      <div className="flex items-center space-x-3">
                        {getRoleIcon(user.role)}
                        <div>
                          <h4 className="font-medium text-gray-900 dark:text-white">
                            {user.preferredName || user.name}
                            {user.preferredName && user.preferredName !== user.name && (
                              <span className="text-sm text-gray-500 dark:text-gray-400 ml-2">
                                ({user.name})
                              </span>
                            )}
                          </h4>
                          <p className="text-sm text-gray-600 dark:text-gray-400">
                            {user.email}
                          </p>
                        </div>
                      </div>
                    </div>
                    <div className="flex items-center space-x-4">
                      <div className="text-right">
                        <span className={`px-3 py-1 rounded-full text-sm font-medium ${getRoleColor(user.role)}`}>
                          {user.role.replace('_', ' ')}
                        </span>
                        <div className="flex items-center space-x-2 mt-1">
                          {user.isActive ? (
                            <CheckCircleIcon className="h-4 w-4 text-green-500" />
                          ) : (
                            <XCircleIcon className="h-4 w-4 text-red-500" />
                          )}
                          <span className="text-xs text-gray-500 dark:text-gray-400">
                            {user.isActive ? 'Active' : 'Inactive'}
                          </span>
                        </div>
                      </div>
                      <div className="text-right">
                        {user.lastLogin ? (
                          <div className="text-sm text-gray-500 dark:text-gray-400">
                            Last login: {new Date(user.lastLogin).toLocaleDateString()}
                          </div>
                        ) : (
                          <div className="text-sm text-gray-500 dark:text-gray-400">
                            Never logged in
                          </div>
                        )}
                      </div>
                      <div className="flex items-center space-x-2">
                        <button
                          onClick={() => {
                            setSelectedUser(user)
                            setShowEditModal(true)
                          }}
                          className="text-blue-600 hover:text-blue-900 dark:text-blue-400 dark:hover:text-blue-300"
                        >
                          <EyeIcon className="h-5 w-5" />
                        </button>
                        {canManageUsers() && (
                          <>
                            <button
                              onClick={() => {
                                setSelectedUser(user)
                                setShowEditModal(true)
                              }}
                              className="text-green-600 hover:text-green-900 dark:text-green-400 dark:hover:text-green-300"
                            >
                              <PencilIcon className="h-5 w-5" />
                            </button>
                            <button
                              onClick={() => handleDeleteUser(user.id)}
                              className="text-red-600 hover:text-red-900 dark:text-red-400 dark:hover:text-red-300"
                            >
                              <TrashIcon className="h-5 w-5" />
                            </button>
                          </>
                        )}
                      </div>
                    </div>
                  </div>
                  
                  {/* Role-specific information */}
                  {(user.role === 'JUDGE' || user.role === 'CONTESTANT') && (
                    <div className="mt-3 pt-3 border-t border-gray-200 dark:border-gray-700">
                      <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                        {user.role === 'JUDGE' && (
                          <>
                            {user.judgeNumber && (
                              <div>
                                <span className="text-gray-500 dark:text-gray-400">Judge #:</span>
                                <div className="font-medium">{user.judgeNumber}</div>
                              </div>
                            )}
                            {user.judgeLevel && (
                              <div>
                                <span className="text-gray-500 dark:text-gray-400">Level:</span>
                                <div className="font-medium">{user.judgeLevel}</div>
                              </div>
                            )}
                            {user.judgeExperience && (
                              <div>
                                <span className="text-gray-500 dark:text-gray-400">Experience:</span>
                                <div className="font-medium">{user.judgeExperience} years</div>
                              </div>
                            )}
                          </>
                        )}
                        {user.role === 'CONTESTANT' && (
                          <>
                            {user.contestantNumber && (
                              <div>
                                <span className="text-gray-500 dark:text-gray-400">Contestant #:</span>
                                <div className="font-medium">{user.contestantNumber}</div>
                              </div>
                            )}
                            {user.age && (
                              <div>
                                <span className="text-gray-500 dark:text-gray-400">Age:</span>
                                <div className="font-medium">{user.age}</div>
                              </div>
                            )}
                            {user.school && (
                              <div>
                                <span className="text-gray-500 dark:text-gray-400">School:</span>
                                <div className="font-medium">{user.school}</div>
                              </div>
                            )}
                            {user.grade && (
                              <div>
                                <span className="text-gray-500 dark:text-gray-400">Grade:</span>
                                <div className="font-medium">{user.grade}</div>
                              </div>
                            )}
                          </>
                        )}
                      </div>
                    </div>
                  )}
                </div>
              ))}
            </div>
          ) : (
            <div className="text-center py-12">
              <UserGroupIcon className="h-12 w-12 text-gray-400 mx-auto mb-4" />
              <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">
                No Users Found
              </h3>
              <p className="text-gray-600 dark:text-gray-400">
                Try adjusting your search criteria.
              </p>
            </div>
          )}
        </div>
      </div>

      {/* Create User Modal */}
      {showCreateModal && (
        <div className="modal">
          <div className="modal-overlay" onClick={() => setShowCreateModal(false)}></div>
          <div className="modal-content max-w-4xl">
            <div className="flex items-center justify-between mb-6">
              <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                Create User
              </h3>
              <button
                onClick={() => setShowCreateModal(false)}
                className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
              >
                <XMarkIcon className="h-6 w-6" />
              </button>
            </div>
            
            <form onSubmit={(e) => {
              e.preventDefault()
              const formData = new FormData(e.target as HTMLFormElement)
              const role = formData.get('role') as 'ADMIN' | 'BOARD' | 'ORGANIZER' | 'JUDGE' | 'TALLY_MASTER' | 'AUDITOR' | 'EMCEE' | 'CONTESTANT'
              
              const userData: CreateUserData = {
                name: formData.get('name') as string,
                email: formData.get('email') as string,
                password: password,
                role: role,
                phone: formData.get('phone') as string,
                address: formData.get('address') as string,
                emergencyContact: formData.get('emergencyContact') as string,
                emergencyPhone: formData.get('emergencyPhone') as string,
                bio: formData.get('bio') as string,
                experience: formData.get('experience') as string,
                preferredName: formData.get('preferredName') as string,
                pronouns: formData.get('pronouns') as string,
                judgeNumber: formData.get('judgeNumber') as string,
                judgeLevel: formData.get('judgeLevel') as string,
                judgeExperience: formData.get('judgeExperience') ? Number(formData.get('judgeExperience')) : undefined,
                contestantNumber: formData.get('contestantNumber') as string,
                age: formData.get('age') ? Number(formData.get('age')) : undefined,
                parentGuardian: formData.get('parentGuardian') as string,
                parentPhone: formData.get('parentPhone') as string,
                school: formData.get('school') as string,
                grade: formData.get('grade') as string
              }
              
              handleCreateUser(userData)
            }}>
              <div className="space-y-6">
                {/* Basic Information */}
                <div className="bg-gray-50 dark:bg-gray-800 rounded-lg p-4">
                  <h4 className="font-semibold text-gray-900 dark:text-white mb-4">Basic Information</h4>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                      <label className="label">Name</label>
                      <input name="name" type="text" className="input" required />
                    </div>
                    <div>
                      <label className="label">Preferred Name</label>
                      <input name="preferredName" type="text" className="input" />
                    </div>
                    <div>
                      <label className="label">Email</label>
                      <input name="email" type="email" className="input" required />
                    </div>
                    <div>
                      <label className="label">Pronouns</label>
                      <input name="pronouns" type="text" className="input" placeholder="they/them" />
                    </div>
                    <div>
                      <label className="label">Role</label>
                      <select name="role" className="input" required>
                        <option value="">Select Role</option>
                        <option value="ADMIN">Admin</option>
                        <option value="BOARD">Board</option>
                        <option value="ORGANIZER">Organizer</option>
                        <option value="JUDGE">Judge</option>
                        <option value="TALLY_MASTER">Tally Master</option>
                        <option value="AUDITOR">Auditor</option>
                        <option value="EMCEE">Emcee</option>
                        <option value="CONTESTANT">Contestant</option>
                      </select>
                    </div>
                    <div>
                      <label className="label">Phone</label>
                      <input name="phone" type="tel" className="input" />
                    </div>
                  </div>
                </div>

                {/* Password */}
                <div className="bg-gray-50 dark:bg-gray-800 rounded-lg p-4">
                  <h4 className="font-semibold text-gray-900 dark:text-white mb-4">Password</h4>
                  <PasswordStrengthMeter
                    password={password}
                    onPasswordChange={setPassword}
                    showPolicy={true}
                  />
                </div>

                {/* Contact Information */}
                <div className="bg-gray-50 dark:bg-gray-800 rounded-lg p-4">
                  <h4 className="font-semibold text-gray-900 dark:text-white mb-4">Contact Information</h4>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                      <label className="label">Address</label>
                      <textarea name="address" rows={3} className="input" />
                    </div>
                    <div>
                      <label className="label">Emergency Contact</label>
                      <input name="emergencyContact" type="text" className="input" />
                    </div>
                    <div>
                      <label className="label">Emergency Phone</label>
                      <input name="emergencyPhone" type="tel" className="input" />
                    </div>
                  </div>
                </div>

                {/* Role-specific fields will be added dynamically based on selected role */}
                <div className="bg-gray-50 dark:bg-gray-800 rounded-lg p-4">
                  <h4 className="font-semibold text-gray-900 dark:text-white mb-4">Additional Information</h4>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                      <label className="label">Bio</label>
                      <textarea name="bio" rows={3} className="input" />
                    </div>
                    <div>
                      <label className="label">Experience</label>
                      <textarea name="experience" rows={3} className="input" />
                    </div>
                  </div>
                </div>
              </div>
              
              <div className="flex items-center justify-end space-x-3 mt-6">
                <button
                  type="button"
                  onClick={() => setShowCreateModal(false)}
                  className="btn-secondary"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  disabled={createUserMutation.isLoading || !password}
                  className="btn-primary"
                >
                  {createUserMutation.isLoading ? 'Creating...' : 'Create User'}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}

      {/* Edit User Modal */}
      {showEditModal && selectedUser && (
        <div className="modal">
          <div className="modal-overlay" onClick={() => setShowEditModal(false)}></div>
          <div className="modal-content max-w-4xl">
            <div className="flex items-center justify-between mb-6">
              <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                Edit User
              </h3>
              <button
                onClick={() => setShowEditModal(false)}
                className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
              >
                <XMarkIcon className="h-6 w-6" />
              </button>
            </div>
            
            <form onSubmit={(e) => {
              e.preventDefault()
              const formData = new FormData(e.target as HTMLFormElement)
              handleUpdateUser(selectedUser.id, {
                name: formData.get('name') as string,
                email: formData.get('email') as string,
                role: formData.get('role') as 'ADMIN' | 'BOARD' | 'ORGANIZER' | 'JUDGE' | 'TALLY_MASTER' | 'AUDITOR' | 'EMCEE' | 'CONTESTANT',
                isActive: formData.get('isActive') === 'on',
                phone: formData.get('phone') as string,
                address: formData.get('address') as string,
                emergencyContact: formData.get('emergencyContact') as string,
                emergencyPhone: formData.get('emergencyPhone') as string,
                bio: formData.get('bio') as string,
                experience: formData.get('experience') as string,
                preferredName: formData.get('preferredName') as string,
                pronouns: formData.get('pronouns') as string,
                judgeNumber: formData.get('judgeNumber') as string,
                judgeLevel: formData.get('judgeLevel') as string,
                judgeExperience: formData.get('judgeExperience') ? Number(formData.get('judgeExperience')) : undefined,
                contestantNumber: formData.get('contestantNumber') as string,
                age: formData.get('age') ? Number(formData.get('age')) : undefined,
                parentGuardian: formData.get('parentGuardian') as string,
                parentPhone: formData.get('parentPhone') as string,
                school: formData.get('school') as string,
                grade: formData.get('grade') as string
              })
            }}>
              <div className="space-y-6">
                {/* Basic Information */}
                <div className="bg-gray-50 dark:bg-gray-800 rounded-lg p-4">
                  <h4 className="font-semibold text-gray-900 dark:text-white mb-4">Basic Information</h4>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                      <label className="label">Name</label>
                      <input name="name" type="text" className="input" defaultValue={selectedUser.name} required />
                    </div>
                    <div>
                      <label className="label">Preferred Name</label>
                      <input name="preferredName" type="text" className="input" defaultValue={selectedUser.preferredName} />
                    </div>
                    <div>
                      <label className="label">Email</label>
                      <input name="email" type="email" className="input" defaultValue={selectedUser.email} required />
                    </div>
                    <div>
                      <label className="label">Pronouns</label>
                      <input name="pronouns" type="text" className="input" defaultValue={selectedUser.pronouns} />
                    </div>
                    <div>
                      <label className="label">Role</label>
                      <select name="role" className="input" defaultValue={selectedUser.role} required>
                        <option value="ADMIN">Admin</option>
                        <option value="BOARD">Board</option>
                        <option value="ORGANIZER">Organizer</option>
                        <option value="JUDGE">Judge</option>
                        <option value="TALLY_MASTER">Tally Master</option>
                        <option value="AUDITOR">Auditor</option>
                        <option value="EMCEE">Emcee</option>
                        <option value="CONTESTANT">Contestant</option>
                      </select>
                    </div>
                    <div>
                      <label className="label">Phone</label>
                      <input name="phone" type="tel" className="input" defaultValue={selectedUser.phone} />
                    </div>
                    <div className="flex items-center">
                      <input
                        name="isActive"
                        type="checkbox"
                        className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                        defaultChecked={selectedUser.isActive}
                      />
                      <label className="ml-2 text-sm text-gray-700 dark:text-gray-300">
                        Active
                      </label>
                    </div>
                  </div>
                </div>

                {/* Contact Information */}
                <div className="bg-gray-50 dark:bg-gray-800 rounded-lg p-4">
                  <h4 className="font-semibold text-gray-900 dark:text-white mb-4">Contact Information</h4>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                      <label className="label">Address</label>
                      <textarea name="address" rows={3} className="input" defaultValue={selectedUser.address} />
                    </div>
                    <div>
                      <label className="label">Emergency Contact</label>
                      <input name="emergencyContact" type="text" className="input" defaultValue={selectedUser.emergencyContact} />
                    </div>
                    <div>
                      <label className="label">Emergency Phone</label>
                      <input name="emergencyPhone" type="tel" className="input" defaultValue={selectedUser.emergencyPhone} />
                    </div>
                  </div>
                </div>

                {/* Additional Information */}
                <div className="bg-gray-50 dark:bg-gray-800 rounded-lg p-4">
                  <h4 className="font-semibold text-gray-900 dark:text-white mb-4">Additional Information</h4>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                      <label className="label">Bio</label>
                      <textarea name="bio" rows={3} className="input" defaultValue={selectedUser.bio} />
                    </div>
                    <div>
                      <label className="label">Experience</label>
                      <textarea name="experience" rows={3} className="input" defaultValue={selectedUser.experience} />
                    </div>
                  </div>
                </div>

                {/* Role-specific fields */}
                {(selectedUser.role === 'JUDGE' || selectedUser.role === 'CONTESTANT') && (
                  <div className="bg-gray-50 dark:bg-gray-800 rounded-lg p-4">
                    <h4 className="font-semibold text-gray-900 dark:text-white mb-4">
                      {selectedUser.role === 'JUDGE' ? 'Judge Information' : 'Contestant Information'}
                    </h4>
                    <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                      {selectedUser.role === 'JUDGE' && (
                        <>
                          <div>
                            <label className="label">Judge Number</label>
                            <input name="judgeNumber" type="text" className="input" defaultValue={selectedUser.judgeNumber} />
                          </div>
                          <div>
                            <label className="label">Judge Level</label>
                            <select name="judgeLevel" className="input" defaultValue={selectedUser.judgeLevel}>
                              <option value="">Select Level</option>
                              <option value="NOVICE">Novice</option>
                              <option value="INTERMEDIATE">Intermediate</option>
                              <option value="ADVANCED">Advanced</option>
                              <option value="EXPERT">Expert</option>
                            </select>
                          </div>
                          <div>
                            <label className="label">Years of Experience</label>
                            <input name="judgeExperience" type="number" className="input" defaultValue={selectedUser.judgeExperience} min="0" />
                          </div>
                        </>
                      )}
                      {selectedUser.role === 'CONTESTANT' && (
                        <>
                          <div>
                            <label className="label">Contestant Number</label>
                            <input name="contestantNumber" type="text" className="input" defaultValue={selectedUser.contestantNumber} />
                          </div>
                          <div>
                            <label className="label">Age</label>
                            <input name="age" type="number" className="input" defaultValue={selectedUser.age} min="1" max="100" />
                          </div>
                          <div>
                            <label className="label">Parent/Guardian</label>
                            <input name="parentGuardian" type="text" className="input" defaultValue={selectedUser.parentGuardian} />
                          </div>
                          <div>
                            <label className="label">Parent Phone</label>
                            <input name="parentPhone" type="tel" className="input" defaultValue={selectedUser.parentPhone} />
                          </div>
                          <div>
                            <label className="label">School</label>
                            <input name="school" type="text" className="input" defaultValue={selectedUser.school} />
                          </div>
                          <div>
                            <label className="label">Grade</label>
                            <input name="grade" type="text" className="input" defaultValue={selectedUser.grade} />
                          </div>
                        </>
                      )}
                    </div>
                  </div>
                )}
              </div>
              
              <div className="flex items-center justify-end space-x-3 mt-6">
                <button
                  type="button"
                  onClick={() => setShowEditModal(false)}
                  className="btn-secondary"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  disabled={updateUserMutation.isLoading}
                  className="btn-primary"
                >
                  {updateUserMutation.isLoading ? 'Updating...' : 'Update User'}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}

      {/* Bulk Delete Modal */}
      {showBulkModal && (
        <div className="modal">
          <div className="modal-overlay" onClick={() => setShowBulkModal(false)}></div>
          <div className="modal-content">
            <div className="flex items-center justify-between mb-6">
              <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                Bulk Delete Users
              </h3>
              <button
                onClick={() => setShowBulkModal(false)}
                className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
              >
                <XMarkIcon className="h-6 w-6" />
              </button>
            </div>
            
            <div className="space-y-4">
              <div className="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-4">
                <div className="flex items-start space-x-2">
                  <ExclamationTriangleIcon className="h-5 w-5 text-red-600 dark:text-red-400 mt-0.5" />
                  <div className="text-sm text-red-700 dark:text-red-300">
                    <p className="font-medium mb-1">Warning:</p>
                    <p>You are about to permanently delete {selectedUsers.length} users. This action cannot be undone.</p>
                  </div>
                </div>
              </div>
              
              <div className="text-sm text-gray-600 dark:text-gray-400">
                <p>Selected users:</p>
                <ul className="list-disc list-inside mt-2 space-y-1">
                  {selectedUsers.map(userId => {
                    const user = users?.find((u: User) => u.id === userId)
                    return user ? (
                      <li key={userId}>{user.name} ({user.email})</li>
                    ) : null
                  })}
                </ul>
              </div>
            </div>
            
            <div className="flex items-center justify-end space-x-3 mt-6">
              <button
                type="button"
                onClick={() => setShowBulkModal(false)}
                className="btn-secondary"
              >
                Cancel
              </button>
              <button
                onClick={handleBulkDelete}
                disabled={bulkDeleteMutation.isLoading}
                className="btn-danger"
              >
                {bulkDeleteMutation.isLoading ? 'Deleting...' : 'Delete Users'}
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}

export default UsersPage
EOF

    # Update ReportsPage with enhanced reporting functionality
    cat > "$APP_DIR/frontend/src/pages/ReportsPage.tsx" << 'EOF'
import React, { useState } from 'react'
import { useQuery, useMutation, useQueryClient } from 'react-query'
import { useAuth } from '../contexts/AuthContext'
import { reportsAPI } from '../services/api'
import {
  DocumentTextIcon,
  PrinterIcon,
  ArrowDownTrayIcon,
  EnvelopeIcon,
  EyeIcon,
  XMarkIcon,
  PlusIcon,
  PencilIcon,
  TrashIcon,
  CalendarIcon,
  ChartBarIcon,
  UserGroupIcon,
  TrophyIcon,
  ClockIcon,
  CheckCircleIcon,
  ExclamationTriangleIcon,
  MagnifyingGlassIcon,
  FunnelIcon,
  DocumentDuplicateIcon,
  ShareIcon,
  Cog6ToothIcon,
  InformationCircleIcon,
  PlayIcon,
  StopIcon,
  ArrowPathIcon
} from '@heroicons/react/24/outline'

interface Report {
  id: string
  name: string
  type: 'EVENT_SUMMARY' | 'CONTEST_RESULTS' | 'JUDGE_PERFORMANCE' | 'SYSTEM_ANALYTICS' | 'CUSTOM'
  description?: string
  parameters: any
  generatedAt?: string
  generatedBy?: string
  filePath?: string
  isPublic: boolean
  createdAt: string
  updatedAt: string
}

interface ReportTemplate {
  id: string
  name: string
  type: string
  description?: string
  parameters: any
  isPublic: boolean
  createdBy: string
  createdAt: string
}

interface CreateReportData {
  name: string
  type: string
  description?: string
  parameters: any
  isPublic: boolean
}

const ReportsPage: React.FC = () => {
  const { user } = useAuth()
  const queryClient = useQueryClient()
  const [showCreateModal, setShowCreateModal] = useState<boolean>(false)
  const [showTemplateModal, setShowTemplateModal] = useState<boolean>(false)
  const [showEmailModal, setShowEmailModal] = useState<boolean>(false)
  const [selectedReport, setSelectedReport] = useState<Report | null>(null)
  const [selectedTemplate, setSelectedTemplate] = useState<ReportTemplate | null>(null)
  const [searchTerm, setSearchTerm] = useState<string>('')
  const [typeFilter, setTypeFilter] = useState<string>('')
  const [statusFilter, setStatusFilter] = useState<string>('')
  const [emailRecipients, setEmailRecipients] = useState<string>('')
  const [emailSubject, setEmailSubject] = useState<string>('')
  const [emailMessage, setEmailMessage] = useState<string>('')

  // Fetch reports
  const { data: reports, isLoading } = useQuery(
    ['reports', searchTerm, typeFilter, statusFilter],
    () => reportsAPI.getReports({
      search: searchTerm,
      type: typeFilter,
      status: statusFilter
    }).then(res => res.data)
  )

  // Fetch templates
  const { data: templates } = useQuery(
    'reportTemplates',
    () => reportsAPI.getTemplates().then(res => res.data)
  )

  // Create report mutation
  const createReportMutation = useMutation(
    (data: CreateReportData) => reportsAPI.createReport(data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('reports')
        setShowCreateModal(false)
      }
    }
  )

  // Generate report mutation
  const generateReportMutation = useMutation(
    (id: string) => reportsAPI.generateReport(id),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('reports')
      }
    }
  )

  // Delete report mutation
  const deleteReportMutation = useMutation(
    (id: string) => reportsAPI.deleteReport(id),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('reports')
      }
    }
  )

  // Email report mutation
  const emailReportMutation = useMutation(
    ({ reportId, recipients, subject, message }: { reportId: string; recipients: string; subject: string; message: string }) =>
      reportsAPI.emailReport(reportId, { recipients, subject, message }),
    {
      onSuccess: () => {
        setShowEmailModal(false)
        setEmailRecipients('')
        setEmailSubject('')
        setEmailMessage('')
      }
    }
  )

  const canManageReports = () => {
    return user?.role === 'ADMIN' || user?.role === 'BOARD' || user?.role === 'ORGANIZER'
  }

  const handleCreateReport = (data: CreateReportData) => {
    createReportMutation.mutate(data)
  }

  const handleGenerateReport = (id: string) => {
    generateReportMutation.mutate(id)
  }

  const handleDeleteReport = (id: string) => {
    if (window.confirm('Are you sure you want to delete this report?')) {
      deleteReportMutation.mutate(id)
    }
  }

  const handleEmailReport = () => {
    if (selectedReport && emailRecipients && emailSubject) {
      emailReportMutation.mutate({
        reportId: selectedReport.id,
        recipients: emailRecipients,
        subject: emailSubject,
        message: emailMessage
      })
    }
  }

  const handleCreateFromTemplate = (template: ReportTemplate) => {
    const reportData: CreateReportData = {
      name: `${template.name} - ${new Date().toLocaleDateString()}`,
      type: template.type,
      description: template.description,
      parameters: template.parameters,
      isPublic: template.isPublic
    }
    handleCreateReport(reportData)
    setShowTemplateModal(false)
  }

  const getReportTypeIcon = (type: string) => {
    switch (type) {
      case 'EVENT_SUMMARY': return <CalendarIcon className="h-5 w-5 text-blue-500" />
      case 'CONTEST_RESULTS': return <TrophyIcon className="h-5 w-5 text-yellow-500" />
      case 'JUDGE_PERFORMANCE': return <UserGroupIcon className="h-5 w-5 text-purple-500" />
      case 'SYSTEM_ANALYTICS': return <ChartBarIcon className="h-5 w-5 text-green-500" />
      case 'CUSTOM': return <Cog6ToothIcon className="h-5 w-5 text-gray-500" />
      default: return <DocumentTextIcon className="h-5 w-5 text-gray-500" />
    }
  }

  const getReportTypeColor = (type: string) => {
    switch (type) {
      case 'EVENT_SUMMARY': return 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200'
      case 'CONTEST_RESULTS': return 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200'
      case 'JUDGE_PERFORMANCE': return 'bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-200'
      case 'SYSTEM_ANALYTICS': return 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200'
      case 'CUSTOM': return 'bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200'
      default: return 'bg-gray-100 text-gray-800 dark:bg-gray-900 dark:text-gray-200'
    }
  }

  const getReportStatus = (report: Report) => {
    if (report.generatedAt) {
      return {
        icon: <CheckCircleIcon className="h-4 w-4 text-green-500" />,
        text: 'Generated',
        color: 'text-green-600 dark:text-green-400'
      }
    } else {
      return {
        icon: <ClockIcon className="h-4 w-4 text-yellow-500" />,
        text: 'Pending',
        color: 'text-yellow-600 dark:text-yellow-400'
      }
    }
  }

  const filteredReports = reports?.filter((report: Report) => {
    const matchesSearch = report.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                         report.description?.toLowerCase().includes(searchTerm.toLowerCase())
    const matchesType = !typeFilter || report.type === typeFilter
    const matchesStatus = !statusFilter || 
                         (statusFilter === 'generated' && report.generatedAt) ||
                         (statusFilter === 'pending' && !report.generatedAt)
    return matchesSearch && matchesType && matchesStatus
  }) || []

  const getReportParametersForm = (type: string) => {
    switch (type) {
      case 'EVENT_SUMMARY':
        return (
          <div className="space-y-4">
            <div>
              <label className="label">Event</label>
              <select name="eventId" className="input" required>
                <option value="">Select Event</option>
                {/* Events will be populated dynamically */}
              </select>
            </div>
            <div className="grid grid-cols-2 gap-4">
              <div>
                <label className="label">Include Contests</label>
                <input name="includeContests" type="checkbox" className="rounded border-gray-300 text-blue-600 focus:ring-blue-500" defaultChecked />
              </div>
              <div>
                <label className="label">Include Participants</label>
                <input name="includeParticipants" type="checkbox" className="rounded border-gray-300 text-blue-600 focus:ring-blue-500" defaultChecked />
              </div>
            </div>
          </div>
        )
      case 'CONTEST_RESULTS':
        return (
          <div className="space-y-4">
            <div>
              <label className="label">Event</label>
              <select name="eventId" className="input" required>
                <option value="">Select Event</option>
              </select>
            </div>
            <div>
              <label className="label">Contest</label>
              <select name="contestId" className="input" required>
                <option value="">Select Contest</option>
              </select>
            </div>
            <div>
              <label className="label">Category</label>
              <select name="categoryId" className="input">
                <option value="">All Categories</option>
              </select>
            </div>
            <div className="grid grid-cols-2 gap-4">
              <div>
                <label className="label">Include Scores</label>
                <input name="includeScores" type="checkbox" className="rounded border-gray-300 text-blue-600 focus:ring-blue-500" defaultChecked />
              </div>
              <div>
                <label className="label">Include Rankings</label>
                <input name="includeRankings" type="checkbox" className="rounded border-gray-300 text-blue-600 focus:ring-blue-500" defaultChecked />
              </div>
            </div>
          </div>
        )
      case 'JUDGE_PERFORMANCE':
        return (
          <div className="space-y-4">
            <div>
              <label className="label">Event</label>
              <select name="eventId" className="input" required>
                <option value="">Select Event</option>
              </select>
            </div>
            <div>
              <label className="label">Judge</label>
              <select name="judgeId" className="input">
                <option value="">All Judges</option>
              </select>
            </div>
            <div className="grid grid-cols-2 gap-4">
              <div>
                <label className="label">Include Scoring History</label>
                <input name="includeHistory" type="checkbox" className="rounded border-gray-300 text-blue-600 focus:ring-blue-500" defaultChecked />
              </div>
              <div>
                <label className="label">Include Statistics</label>
                <input name="includeStatistics" type="checkbox" className="rounded border-gray-300 text-blue-600 focus:ring-blue-500" defaultChecked />
              </div>
            </div>
          </div>
        )
      case 'SYSTEM_ANALYTICS':
        return (
          <div className="space-y-4">
            <div className="grid grid-cols-2 gap-4">
              <div>
                <label className="label">Start Date</label>
                <input name="startDate" type="date" className="input" />
              </div>
              <div>
                <label className="label">End Date</label>
                <input name="endDate" type="date" className="input" />
              </div>
            </div>
            <div className="grid grid-cols-2 gap-4">
              <div>
                <label className="label">Include User Activity</label>
                <input name="includeUserActivity" type="checkbox" className="rounded border-gray-300 text-blue-600 focus:ring-blue-500" defaultChecked />
              </div>
              <div>
                <label className="label">Include System Performance</label>
                <input name="includeSystemPerformance" type="checkbox" className="rounded border-gray-300 text-blue-600 focus:ring-blue-500" defaultChecked />
              </div>
            </div>
          </div>
        )
      default:
        return (
          <div className="space-y-4">
            <div>
              <label className="label">Custom Parameters (JSON)</label>
              <textarea name="customParameters" rows={6} className="input font-mono text-sm" placeholder="Enter custom parameters as JSON..." />
            </div>
          </div>
        )
    }
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">
            Reports
          </h1>
          <p className="text-gray-600 dark:text-gray-400">
            Generate and manage reports
          </p>
        </div>
        <div className="flex items-center space-x-3">
          <button
            onClick={() => setShowTemplateModal(true)}
            className="btn-secondary"
          >
            <DocumentDuplicateIcon className="h-4 w-4 mr-2" />
            From Template
          </button>
          {canManageReports() && (
            <button
              onClick={() => setShowCreateModal(true)}
              className="btn-primary"
            >
              <PlusIcon className="h-4 w-4 mr-2" />
              New Report
            </button>
          )}
        </div>
      </div>

      {/* Filters */}
      <div className="card">
        <div className="card-header">
          <h3 className="card-title">Filter Reports</h3>
        </div>
        <div className="card-content">
          <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
            <div>
              <label className="label">Search</label>
              <div className="relative">
                <MagnifyingGlassIcon className="h-5 w-5 absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" />
                <input
                  type="text"
                  placeholder="Search reports..."
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                  className="input pl-10"
                />
              </div>
            </div>
            <div>
              <label className="label">Type</label>
              <select
                value={typeFilter}
                onChange={(e) => setTypeFilter(e.target.value)}
                className="input"
              >
                <option value="">All Types</option>
                <option value="EVENT_SUMMARY">Event Summary</option>
                <option value="CONTEST_RESULTS">Contest Results</option>
                <option value="JUDGE_PERFORMANCE">Judge Performance</option>
                <option value="SYSTEM_ANALYTICS">System Analytics</option>
                <option value="CUSTOM">Custom</option>
              </select>
            </div>
            <div>
              <label className="label">Status</label>
              <select
                value={statusFilter}
                onChange={(e) => setStatusFilter(e.target.value)}
                className="input"
              >
                <option value="">All Status</option>
                <option value="generated">Generated</option>
                <option value="pending">Pending</option>
              </select>
            </div>
            <div className="flex items-end">
              <button
                onClick={() => {
                  setSearchTerm('')
                  setTypeFilter('')
                  setStatusFilter('')
                }}
                className="btn-secondary w-full"
              >
                Clear Filters
              </button>
            </div>
          </div>
        </div>
      </div>

      {/* Reports List */}
      <div className="card">
        <div className="card-header">
          <div className="flex items-center justify-between">
            <div>
              <h3 className="card-title">Reports</h3>
              <p className="card-description">
                {filteredReports.length} reports found
              </p>
            </div>
          </div>
        </div>
        <div className="card-content">
          {isLoading ? (
            <div className="flex items-center justify-center py-8">
              <div className="loading-spinner h-8 w-8"></div>
            </div>
          ) : filteredReports.length > 0 ? (
            <div className="space-y-4">
              {filteredReports.map((report: Report) => {
                const status = getReportStatus(report)
                return (
                  <div
                    key={report.id}
                    className="border rounded-lg p-4 bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700"
                  >
                    <div className="flex items-center justify-between">
                      <div className="flex items-center space-x-4">
                        <div className="flex items-center space-x-3">
                          {getReportTypeIcon(report.type)}
                          <div>
                            <h4 className="font-medium text-gray-900 dark:text-white">
                              {report.name}
                            </h4>
                            {report.description && (
                              <p className="text-sm text-gray-600 dark:text-gray-400">
                                {report.description}
                              </p>
                            )}
                          </div>
                        </div>
                      </div>
                      <div className="flex items-center space-x-4">
                        <div className="text-right">
                          <span className={`px-3 py-1 rounded-full text-sm font-medium ${getReportTypeColor(report.type)}`}>
                            {report.type.replace('_', ' ')}
                          </span>
                          <div className="flex items-center space-x-2 mt-1">
                            {status.icon}
                            <span className={`text-xs font-medium ${status.color}`}>
                              {status.text}
                            </span>
                          </div>
                        </div>
                        <div className="text-right">
                          {report.generatedAt ? (
                            <div className="text-sm text-gray-500 dark:text-gray-400">
                              Generated: {new Date(report.generatedAt).toLocaleDateString()}
                            </div>
                          ) : (
                            <div className="text-sm text-gray-500 dark:text-gray-400">
                              Created: {new Date(report.createdAt).toLocaleDateString()}
                            </div>
                          )}
                        </div>
                        <div className="flex items-center space-x-2">
                          {report.generatedAt ? (
                            <>
                              <button
                                onClick={() => window.open(`/api/reports/${report.id}/download`, '_blank')}
                                className="text-blue-600 hover:text-blue-900 dark:text-blue-400 dark:hover:text-blue-300"
                                title="Download Report"
                              >
                                <ArrowDownTrayIcon className="h-5 w-5" />
                              </button>
                              <button
                                onClick={() => window.print()}
                                className="text-green-600 hover:text-green-900 dark:text-green-400 dark:hover:text-green-300"
                                title="Print Report"
                              >
                                <PrinterIcon className="h-5 w-5" />
                              </button>
                              <button
                                onClick={() => {
                                  setSelectedReport(report)
                                  setShowEmailModal(true)
                                }}
                                className="text-purple-600 hover:text-purple-900 dark:text-purple-400 dark:hover:text-purple-300"
                                title="Email Report"
                              >
                                <EnvelopeIcon className="h-5 w-5" />
                              </button>
                            </>
                          ) : (
                            <button
                              onClick={() => handleGenerateReport(report.id)}
                              disabled={generateReportMutation.isLoading}
                              className="text-yellow-600 hover:text-yellow-900 dark:text-yellow-400 dark:hover:text-yellow-300"
                              title="Generate Report"
                            >
                              <PlayIcon className="h-5 w-5" />
                            </button>
                          )}
                          <button
                            onClick={() => {
                              setSelectedReport(report)
                              // Show report details modal
                            }}
                            className="text-gray-600 hover:text-gray-900 dark:text-gray-400 dark:hover:text-gray-300"
                            title="View Details"
                          >
                            <EyeIcon className="h-5 w-5" />
                          </button>
                          {canManageReports() && (
                            <>
                              <button
                                onClick={() => {
                                  setSelectedReport(report)
                                  setShowCreateModal(true)
                                }}
                                className="text-green-600 hover:text-green-900 dark:text-green-400 dark:hover:text-green-300"
                                title="Edit Report"
                              >
                                <PencilIcon className="h-5 w-5" />
                              </button>
                              <button
                                onClick={() => handleDeleteReport(report.id)}
                                className="text-red-600 hover:text-red-900 dark:text-red-400 dark:hover:text-red-300"
                                title="Delete Report"
                              >
                                <TrashIcon className="h-5 w-5" />
                              </button>
                            </>
                          )}
                        </div>
                      </div>
                    </div>
                  </div>
                )
              })}
            </div>
          ) : (
            <div className="text-center py-12">
              <DocumentTextIcon className="h-12 w-12 text-gray-400 mx-auto mb-4" />
              <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">
                No Reports Found
              </h3>
              <p className="text-gray-600 dark:text-gray-400">
                {canManageReports()
                  ? 'Create your first report to get started.'
                  : 'No reports are available.'}
              </p>
            </div>
          )}
        </div>
      </div>

      {/* Create Report Modal */}
      {showCreateModal && (
        <div className="modal">
          <div className="modal-overlay" onClick={() => setShowCreateModal(false)}></div>
          <div className="modal-content max-w-4xl">
            <div className="flex items-center justify-between mb-6">
              <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                {selectedReport ? 'Edit Report' : 'Create Report'}
              </h3>
              <button
                onClick={() => setShowCreateModal(false)}
                className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
              >
                <XMarkIcon className="h-6 w-6" />
              </button>
            </div>
            
            <form onSubmit={(e) => {
              e.preventDefault()
              const formData = new FormData(e.target as HTMLFormElement)
              const type = formData.get('type') as string
              
              // Build parameters object based on type
              let parameters: any = {}
              if (type === 'EVENT_SUMMARY') {
                parameters = {
                  eventId: formData.get('eventId'),
                  includeContests: formData.get('includeContests') === 'on',
                  includeParticipants: formData.get('includeParticipants') === 'on'
                }
              } else if (type === 'CONTEST_RESULTS') {
                parameters = {
                  eventId: formData.get('eventId'),
                  contestId: formData.get('contestId'),
                  categoryId: formData.get('categoryId'),
                  includeScores: formData.get('includeScores') === 'on',
                  includeRankings: formData.get('includeRankings') === 'on'
                }
              } else if (type === 'JUDGE_PERFORMANCE') {
                parameters = {
                  eventId: formData.get('eventId'),
                  judgeId: formData.get('judgeId'),
                  includeHistory: formData.get('includeHistory') === 'on',
                  includeStatistics: formData.get('includeStatistics') === 'on'
                }
              } else if (type === 'SYSTEM_ANALYTICS') {
                parameters = {
                  startDate: formData.get('startDate'),
                  endDate: formData.get('endDate'),
                  includeUserActivity: formData.get('includeUserActivity') === 'on',
                  includeSystemPerformance: formData.get('includeSystemPerformance') === 'on'
                }
              } else if (type === 'CUSTOM') {
                try {
                  parameters = JSON.parse(formData.get('customParameters') as string || '{}')
                } catch (e) {
                  alert('Invalid JSON in custom parameters')
                  return
                }
              }
              
              const reportData: CreateReportData = {
                name: formData.get('name') as string,
                type: type,
                description: formData.get('description') as string,
                parameters: parameters,
                isPublic: formData.get('isPublic') === 'on'
              }
              
              if (selectedReport) {
                // Update existing report
                // updateReportMutation.mutate({ id: selectedReport.id, data: reportData })
              } else {
                handleCreateReport(reportData)
              }
            }}>
              <div className="space-y-6">
                {/* Basic Information */}
                <div className="bg-gray-50 dark:bg-gray-800 rounded-lg p-4">
                  <h4 className="font-semibold text-gray-900 dark:text-white mb-4">Basic Information</h4>
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                    <div>
                      <label className="label">Name</label>
                      <input name="name" type="text" className="input" defaultValue={selectedReport?.name} required />
                    </div>
                    <div>
                      <label className="label">Type</label>
                      <select name="type" className="input" defaultValue={selectedReport?.type} required>
                        <option value="">Select Type</option>
                        <option value="EVENT_SUMMARY">Event Summary</option>
                        <option value="CONTEST_RESULTS">Contest Results</option>
                        <option value="JUDGE_PERFORMANCE">Judge Performance</option>
                        <option value="SYSTEM_ANALYTICS">System Analytics</option>
                        <option value="CUSTOM">Custom</option>
                      </select>
                    </div>
                    <div className="md:col-span-2">
                      <label className="label">Description</label>
                      <textarea name="description" rows={3} className="input" defaultValue={selectedReport?.description} />
                    </div>
                    <div className="flex items-center">
                      <input
                        name="isPublic"
                        type="checkbox"
                        className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
                        defaultChecked={selectedReport?.isPublic}
                      />
                      <label className="ml-2 text-sm text-gray-700 dark:text-gray-300">
                        Public report
                      </label>
                    </div>
                  </div>
                </div>

                {/* Report Parameters */}
                <div className="bg-gray-50 dark:bg-gray-800 rounded-lg p-4">
                  <h4 className="font-semibold text-gray-900 dark:text-white mb-4">Report Parameters</h4>
                  {getReportParametersForm(selectedReport?.type || 'EVENT_SUMMARY')}
                </div>
              </div>
              
              <div className="flex items-center justify-end space-x-3 mt-6">
                <button
                  type="button"
                  onClick={() => setShowCreateModal(false)}
                  className="btn-secondary"
                >
                  Cancel
                </button>
                <button
                  type="submit"
                  disabled={createReportMutation.isLoading}
                  className="btn-primary"
                >
                  {createReportMutation.isLoading ? 'Creating...' : selectedReport ? 'Update Report' : 'Create Report'}
                </button>
              </div>
            </form>
          </div>
        </div>
      )}

      {/* Template Selection Modal */}
      {showTemplateModal && (
        <div className="modal">
          <div className="modal-overlay" onClick={() => setShowTemplateModal(false)}></div>
          <div className="modal-content max-w-4xl">
            <div className="flex items-center justify-between mb-6">
              <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                Create Report from Template
              </h3>
              <button
                onClick={() => setShowTemplateModal(false)}
                className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
              >
                <XMarkIcon className="h-6 w-6" />
              </button>
            </div>
            
            <div className="space-y-4">
              {templates && templates.length > 0 ? (
                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
                  {templates.map((template: ReportTemplate) => (
                    <div
                      key={template.id}
                      className="border rounded-lg p-4 bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700 hover:shadow-md transition-shadow cursor-pointer"
                      onClick={() => handleCreateFromTemplate(template)}
                    >
                      <div className="flex items-center space-x-3 mb-3">
                        {getReportTypeIcon(template.type)}
                        <div>
                          <h4 className="font-medium text-gray-900 dark:text-white">
                            {template.name}
                          </h4>
                          <span className={`px-2 py-1 rounded-full text-xs font-medium ${getReportTypeColor(template.type)}`}>
                            {template.type.replace('_', ' ')}
                          </span>
                        </div>
                      </div>
                      {template.description && (
                        <p className="text-sm text-gray-600 dark:text-gray-400 mb-3">
                          {template.description}
                        </p>
                      )}
                      <div className="text-xs text-gray-500 dark:text-gray-400">
                        Created: {new Date(template.createdAt).toLocaleDateString()}
                      </div>
                    </div>
                  ))}
                </div>
              ) : (
                <div className="text-center py-12">
                  <DocumentDuplicateIcon className="h-12 w-12 text-gray-400 mx-auto mb-4" />
                  <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">
                    No Templates Available
                  </h3>
                  <p className="text-gray-600 dark:text-gray-400">
                    No report templates are available.
                  </p>
                </div>
              )}
            </div>
          </div>
        </div>
      )}

      {/* Email Report Modal */}
      {showEmailModal && selectedReport && (
        <div className="modal">
          <div className="modal-overlay" onClick={() => setShowEmailModal(false)}></div>
          <div className="modal-content">
            <div className="flex items-center justify-between mb-6">
              <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                Email Report
              </h3>
              <button
                onClick={() => setShowEmailModal(false)}
                className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
              >
                <XMarkIcon className="h-6 w-6" />
              </button>
            </div>
            
            <div className="space-y-4">
              <div>
                <label className="label">Recipients</label>
                <input
                  type="text"
                  value={emailRecipients}
                  onChange={(e) => setEmailRecipients(e.target.value)}
                  className="input"
                  placeholder="email1@example.com, email2@example.com"
                  required
                />
                <p className="text-sm text-gray-500 dark:text-gray-400 mt-1">
                  Separate multiple email addresses with commas
                </p>
              </div>
              <div>
                <label className="label">Subject</label>
                <input
                  type="text"
                  value={emailSubject}
                  onChange={(e) => setEmailSubject(e.target.value)}
                  className="input"
                  defaultValue={`Report: ${selectedReport.name}`}
                  required
                />
              </div>
              <div>
                <label className="label">Message</label>
                <textarea
                  value={emailMessage}
                  onChange={(e) => setEmailMessage(e.target.value)}
                  rows={4}
                  className="input"
                  placeholder="Optional message to include with the report..."
                />
              </div>
            </div>
            
            <div className="flex items-center justify-end space-x-3 mt-6">
              <button
                type="button"
                onClick={() => setShowEmailModal(false)}
                className="btn-secondary"
              >
                Cancel
              </button>
              <button
                onClick={handleEmailReport}
                disabled={emailReportMutation.isLoading || !emailRecipients || !emailSubject}
                className="btn-primary"
              >
                {emailReportMutation.isLoading ? 'Sending...' : 'Send Email'}
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}

export default ReportsPage
EOF

    # Create CountdownTimer component for timed criteria
    cat > "$APP_DIR/frontend/src/components/CountdownTimer.tsx" << 'EOF'
import React, { useState, useEffect, useRef } from 'react'
import {
  ClockIcon,
  PlayIcon,
  PauseIcon,
  StopIcon,
  ExclamationTriangleIcon,
  CheckCircleIcon
} from '@heroicons/react/24/outline'

interface CountdownTimerProps {
  timeLimit: number // in seconds
  onTimeUp?: () => void
  onTimeWarning?: () => void
  warningThreshold?: number // seconds before time up to show warning
  autoStart?: boolean
  showControls?: boolean
  className?: string
}

const CountdownTimer: React.FC<CountdownTimerProps> = ({
  timeLimit,
  onTimeUp,
  onTimeWarning,
  warningThreshold = 30,
  autoStart = false,
  showControls = true,
  className = ''
}) => {
  const [timeLeft, setTimeLeft] = useState<number>(timeLimit)
  const [isRunning, setIsRunning] = useState<boolean>(autoStart)
  const [isPaused, setIsPaused] = useState<boolean>(false)
  const [hasStarted, setHasStarted] = useState<boolean>(false)
  const [isTimeUp, setIsTimeUp] = useState<boolean>(false)
  const [hasWarned, setHasWarned] = useState<boolean>(false)
  const intervalRef = useRef<NodeJS.Timeout | null>(null)

  useEffect(() => {
    if (isRunning && !isPaused && timeLeft > 0) {
      intervalRef.current = setInterval(() => {
        setTimeLeft((prev) => {
          const newTime = prev - 1
          
          // Check for warning
          if (newTime <= warningThreshold && !hasWarned) {
            setHasWarned(true)
            onTimeWarning?.()
          }
          
          // Check for time up
          if (newTime <= 0) {
            setIsTimeUp(true)
            setIsRunning(false)
            onTimeUp?.()
            return 0
          }
          
          return newTime
        })
      }, 1000)
    } else {
      if (intervalRef.current) {
        clearInterval(intervalRef.current)
        intervalRef.current = null
      }
    }

    return () => {
      if (intervalRef.current) {
        clearInterval(intervalRef.current)
      }
    }
  }, [isRunning, isPaused, timeLeft, warningThreshold, hasWarned, onTimeUp, onTimeWarning])

  const formatTime = (seconds: number): string => {
    const minutes = Math.floor(seconds / 60)
    const remainingSeconds = seconds % 60
    return `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`
  }

  const handleStart = () => {
    if (!hasStarted) {
      setHasStarted(true)
    }
    setIsRunning(true)
    setIsPaused(false)
  }

  const handlePause = () => {
    setIsRunning(false)
    setIsPaused(true)
  }

  const handleResume = () => {
    setIsRunning(true)
    setIsPaused(false)
  }

  const handleStop = () => {
    setIsRunning(false)
    setIsPaused(false)
    setTimeLeft(timeLimit)
    setHasStarted(false)
    setIsTimeUp(false)
    setHasWarned(false)
  }

  const handleReset = () => {
    setTimeLeft(timeLimit)
    setIsRunning(false)
    setIsPaused(false)
    setHasStarted(false)
    setIsTimeUp(false)
    setHasWarned(false)
  }

  const getTimerColor = (): string => {
    if (isTimeUp) return 'text-red-600 dark:text-red-400'
    if (timeLeft <= warningThreshold) return 'text-yellow-600 dark:text-yellow-400'
    return 'text-green-600 dark:text-green-400'
  }

  const getTimerBgColor = (): string => {
    if (isTimeUp) return 'bg-red-100 dark:bg-red-900/20 border-red-200 dark:border-red-800'
    if (timeLeft <= warningThreshold) return 'bg-yellow-100 dark:bg-yellow-900/20 border-yellow-200 dark:border-yellow-800'
    return 'bg-green-100 dark:bg-green-900/20 border-green-200 dark:border-green-800'
  }

  const getStatusIcon = () => {
    if (isTimeUp) return <ExclamationTriangleIcon className="h-5 w-5 text-red-500" />
    if (timeLeft <= warningThreshold) return <ExclamationTriangleIcon className="h-5 w-5 text-yellow-500" />
    if (isRunning) return <PlayIcon className="h-5 w-5 text-green-500" />
    if (isPaused) return <PauseIcon className="h-5 w-5 text-yellow-500" />
    return <ClockIcon className="h-5 w-5 text-gray-500" />
  }

  const getStatusText = (): string => {
    if (isTimeUp) return 'Time Up!'
    if (timeLeft <= warningThreshold) return 'Time Warning'
    if (isRunning) return 'Running'
    if (isPaused) return 'Paused'
    if (hasStarted) return 'Stopped'
    return 'Ready'
  }

  return (
    <div className={`border rounded-lg p-4 ${getTimerBgColor()} ${className}`}>
      <div className="flex items-center justify-between mb-3">
        <div className="flex items-center space-x-2">
          <ClockIcon className="h-5 w-5 text-gray-600 dark:text-gray-400" />
          <h3 className="font-medium text-gray-900 dark:text-white">Timer</h3>
        </div>
        <div className="flex items-center space-x-2">
          {getStatusIcon()}
          <span className="text-sm font-medium text-gray-700 dark:text-gray-300">
            {getStatusText()}
          </span>
        </div>
      </div>

      <div className="text-center mb-4">
        <div className={`text-4xl font-mono font-bold ${getTimerColor()}`}>
          {formatTime(timeLeft)}
        </div>
        <div className="text-sm text-gray-600 dark:text-gray-400 mt-1">
          {isTimeUp ? 'Time has expired' : `${timeLeft} seconds remaining`}
        </div>
      </div>

      {/* Progress Bar */}
      <div className="mb-4">
        <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2">
          <div
            className={`h-2 rounded-full transition-all duration-1000 ${
              isTimeUp ? 'bg-red-500' : timeLeft <= warningThreshold ? 'bg-yellow-500' : 'bg-green-500'
            }`}
            style={{ width: `${((timeLimit - timeLeft) / timeLimit) * 100}%` }}
          />
        </div>
        <div className="flex justify-between text-xs text-gray-500 dark:text-gray-400 mt-1">
          <span>0:00</span>
          <span>{formatTime(timeLimit)}</span>
        </div>
      </div>

      {/* Controls */}
      {showControls && (
        <div className="flex items-center justify-center space-x-2">
          {!hasStarted || (!isRunning && !isPaused) ? (
            <button
              onClick={handleStart}
              className="flex items-center space-x-1 px-3 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors"
            >
              <PlayIcon className="h-4 w-4" />
              <span>Start</span>
            </button>
          ) : isRunning ? (
            <button
              onClick={handlePause}
              className="flex items-center space-x-1 px-3 py-2 bg-yellow-600 text-white rounded-md hover:bg-yellow-700 transition-colors"
            >
              <PauseIcon className="h-4 w-4" />
              <span>Pause</span>
            </button>
          ) : (
            <button
              onClick={handleResume}
              className="flex items-center space-x-1 px-3 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors"
            >
              <PlayIcon className="h-4 w-4" />
              <span>Resume</span>
            </button>
          )}

          {(hasStarted || isRunning || isPaused) && (
            <button
              onClick={handleStop}
              className="flex items-center space-x-1 px-3 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors"
            >
              <StopIcon className="h-4 w-4" />
              <span>Stop</span>
            </button>
          )}

          <button
            onClick={handleReset}
            className="flex items-center space-x-1 px-3 py-2 bg-gray-600 text-white rounded-md hover:bg-gray-700 transition-colors"
          >
            <ClockIcon className="h-4 w-4" />
            <span>Reset</span>
          </button>
        </div>
      )}

      {/* Time Up Message */}
      {isTimeUp && (
        <div className="mt-4 p-3 bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg">
          <div className="flex items-center space-x-2">
            <ExclamationTriangleIcon className="h-5 w-5 text-red-600 dark:text-red-400" />
            <span className="text-sm font-medium text-red-700 dark:text-red-300">
              Time limit reached! Please submit your scores.
            </span>
          </div>
        </div>
      )}

      {/* Warning Message */}
      {timeLeft <= warningThreshold && !isTimeUp && (
        <div className="mt-4 p-3 bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-lg">
          <div className="flex items-center space-x-2">
            <ExclamationTriangleIcon className="h-5 w-5 text-yellow-600 dark:text-yellow-400" />
            <span className="text-sm font-medium text-yellow-700 dark:text-yellow-300">
              {timeLeft <= 10 
                ? `Only ${timeLeft} seconds remaining!` 
                : `${timeLeft} seconds remaining - time is running out!`}
            </span>
          </div>
        </div>
      )}
    </div>
  )
}

export default CountdownTimer
EOF

    # Update ScoringPage with countdown timer for timed criteria
    cat > "$APP_DIR/frontend/src/pages/ScoringPage.tsx" << 'EOF'
import React, { useState } from 'react'
import { useQuery, useMutation, useQueryClient } from 'react-query'
import { scoringAPI } from '../services/api'
import { useAuth } from '../contexts/AuthContext'
import CountdownTimer from '../components/CountdownTimer'
import {
  StarIcon,
  CheckCircleIcon,
  XCircleIcon,
  ClockIcon,
  UserIcon,
  TrophyIcon,
  MagnifyingGlassIcon,
  FunnelIcon,
  DocumentCheckIcon,
  ExclamationTriangleIcon,
  PencilIcon,
  TrashIcon,
  PlayIcon,
  PauseIcon,
  StopIcon
} from '@heroicons/react/24/outline'
import { format } from 'date-fns'

interface Score {
  id: string
  score: number
  comment?: string
  createdAt: string
  updatedAt: string
  judge: {
    id: string
    name: string
    email: string
  }
  contestant: {
    id: string
    name: string
    email: string
  }
  criterion: {
    id: string
    name: string
    maxScore: number
    timeLimit?: number
  }
  category: {
    id: string
    name: string
    maxScore: number
  }
}

interface Category {
  id: string
  name: string
  description: string
  maxScore: number
  criteria: Criterion[]
}

interface Criterion {
  id: string
  name: string
  description: string
  maxScore: number
  minScore?: number
  timeLimit?: number
  isRequired: boolean
  order: number
}

interface Contestant {
  id: string
  name: string
  email: string
  contestantNumber?: string
}

interface Judge {
  id: string
  name: string
  email: string
}

const ScoringPage: React.FC = () => {
  const { user } = useAuth()
  const queryClient = useQueryClient()
  const [selectedCategory, setSelectedCategory] = useState<string>('')
  const [selectedContestant, setSelectedContestant] = useState<string>('')
  const [selectedCriterion, setSelectedCriterion] = useState<string>('')
  const [searchTerm, setSearchTerm] = useState('')
  const [showScoreModal, setShowScoreModal] = useState(false)
  const [editingScore, setEditingScore] = useState<Score | null>(null)
  const [activeTimer, setActiveTimer] = useState<string | null>(null)
  const [timerWarnings, setTimerWarnings] = useState<Set<string>>(new Set())

  const { data: categories, isLoading: categoriesLoading } = useQuery(
    'categories',
    () => scoringAPI.getCategories().then(res => res.data),
    {
      enabled: user?.role === 'JUDGE',
    }
  )

  const { data: scores, isLoading: scoresLoading } = useQuery(
    ['scores', selectedCategory, selectedContestant],
    () => scoringAPI.getScores(selectedCategory, selectedContestant).then(res => res.data),
    {
      enabled: !!selectedCategory && !!selectedContestant,
    }
  )

  const submitScoreMutation = useMutation(
    (scoreData: any) => scoringAPI.submitScoreData(scoreData),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['scores', selectedCategory, selectedContestant])
        setShowScoreModal(false)
        setEditingScore(null)
      },
    }
  )

  const updateScoreMutation = useMutation(
    ({ id, data }: { id: string; data: any }) => scoringAPI.updateScore(id, data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['scores', selectedCategory, selectedContestant])
        setShowScoreModal(false)
        setEditingScore(null)
      },
    }
  )

  const deleteScoreMutation = useMutation(
    (id: string) => scoringAPI.deleteScore(id),
    {
      onSuccess: () => {
        queryClient.invalidateQueries(['scores', selectedCategory, selectedContestant])
      },
    }
  )

  const filteredCategories = categories?.filter((category: Category) =>
    category.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
    category.description.toLowerCase().includes(searchTerm.toLowerCase())
  ) || []

  const selectedCategoryData = categories?.find((cat: Category) => cat.id === selectedCategory)
  const selectedContestantData = selectedCategoryData?.criteria?.find((criterion: Criterion) => criterion.id === selectedContestant)

  const calculateTotalScore = (scores: Score[]): number => {
    return scores.reduce((total, score) => total + score.score, 0)
  }

  const calculateAverageScore = (scores: Score[]): number => {
    if (scores.length === 0) return 0
    return calculateTotalScore(scores) / scores.length
  }

  const handleTimerStart = (criterionId: string) => {
    setActiveTimer(criterionId)
  }

  const handleTimerWarning = (criterionId: string) => {
    setTimerWarnings(prev => new Set([...prev, criterionId]))
  }

  const handleTimerTimeUp = (criterionId: string) => {
    setActiveTimer(null)
    setTimerWarnings(prev => {
      const newSet = new Set(prev)
      newSet.delete(criterionId)
      return newSet
    })
    
    // Show notification or auto-submit if needed
    alert(`Time limit reached for criterion: ${selectedCategoryData?.criteria.find(c => c.id === criterionId)?.name}`)
  }

  const getCriterionStatus = (criterion: Criterion): 'not-started' | 'in-progress' | 'completed' | 'time-up' => {
    const score = scores?.find((s: Score) => s.criterion.id === criterion.id)
    if (score) return 'completed'
    if (activeTimer === criterion.id) return 'in-progress'
    if (timerWarnings.has(criterion.id)) return 'time-up'
    return 'not-started'
  }

  const getCriterionIcon = (criterion: Criterion) => {
    const status = getCriterionStatus(criterion)
    switch (status) {
      case 'completed':
        return <CheckCircleIcon className="h-5 w-5 text-green-500" />
      case 'in-progress':
        return <PlayIcon className="h-5 w-5 text-blue-500" />
      case 'time-up':
        return <ExclamationTriangleIcon className="h-5 w-5 text-red-500" />
      default:
        return <ClockIcon className="h-5 w-5 text-gray-400" />
    }
  }

  const getCriterionColor = (criterion: Criterion): string => {
    const status = getCriterionStatus(criterion)
    switch (status) {
      case 'completed':
        return 'bg-green-50 dark:bg-green-900/20 border-green-200 dark:border-green-800'
      case 'in-progress':
        return 'bg-blue-50 dark:bg-blue-900/20 border-blue-200 dark:border-blue-800'
      case 'time-up':
        return 'bg-red-50 dark:bg-red-900/20 border-red-200 dark:border-red-800'
      default:
        return 'bg-gray-50 dark:bg-gray-800 border-gray-200 dark:border-gray-700'
    }
  }

  if (user?.role !== 'JUDGE') {
    return (
      <div className="flex items-center justify-center h-64">
        <div className="text-center">
          <XCircleIcon className="h-12 w-12 text-red-500 mx-auto mb-4" />
          <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">
            Access Denied
          </h3>
          <p className="text-gray-600 dark:text-gray-400">
            You need to be a judge to access the scoring interface.
          </p>
        </div>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">
            Scoring Interface
          </h1>
          <p className="text-gray-600 dark:text-gray-400">
            Score contestants for each criterion
          </p>
        </div>
      </div>

      {/* Category Selection */}
      <div className="card">
        <div className="card-header">
          <h3 className="card-title">Select Category</h3>
        </div>
        <div className="card-content">
          <div className="mb-4">
            <div className="relative">
              <MagnifyingGlassIcon className="h-5 w-5 absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400" />
              <input
                type="text"
                placeholder="Search categories..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="input pl-10"
              />
            </div>
          </div>
          
          {categoriesLoading ? (
            <div className="flex items-center justify-center py-8">
              <div className="loading-spinner"></div>
            </div>
          ) : filteredCategories.length > 0 ? (
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              {filteredCategories.map((category: Category) => (
                <div
                  key={category.id}
                  onClick={() => setSelectedCategory(category.id)}
                  className={`p-4 border rounded-lg cursor-pointer transition-colors ${
                    selectedCategory === category.id
                      ? 'bg-primary text-white border-primary'
                      : 'bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700 hover:border-primary'
                  }`}
                >
                  <h4 className="font-medium mb-2">{category.name}</h4>
                  <p className="text-sm opacity-75">{category.description}</p>
                  <div className="mt-2 text-sm">
                    <span className="font-medium">Max Score:</span> {category.maxScore}
                  </div>
                  <div className="text-sm">
                    <span className="font-medium">Criteria:</span> {category.criteria.length}
                  </div>
                </div>
              ))}
            </div>
          ) : (
            <div className="text-center py-8 text-gray-500 dark:text-gray-400">
              <TrophyIcon className="h-12 w-12 mx-auto mb-4 text-gray-300 dark:text-gray-600" />
              <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-2">
                No categories found
              </h3>
              <p>Try adjusting your search criteria.</p>
            </div>
          )}
        </div>
      </div>

      {/* Contestant Selection */}
      {selectedCategory && (
        <div className="card">
          <div className="card-header">
            <h3 className="card-title">Select Contestant</h3>
          </div>
          <div className="card-content">
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              {/* Contestants would be loaded here */}
              <div className="p-4 border rounded-lg bg-white dark:bg-gray-800 border-gray-200 dark:border-gray-700">
                <h4 className="font-medium mb-2">Sample Contestant</h4>
                <p className="text-sm text-gray-600 dark:text-gray-400">Contestant #001</p>
                <button
                  onClick={() => setSelectedContestant('sample-contestant')}
                  className="mt-2 btn btn-primary btn-sm"
                >
                  Select
                </button>
              </div>
            </div>
          </div>
        </div>
      )}

      {/* Scoring Interface */}
      {selectedCategory && selectedContestant && (
        <div className="space-y-6">
          {/* Timer Section */}
          {selectedCategoryData?.criteria.some(c => c.timeLimit) && (
            <div className="card">
              <div className="card-header">
                <h3 className="card-title">Timed Criteria</h3>
              </div>
              <div className="card-content">
                <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                  {selectedCategoryData.criteria
                    .filter(criterion => criterion.timeLimit)
                    .map((criterion) => (
                    <div key={criterion.id} className="space-y-2">
                      <div className="flex items-center justify-between">
                        <h4 className="font-medium text-gray-900 dark:text-white">
                          {criterion.name}
                        </h4>
                        <span className="text-sm text-gray-500 dark:text-gray-400">
                          {criterion.timeLimit}s limit
                        </span>
                      </div>
                      <CountdownTimer
                        timeLimit={criterion.timeLimit || 300}
                        onTimeUp={() => handleTimerTimeUp(criterion.id)}
                        onTimeWarning={() => handleTimerWarning(criterion.id)}
                        warningThreshold={30}
                        autoStart={false}
                        showControls={true}
                        className="w-full"
                      />
                    </div>
                  ))}
                </div>
              </div>
            </div>
          )}

          {/* Criteria List */}
          <div className="card">
            <div className="card-header">
              <h3 className="card-title">Scoring Criteria</h3>
            </div>
            <div className="card-content">
              {scoresLoading ? (
                <div className="flex items-center justify-center py-8">
                  <div className="loading-spinner"></div>
                </div>
              ) : (
                <div className="space-y-4">
                  {/* Score Summary */}
                  {scores && scores.length > 0 && (
                    <div className="bg-gray-50 dark:bg-gray-700 rounded-lg p-4">
                      <div className="grid grid-cols-1 md:grid-cols-3 gap-4 text-center">
                        <div>
                          <div className="text-2xl font-bold text-primary">
                            {calculateTotalScore(scores)}
                          </div>
                          <div className="text-sm text-gray-600 dark:text-gray-400">Total Score</div>
                        </div>
                        <div>
                          <div className="text-2xl font-bold text-primary">
                            {calculateAverageScore(scores).toFixed(1)}
                          </div>
                          <div className="text-sm text-gray-600 dark:text-gray-400">Average Score</div>
                        </div>
                        <div>
                          <div className="text-2xl font-bold text-primary">
                            {scores.length}
                          </div>
                          <div className="text-sm text-gray-600 dark:text-gray-400">Criteria Scored</div>
                        </div>
                      </div>
                    </div>
                  )}

                  {/* Criteria List */}
                  <div className="space-y-3">
                    {selectedCategoryData?.criteria.map((criterion) => {
                      const score = scores?.find((s: Score) => s.criterion.id === criterion.id)
                      const status = getCriterionStatus(criterion)
                      
                      return (
                        <div
                          key={criterion.id}
                          className={`border rounded-lg p-4 transition-colors ${getCriterionColor(criterion)}`}
                        >
                          <div className="flex items-center justify-between">
                            <div className="flex items-center space-x-3">
                              {getCriterionIcon(criterion)}
                              <div>
                                <h4 className="font-medium text-gray-900 dark:text-white">
                                  {criterion.name}
                                  {criterion.isRequired && (
                                    <span className="ml-2 text-xs bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200 px-2 py-1 rounded">
                                      Required
                                    </span>
                                  )}
                                </h4>
                                <p className="text-sm text-gray-600 dark:text-gray-400">
                                  {criterion.description}
                                </p>
                                <div className="flex items-center space-x-4 mt-1">
                                  <span className="text-sm text-gray-500 dark:text-gray-400">
                                    Max: {criterion.maxScore}
                                    {criterion.minScore && `, Min: ${criterion.minScore}`}
                                  </span>
                                  {criterion.timeLimit && (
                                    <span className="text-sm text-gray-500 dark:text-gray-400">
                                      Time: {criterion.timeLimit}s
                                    </span>
                                  )}
                                </div>
                              </div>
                            </div>
                            <div className="flex items-center space-x-4">
                              {score ? (
                                <div className="text-right">
                                  <div className="text-lg font-semibold text-gray-900 dark:text-white">
                                    {score.score}/{criterion.maxScore}
                                  </div>
                                  <div className="text-sm text-gray-500 dark:text-gray-400">
                                    {format(new Date(score.createdAt), 'MMM dd, yyyy HH:mm')}
                                  </div>
                                </div>
                              ) : (
                                <div className="text-right">
                                  <div className="text-sm text-gray-500 dark:text-gray-400">
                                    Not scored
                                  </div>
                                </div>
                              )}
                              <div className="flex items-center space-x-2">
                                {score ? (
                                  <>
                                    <button
                                      onClick={() => {
                                        setEditingScore(score)
                                        setShowScoreModal(true)
                                      }}
                                      className="text-blue-600 hover:text-blue-900 dark:text-blue-400 dark:hover:text-blue-300"
                                    >
                                      <PencilIcon className="h-5 w-5" />
                                    </button>
                                    <button
                                      onClick={() => deleteScoreMutation.mutate(score.id)}
                                      className="text-red-600 hover:text-red-900 dark:text-red-400 dark:hover:text-red-300"
                                    >
                                      <TrashIcon className="h-5 w-5" />
                                    </button>
                                  </>
                                ) : (
                                  <button
                                    onClick={() => {
                                      setSelectedCriterion(criterion.id)
                                      setShowScoreModal(true)
                                    }}
                                    className="btn btn-primary btn-sm"
                                  >
                                    <StarIcon className="h-4 w-4 mr-1" />
                                    Score
                                  </button>
                                )}
                              </div>
                            </div>
                          </div>
                        </div>
                      )
                    })}
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>
      )}

      {/* Score Modal */}
      {showScoreModal && (
        <ScoreModal
          score={editingScore}
          categoryId={selectedCategory}
          contestantId={selectedContestant}
          criterionId={selectedCriterion}
          onClose={() => {
            setShowScoreModal(false)
            setEditingScore(null)
            setSelectedCriterion('')
          }}
          onSave={(data) => {
            if (editingScore) {
              updateScoreMutation.mutate({ id: editingScore.id, data })
            } else {
              submitScoreMutation.mutate(data)
            }
          }}
          isLoading={submitScoreMutation.isLoading || updateScoreMutation.isLoading}
        />
      )}
    </div>
  )
}

// Score Modal Component
interface ScoreModalProps {
  score: Score | null
  categoryId: string
  contestantId: string
  criterionId?: string
  onClose: () => void
  onSave: (data: any) => void
  isLoading: boolean
}

const ScoreModal: React.FC<ScoreModalProps> = ({
  score,
  categoryId,
  contestantId,
  criterionId,
  onClose,
  onSave,
  isLoading
}) => {
  const [formData, setFormData] = useState({
    score: score?.score || 0,
    comment: score?.comment || '',
  })

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault()
    onSave({
      categoryId,
      contestantId,
      criterionId,
      ...formData,
    })
  }

  return (
    <div className="modal">
      <div className="modal-overlay" onClick={onClose}></div>
      <div className="modal-content">
        <div className="flex items-center justify-between mb-6">
          <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
            {score ? 'Edit Score' : 'Add Score'}
          </h3>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
          >
            <XCircleIcon className="h-6 w-6" />
          </button>
        </div>

        <form onSubmit={handleSubmit}>
          <div className="space-y-4">
            <div>
              <label className="label">Score</label>
              <input
                type="number"
                value={formData.score}
                onChange={(e) => setFormData({ ...formData, score: Number(e.target.value) })}
                className="input"
                min="0"
                max="100"
                required
              />
            </div>
            <div>
              <label className="label">Comment</label>
              <textarea
                value={formData.comment}
                onChange={(e) => setFormData({ ...formData, comment: e.target.value })}
                rows={3}
                className="input"
                placeholder="Optional comment..."
              />
            </div>
          </div>

          <div className="flex items-center justify-end space-x-3 mt-6">
            <button
              type="button"
              onClick={onClose}
              className="btn btn-secondary"
            >
              Cancel
            </button>
            <button
              type="submit"
              disabled={isLoading}
              className="btn btn-primary"
            >
              {isLoading ? 'Saving...' : score ? 'Update Score' : 'Save Score'}
            </button>
          </div>
        </form>
      </div>
    </div>
  )
}

export default ScoringPage
EOF

    # Update SettingsPage with password policy configuration
    cat > "$APP_DIR/frontend/src/pages/SettingsPage.tsx" << 'EOF'
import React, { useState } from 'react'
import { useQuery, useMutation, useQueryClient } from 'react-query'
import { adminAPI } from '../services/api'
import { useAuth } from '../contexts/AuthContext'
import PasswordStrengthMeter from '../components/PasswordStrengthMeter'
import {
  CogIcon,
  ServerIcon,
  EnvelopeIcon,
  ShieldCheckIcon,
  ServerIcon as DatabaseIcon,
  BellIcon,
  KeyIcon,
  GlobeAltIcon,
  DocumentTextIcon,
  CloudIcon,
  ExclamationTriangleIcon,
  CheckCircleIcon,
  LockClosedIcon,
  EyeIcon,
  EyeSlashIcon,
  InformationCircleIcon
} from '@heroicons/react/24/outline'

interface SystemSetting {
  id: string
  key: string
  value: string
  description: string
  category: string
  type: 'string' | 'number' | 'boolean' | 'json'
  updatedAt: string
  updatedBy: string
}

interface PasswordPolicy {
  minLength: number
  requireUppercase: boolean
  requireLowercase: boolean
  requireNumbers: boolean
  requireSpecialChars: boolean
  maxAge: number // days
  preventReuse: number // number of previous passwords to prevent reuse
  lockoutAttempts: number
  lockoutDuration: number // minutes
  preventCommonPasswords: boolean
  preventUserInfo: boolean
}

const SettingsPage: React.FC = () => {
  const { user } = useAuth()
  const queryClient = useQueryClient()
  const [activeTab, setActiveTab] = useState<'general' | 'email' | 'security' | 'database' | 'notifications' | 'backup' | 'password-policy'>('general')
  const [showTestModal, setShowTestModal] = useState(false)
  const [testType, setTestType] = useState<'email' | 'database' | 'backup'>('email')
  const [passwordPolicy, setPasswordPolicy] = useState<PasswordPolicy>({
    minLength: 8,
    requireUppercase: true,
    requireLowercase: true,
    requireNumbers: true,
    requireSpecialChars: true,
    maxAge: 90,
    preventReuse: 5,
    lockoutAttempts: 5,
    lockoutDuration: 30,
    preventCommonPasswords: true,
    preventUserInfo: true
  })
  const [showPasswordPreview, setShowPasswordPreview] = useState(false)
  const [testPassword, setTestPassword] = useState('')

  const { data: settings, isLoading } = useQuery(
    'admin-settings',
    () => adminAPI.getSettings().then(res => res.data),
    {
      enabled: user?.role === 'ADMIN' || user?.role === 'BOARD' || user?.role === 'ORGANIZER',
    }
  )

  const { data: passwordPolicySettings } = useQuery(
    'password-policy',
    () => adminAPI.getPasswordPolicy().then(res => res.data),
    {
      enabled: user?.role === 'ADMIN' || user?.role === 'BOARD' || user?.role === 'ORGANIZER',
      onSuccess: (data) => {
        if (data) {
          setPasswordPolicy(data)
        }
      }
    }
  )

  const updateMutation = useMutation(
    (data: any) => adminAPI.updateSettings(data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('admin-settings')
      },
    }
  )

  const updatePasswordPolicyMutation = useMutation(
    (data: PasswordPolicy) => adminAPI.updatePasswordPolicy(data),
    {
      onSuccess: () => {
        queryClient.invalidateQueries('password-policy')
      },
    }
  )

  const testMutation = useMutation(
    (type: string) => adminAPI.testConnection(type),
    {
      onSuccess: () => {
        setShowTestModal(false)
      },
    }
  )

  const tabs = [
    { id: 'general', name: 'General', icon: CogIcon },
    { id: 'email', name: 'Email', icon: EnvelopeIcon },
    { id: 'security', name: 'Security', icon: ShieldCheckIcon },
    { id: 'password-policy', name: 'Password Policy', icon: LockClosedIcon },
    { id: 'database', name: 'Database', icon: DatabaseIcon },
    { id: 'notifications', name: 'Notifications', icon: BellIcon },
    { id: 'backup', name: 'Backup', icon: CloudIcon },
  ]

  const getSettingsByCategory = (category: string) => {
    return settings?.filter((setting: SystemSetting) => setting.category === category) || []
  }

  const handleSettingChange = (key: string, value: string) => {
    updateMutation.mutate({ [key]: value })
  }

  const handlePasswordPolicyChange = (field: keyof PasswordPolicy, value: any) => {
    const updatedPolicy = { ...passwordPolicy, [field]: value }
    setPasswordPolicy(updatedPolicy)
    updatePasswordPolicyMutation.mutate(updatedPolicy)
  }

  const handleTest = (type: 'email' | 'database' | 'backup') => {
    setTestType(type)
    setShowTestModal(true)
    testMutation.mutate(type)
  }

  const getPasswordStrength = (password: string): number => {
    let strength = 0
    if (password.length >= passwordPolicy.minLength) strength += 20
    if (passwordPolicy.requireUppercase && /[A-Z]/.test(password)) strength += 20
    if (passwordPolicy.requireLowercase && /[a-z]/.test(password)) strength += 20
    if (passwordPolicy.requireNumbers && /\d/.test(password)) strength += 20
    if (passwordPolicy.requireSpecialChars && /[!@#$%^&*(),.?":{}|<>]/.test(password)) strength += 20
    return strength
  }

  const getPasswordStrengthText = (strength: number): string => {
    if (strength < 40) return 'Weak'
    if (strength < 60) return 'Fair'
    if (strength < 80) return 'Good'
    return 'Strong'
  }

  const getPasswordStrengthColor = (strength: number): string => {
    if (strength < 40) return 'text-red-600 dark:text-red-400'
    if (strength < 60) return 'text-yellow-600 dark:text-yellow-400'
    if (strength < 80) return 'text-blue-600 dark:text-blue-400'
    return 'text-green-600 dark:text-green-400'
  }

  if (isLoading) {
    return (
      <div className="flex items-center justify-center py-12">
        <div className="loading-spinner"></div>
      </div>
    )
  }

  return (
    <div className="space-y-6">
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h1 className="text-2xl font-bold text-gray-900 dark:text-white">
            System Settings
          </h1>
          <p className="text-gray-600 dark:text-gray-400">
            Configure system-wide settings and policies
          </p>
        </div>
        <div className="flex items-center space-x-3">
          <button
            onClick={() => handleTest('email')}
            className="btn btn-secondary"
          >
            <EnvelopeIcon className="h-4 w-4 mr-2" />
            Test Email
          </button>
          <button
            onClick={() => handleTest('database')}
            className="btn btn-secondary"
          >
            <DatabaseIcon className="h-4 w-4 mr-2" />
            Test Database
          </button>
        </div>
      </div>

      {/* Tab Navigation */}
      <div className="border-b border-gray-200 dark:border-gray-700">
        <nav className="-mb-px flex space-x-8">
          {tabs.map((tab) => {
            const Icon = tab.icon
            return (
              <button
                key={tab.id}
                onClick={() => setActiveTab(tab.id as any)}
                className={`flex items-center space-x-2 py-2 px-1 border-b-2 font-medium text-sm ${
                  activeTab === tab.id
                    ? 'border-primary text-primary'
                    : 'border-transparent text-gray-500 hover:text-gray-700 hover:border-gray-300 dark:text-gray-400 dark:hover:text-gray-300'
                }`}
              >
                <Icon className="h-5 w-5" />
                <span>{tab.name}</span>
              </button>
            )
          })}
        </nav>
      </div>

      {/* Tab Content */}
      <div className="card">
        <div className="card-content">
          {activeTab === 'general' && (
            <div className="space-y-6">
              <h3 className="text-lg font-medium">General Settings</h3>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                {getSettingsByCategory('general').map((setting: SystemSetting) => (
                  <div key={setting.key} className="space-y-2">
                    <label className="label">{setting.description}</label>
                    {setting.type === 'boolean' ? (
                      <div className="flex items-center space-x-2">
                        <input
                          type="checkbox"
                          checked={setting.value === 'true'}
                          onChange={(e) => handleSettingChange(setting.key, e.target.checked.toString())}
                          className="rounded border-gray-300 text-primary focus:ring-primary"
                        />
                        <span className="text-sm text-gray-600 dark:text-gray-400">
                          {setting.value === 'true' ? 'Enabled' : 'Disabled'}
                        </span>
                      </div>
                    ) : setting.type === 'number' ? (
                      <input
                        type="number"
                        value={setting.value}
                        onChange={(e) => handleSettingChange(setting.key, e.target.value)}
                        className="input"
                      />
                    ) : (
                      <input
                        type="text"
                        value={setting.value}
                        onChange={(e) => handleSettingChange(setting.key, e.target.value)}
                        className="input"
                      />
                    )}
                  </div>
                ))}
              </div>
            </div>
          )}

          {activeTab === 'email' && (
            <div className="space-y-6">
              <h3 className="text-lg font-medium">Email Settings</h3>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                {getSettingsByCategory('email').map((setting: SystemSetting) => (
                  <div key={setting.key} className="space-y-2">
                    <label className="label">{setting.description}</label>
                    {setting.key.includes('password') ? (
                      <div className="relative">
                        <input
                          type={showPasswordPreview ? 'text' : 'password'}
                          value={setting.value}
                          onChange={(e) => handleSettingChange(setting.key, e.target.value)}
                          className="input pr-10"
                        />
                        <button
                          type="button"
                          onClick={() => setShowPasswordPreview(!showPasswordPreview)}
                          className="absolute inset-y-0 right-0 pr-3 flex items-center"
                        >
                          {showPasswordPreview ? (
                            <EyeSlashIcon className="h-5 w-5 text-gray-400" />
                          ) : (
                            <EyeIcon className="h-5 w-5 text-gray-400" />
                          )}
                        </button>
                      </div>
                    ) : (
                      <input
                        type="text"
                        value={setting.value}
                        onChange={(e) => handleSettingChange(setting.key, e.target.value)}
                        className="input"
                      />
                    )}
                  </div>
                ))}
              </div>
            </div>
          )}

          {activeTab === 'security' && (
            <div className="space-y-6">
              <h3 className="text-lg font-medium">Security Settings</h3>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                {getSettingsByCategory('security').map((setting: SystemSetting) => (
                  <div key={setting.key} className="space-y-2">
                    <label className="label">{setting.description}</label>
                    {setting.type === 'boolean' ? (
                      <div className="flex items-center space-x-2">
                        <input
                          type="checkbox"
                          checked={setting.value === 'true'}
                          onChange={(e) => handleSettingChange(setting.key, e.target.checked.toString())}
                          className="rounded border-gray-300 text-primary focus:ring-primary"
                        />
                        <span className="text-sm text-gray-600 dark:text-gray-400">
                          {setting.value === 'true' ? 'Enabled' : 'Disabled'}
                        </span>
                      </div>
                    ) : setting.type === 'number' ? (
                      <input
                        type="number"
                        value={setting.value}
                        onChange={(e) => handleSettingChange(setting.key, e.target.value)}
                        className="input"
                      />
                    ) : (
                      <input
                        type="text"
                        value={setting.value}
                        onChange={(e) => handleSettingChange(setting.key, e.target.value)}
                        className="input"
                      />
                    )}
                  </div>
                ))}
              </div>
            </div>
          )}

          {activeTab === 'password-policy' && (
            <div className="space-y-6">
              <div className="flex items-center justify-between">
                <h3 className="text-lg font-medium">Password Policy</h3>
                <div className="flex items-center space-x-2">
                  <button
                    onClick={() => setTestPassword('')}
                    className="btn btn-secondary btn-sm"
                  >
                    Clear Test
                  </button>
                </div>
              </div>

              <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                {/* Policy Configuration */}
                <div className="space-y-6">
                  <div className="bg-gray-50 dark:bg-gray-800 rounded-lg p-6">
                    <h4 className="font-semibold text-gray-900 dark:text-white mb-4">Password Requirements</h4>
                    <div className="space-y-4">
                      <div>
                        <label className="label">Minimum Length</label>
                        <input
                          type="number"
                          value={passwordPolicy.minLength}
                          onChange={(e) => handlePasswordPolicyChange('minLength', Number(e.target.value))}
                          className="input"
                          min="4"
                          max="32"
                        />
                      </div>
                      <div className="space-y-3">
                        <div className="flex items-center justify-between">
                          <label className="label">Require Uppercase Letters</label>
                          <input
                            type="checkbox"
                            checked={passwordPolicy.requireUppercase}
                            onChange={(e) => handlePasswordPolicyChange('requireUppercase', e.target.checked)}
                            className="rounded border-gray-300 text-primary focus:ring-primary"
                          />
                        </div>
                        <div className="flex items-center justify-between">
                          <label className="label">Require Lowercase Letters</label>
                          <input
                            type="checkbox"
                            checked={passwordPolicy.requireLowercase}
                            onChange={(e) => handlePasswordPolicyChange('requireLowercase', e.target.checked)}
                            className="rounded border-gray-300 text-primary focus:ring-primary"
                          />
                        </div>
                        <div className="flex items-center justify-between">
                          <label className="label">Require Numbers</label>
                          <input
                            type="checkbox"
                            checked={passwordPolicy.requireNumbers}
                            onChange={(e) => handlePasswordPolicyChange('requireNumbers', e.target.checked)}
                            className="rounded border-gray-300 text-primary focus:ring-primary"
                          />
                        </div>
                        <div className="flex items-center justify-between">
                          <label className="label">Require Special Characters</label>
                          <input
                            type="checkbox"
                            checked={passwordPolicy.requireSpecialChars}
                            onChange={(e) => handlePasswordPolicyChange('requireSpecialChars', e.target.checked)}
                            className="rounded border-gray-300 text-primary focus:ring-primary"
                          />
                        </div>
                      </div>
                    </div>
                  </div>

                  <div className="bg-gray-50 dark:bg-gray-800 rounded-lg p-6">
                    <h4 className="font-semibold text-gray-900 dark:text-white mb-4">Password Management</h4>
                    <div className="space-y-4">
                      <div>
                        <label className="label">Maximum Age (days)</label>
                        <input
                          type="number"
                          value={passwordPolicy.maxAge}
                          onChange={(e) => handlePasswordPolicyChange('maxAge', Number(e.target.value))}
                          className="input"
                          min="0"
                          max="365"
                        />
                        <p className="text-sm text-gray-500 dark:text-gray-400 mt-1">
                          Set to 0 to disable password expiration
                        </p>
                      </div>
                      <div>
                        <label className="label">Prevent Password Reuse</label>
                        <input
                          type="number"
                          value={passwordPolicy.preventReuse}
                          onChange={(e) => handlePasswordPolicyChange('preventReuse', Number(e.target.value))}
                          className="input"
                          min="0"
                          max="10"
                        />
                        <p className="text-sm text-gray-500 dark:text-gray-400 mt-1">
                          Number of previous passwords to prevent reuse
                        </p>
                      </div>
                    </div>
                  </div>

                  <div className="bg-gray-50 dark:bg-gray-800 rounded-lg p-6">
                    <h4 className="font-semibold text-gray-900 dark:text-white mb-4">Account Lockout</h4>
                    <div className="space-y-4">
                      <div>
                        <label className="label">Failed Login Attempts</label>
                        <input
                          type="number"
                          value={passwordPolicy.lockoutAttempts}
                          onChange={(e) => handlePasswordPolicyChange('lockoutAttempts', Number(e.target.value))}
                          className="input"
                          min="3"
                          max="10"
                        />
                        <p className="text-sm text-gray-500 dark:text-gray-400 mt-1">
                          Number of failed attempts before lockout
                        </p>
                      </div>
                      <div>
                        <label className="label">Lockout Duration (minutes)</label>
                        <input
                          type="number"
                          value={passwordPolicy.lockoutDuration}
                          onChange={(e) => handlePasswordPolicyChange('lockoutDuration', Number(e.target.value))}
                          className="input"
                          min="5"
                          max="1440"
                        />
                        <p className="text-sm text-gray-500 dark:text-gray-400 mt-1">
                          How long to lock the account after failed attempts
                        </p>
                      </div>
                    </div>
                  </div>
                </div>

                {/* Password Testing */}
                <div className="space-y-6">
                  <div className="bg-gray-50 dark:bg-gray-800 rounded-lg p-6">
                    <h4 className="font-semibold text-gray-900 dark:text-white mb-4">Test Password Policy</h4>
                    <div className="space-y-4">
                      <div>
                        <label className="label">Test Password</label>
                        <input
                          type="password"
                          value={testPassword}
                          onChange={(e) => setTestPassword(e.target.value)}
                          className="input"
                          placeholder="Enter a password to test"
                        />
                      </div>
                      {testPassword && (
                        <div className="space-y-3">
                          <PasswordStrengthMeter
                            password={testPassword}
                            onPasswordChange={setTestPassword}
                            showPolicy={true}
                            policy={passwordPolicy}
                          />
                          <div className="space-y-2">
                            <h5 className="font-medium text-gray-900 dark:text-white">Policy Compliance:</h5>
                            <div className="space-y-1 text-sm">
                              <div className={`flex items-center space-x-2 ${
                                testPassword.length >= passwordPolicy.minLength ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'
                              }`}>
                                {testPassword.length >= passwordPolicy.minLength ? (
                                  <CheckCircleIcon className="h-4 w-4" />
                                ) : (
                                  <ExclamationTriangleIcon className="h-4 w-4" />
                                )}
                                <span>Minimum {passwordPolicy.minLength} characters</span>
                              </div>
                              {passwordPolicy.requireUppercase && (
                                <div className={`flex items-center space-x-2 ${
                                  /[A-Z]/.test(testPassword) ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'
                                }`}>
                                  {/[A-Z]/.test(testPassword) ? (
                                    <CheckCircleIcon className="h-4 w-4" />
                                  ) : (
                                    <ExclamationTriangleIcon className="h-4 w-4" />
                                  )}
                                  <span>Contains uppercase letter</span>
                                </div>
                              )}
                              {passwordPolicy.requireLowercase && (
                                <div className={`flex items-center space-x-2 ${
                                  /[a-z]/.test(testPassword) ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'
                                }`}>
                                  {/[a-z]/.test(testPassword) ? (
                                    <CheckCircleIcon className="h-4 w-4" />
                                  ) : (
                                    <ExclamationTriangleIcon className="h-4 w-4" />
                                  )}
                                  <span>Contains lowercase letter</span>
                                </div>
                              )}
                              {passwordPolicy.requireNumbers && (
                                <div className={`flex items-center space-x-2 ${
                                  /\d/.test(testPassword) ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'
                                }`}>
                                  {/\d/.test(testPassword) ? (
                                    <CheckCircleIcon className="h-4 w-4" />
                                  ) : (
                                    <ExclamationTriangleIcon className="h-4 w-4" />
                                  )}
                                  <span>Contains number</span>
                                </div>
                              )}
                              {passwordPolicy.requireSpecialChars && (
                                <div className={`flex items-center space-x-2 ${
                                  /[!@#$%^&*(),.?":{}|<>]/.test(testPassword) ? 'text-green-600 dark:text-green-400' : 'text-red-600 dark:text-red-400'
                                }`}>
                                  {/[!@#$%^&*(),.?":{}|<>]/.test(testPassword) ? (
                                    <CheckCircleIcon className="h-4 w-4" />
                                  ) : (
                                    <ExclamationTriangleIcon className="h-4 w-4" />
                                  )}
                                  <span>Contains special character</span>
                                </div>
                              )}
                            </div>
                          </div>
                        </div>
                      )}
                    </div>
                  </div>

                  <div className="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-4">
                    <div className="flex items-start space-x-2">
                      <InformationCircleIcon className="h-5 w-5 text-blue-600 dark:text-blue-400 mt-0.5" />
                      <div className="text-sm text-blue-700 dark:text-blue-300">
                        <p className="font-medium mb-1">Password Policy Information:</p>
                        <ul className="list-disc list-inside space-y-1">
                          <li>Changes take effect immediately for new passwords</li>
                          <li>Existing passwords are not affected until changed</li>
                          <li>Users will be prompted to update passwords if they don't meet new requirements</li>
                          <li>Account lockout applies to all login attempts</li>
                        </ul>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          )}

          {activeTab === 'database' && (
            <div className="space-y-6">
              <h3 className="text-lg font-medium">Database Settings</h3>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                {getSettingsByCategory('database').map((setting: SystemSetting) => (
                  <div key={setting.key} className="space-y-2">
                    <label className="label">{setting.description}</label>
                    <input
                      type="text"
                      value={setting.value}
                      onChange={(e) => handleSettingChange(setting.key, e.target.value)}
                      className="input"
                    />
                  </div>
                ))}
              </div>
            </div>
          )}

          {activeTab === 'notifications' && (
            <div className="space-y-6">
              <h3 className="text-lg font-medium">Notification Settings</h3>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                {getSettingsByCategory('notifications').map((setting: SystemSetting) => (
                  <div key={setting.key} className="space-y-2">
                    <label className="label">{setting.description}</label>
                    {setting.type === 'boolean' ? (
                      <div className="flex items-center space-x-2">
                        <input
                          type="checkbox"
                          checked={setting.value === 'true'}
                          onChange={(e) => handleSettingChange(setting.key, e.target.checked.toString())}
                          className="rounded border-gray-300 text-primary focus:ring-primary"
                        />
                        <span className="text-sm text-gray-600 dark:text-gray-400">
                          {setting.value === 'true' ? 'Enabled' : 'Disabled'}
                        </span>
                      </div>
                    ) : (
                      <input
                        type="text"
                        value={setting.value}
                        onChange={(e) => handleSettingChange(setting.key, e.target.value)}
                        className="input"
                      />
                    )}
                  </div>
                ))}
              </div>
            </div>
          )}

          {activeTab === 'backup' && (
            <div className="space-y-6">
              <h3 className="text-lg font-medium">Backup Settings</h3>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                {getSettingsByCategory('backup').map((setting: SystemSetting) => (
                  <div key={setting.key} className="space-y-2">
                    <label className="label">{setting.description}</label>
                    {setting.type === 'boolean' ? (
                      <div className="flex items-center space-x-2">
                        <input
                          type="checkbox"
                          checked={setting.value === 'true'}
                          onChange={(e) => handleSettingChange(setting.key, e.target.checked.toString())}
                          className="rounded border-gray-300 text-primary focus:ring-primary"
                        />
                        <span className="text-sm text-gray-600 dark:text-gray-400">
                          {setting.value === 'true' ? 'Enabled' : 'Disabled'}
                        </span>
                      </div>
                    ) : setting.type === 'number' ? (
                      <input
                        type="number"
                        value={setting.value}
                        onChange={(e) => handleSettingChange(setting.key, e.target.value)}
                        className="input"
                      />
                    ) : (
                      <input
                        type="text"
                        value={setting.value}
                        onChange={(e) => handleSettingChange(setting.key, e.target.value)}
                        className="input"
                      />
                    )}
                  </div>
                ))}
              </div>
            </div>
          )}
        </div>
      </div>

      {/* Test Modal */}
      {showTestModal && (
        <div className="modal">
          <div className="modal-overlay" onClick={() => setShowTestModal(false)}></div>
          <div className="modal-content">
            <div className="flex items-center justify-between mb-6">
              <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                Test {testType.charAt(0).toUpperCase() + testType.slice(1)} Connection
              </h3>
              <button
                onClick={() => setShowTestModal(false)}
                className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
              >
                <ExclamationTriangleIcon className="h-6 w-6" />
              </button>
            </div>
            
            <div className="text-center py-8">
              {testMutation.isLoading ? (
                <div className="space-y-4">
                  <div className="loading-spinner mx-auto"></div>
                  <p className="text-gray-600 dark:text-gray-400">
                    Testing {testType} connection...
                  </p>
                </div>
              ) : testMutation.isSuccess ? (
                <div className="space-y-4">
                  <CheckCircleIcon className="h-12 w-12 text-green-500 mx-auto" />
                  <p className="text-green-600 dark:text-green-400 font-medium">
                    {testType.charAt(0).toUpperCase() + testType.slice(1)} connection successful!
                  </p>
                </div>
              ) : testMutation.isError ? (
                <div className="space-y-4">
                  <ExclamationTriangleIcon className="h-12 w-12 text-red-500 mx-auto" />
                  <p className="text-red-600 dark:text-red-400 font-medium">
                    {testType.charAt(0).toUpperCase() + testType.slice(1)} connection failed!
                  </p>
                </div>
              ) : null}
            </div>
          </div>
        </div>
      )}
    </div>
  )
}

export default SettingsPage
EOF

    print_success "Frontend files created successfully"
    
    # Install frontend dependencies
    print_status "Installing frontend dependencies..."
    if ! safe_npm_install "$APP_DIR/frontend" "frontend"; then
        print_error "Failed to install frontend dependencies"
        return 1
    fi
    
    # Build frontend for production
    print_status "Building frontend for production..."
    if npm run build; then
        print_success "Frontend build completed successfully"
    else
        print_error "Frontend build failed"
        return 1
    fi
    
    # Verify build output exists
    if [[ -d "dist" && -f "dist/index.html" ]]; then
        print_success "Frontend build verified - dist directory and index.html found"
    else
        print_error "Frontend build verification failed - dist directory or index.html missing"
        return 1
    fi
}

# Main installation function
main() {
    echo " Event Manager Complete Setup Script"
    echo "======================================"
    echo ""
    
    # Parse command line arguments
    parse_args "$@"
    
    # Handle rebuild-frontend option
    if [[ "$REBUILD_FRONTEND" == "true" ]]; then
        print_status "Rebuild frontend mode - skipping full installation"
        setup_application_directory
        rebuild_frontend
        print_success "Frontend rebuild completed!"
        exit 0
    fi
    
    # Check prerequisites
    check_root
    detect_os
    check_node_version
    
    # Install prerequisites
    install_prerequisites
    
    # Setup application directory
    setup_application_directory
    
    # Setup environment variables
    setup_environment
    
    # Setup database
    setup_database
    
    # Build frontend
    build_frontend
    
    # Setup web server permissions
    setup_permissions
    
    # Check for PM2
    check_pm2
    
    # Setup process management
    setup_systemd_service
    
    # Configure Nginx
    configure_nginx
    
    # Setup SSL certificate
    setup_ssl
    
    # Evaluate setup completeness
    evaluate_setup_completeness
    
    # Display completion information
    echo ""
    echo " Complete Event Manager Application Deployed!"
    echo "==============================================="
    echo ""
    echo " Application Details:"
    echo "   Application Directory: $APP_DIR"
    echo "   Database: $DB_NAME"
    echo "   Database User: $DB_USER"
    echo "   Web Server User: $WEB_SERVER_USER"
    echo "   Process Manager: $([ "$USE_PM2" == "true" ] && echo "PM2" || echo "systemd")"
    echo ""
    echo " Access Information:"
    if [[ -n "$DOMAIN" ]]; then
        echo "   URL: https://$DOMAIN"
    else
        echo "   URL: http://localhost (or your server IP)"
    fi
    echo "   Backend API: http://localhost:3000"
    echo ""
    echo " Default Login Credentials (all users have password: password123):"
    echo "   ORGANIZER: admin@eventmanager.com"
    echo "   JUDGE: judge@eventmanager.com"
    echo "   CONTESTANT: contestant@eventmanager.com"
    echo "   EMCEE: emcee@eventmanager.com"
    echo "   TALLY_MASTER: tallymaster@eventmanager.com"
    echo "   AUDITOR: auditor@eventmanager.com"
    echo "   BOARD: board@eventmanager.com"
    echo ""
    echo " Complete Event Manager Application Features:"
    echo "    Professional Login Page with Authentication"
    echo "    Role-Based Dashboards (Organizer, Judge, Contestant, Board, etc.)"
    echo "    Event Management System (Create, Edit, Delete Events)"
    echo "    Contest Management (Multiple Contests per Event)"
    echo "    Category Management (Multiple Categories per Contest)"
    echo "    User Management with Role Assignment"
    echo "    Scoring System with Real-time Updates"
    echo "    Judge Certification Workflows"
    echo "    Contestant Score Tracking"
    echo "    Admin Statistics and Reporting"
    echo "    Real-time Updates via WebSocket"
    echo "    Responsive Design with Tailwind CSS"
    echo "    PostgreSQL Database with Prisma ORM"
    echo "    Complete REST API (Events, Contests, Categories, Users, Scoring)"
    echo "    JWT Authentication with Role-Based Access Control"
    echo "    Nginx Reverse Proxy with SSL Support"
    echo "    Systemd Service Management"
    echo "    Production-Ready Security Configuration"
    echo ""
    echo " Management Commands:"
    if [[ "$USE_PM2" == "true" ]]; then
        echo "   PM2 Status: sudo -u $WEB_SERVER_USER pm2 status"
        echo "   PM2 Logs: sudo -u $WEB_SERVER_USER pm2 logs"
        echo "   PM2 Restart: sudo -u $WEB_SERVER_USER pm2 restart $APP_NAME"
    else
        echo "   Service Status: sudo systemctl status $APP_NAME"
        echo "   Service Logs: sudo journalctl -u $APP_NAME -f"
        echo "   Service Restart: sudo systemctl restart $APP_NAME"
    fi
    echo "   Nginx Status: sudo systemctl status nginx"
    echo "   Nginx Reload: sudo systemctl reload nginx"
    echo ""
    echo " Next Steps:"
    echo "   1. Open your browser and navigate to your server IP"
    echo "   2. You'll see the professional login page"
    echo "   3. Log in with the default credentials"
    echo "   4. Explore the dashboard and start managing events!"
    echo ""
    echo " Your Event Manager application is now fully operational!"
    echo ""
}

evaluate_setup_completeness() {
    print_status "Evaluating setup completeness and checking for remaining issues..."
    
    local issues_found=0
    
    # Check for common installation issues
    if [[ -f "$APP_DIR/package.json" ]]; then
        print_success "Backend package.json found"
    else
        print_error "Backend package.json missing!"
        ((issues_found++))
    fi
    
    if [[ -f "$APP_DIR/frontend/package.json" ]]; then
        print_success "Frontend package.json found"
    else
        print_error "Frontend package.json missing!"
        ((issues_found++))
    fi
    
    if [[ -f "$APP_DIR/src/server.js" ]]; then
        print_success "Server.js found"
    else
        print_error "Server.js missing!"
        ((issues_found++))
    fi
    
    if [[ -f "$APP_DIR/frontend/dist/index.html" ]]; then
        print_success "Frontend build found"
    else
        print_error "Frontend build missing!"
        ((issues_found++))
    fi
    
    if [[ -f "$APP_DIR/.env" ]]; then
        print_success "Backend .env found"
    else
        print_error "Backend .env missing!"
        ((issues_found++))
    fi
    
    if [[ -f "$APP_DIR/frontend/.env" ]]; then
        print_success "Frontend .env found"
    else
        print_error "Frontend .env missing!"
        ((issues_found++))
    fi
    
    if [[ -f "$APP_DIR/prisma/schema.prisma" ]]; then
        print_success "Prisma schema found"
    else
        print_error "Prisma schema missing!"
        ((issues_found++))
    fi
    
    if [[ -d "$APP_DIR/node_modules" ]]; then
        print_success "Backend node_modules found"
    else
        print_error "Backend node_modules missing!"
        ((issues_found++))
    fi
    
    if [[ -d "$APP_DIR/frontend/node_modules" ]]; then
        print_success "Frontend node_modules found"
    else
        print_error "Frontend node_modules missing!"
        ((issues_found++))
    fi
    
    if [[ -d "$APP_DIR/frontend/dist" ]]; then
        print_success "Frontend dist directory found"
    else
        print_error "Frontend dist directory missing!"
        ((issues_found++))
    fi
    
    # Check for common configuration issues
    if grep -q "VITE_API_URL" "$APP_DIR/frontend/.env" 2>/dev/null; then
        print_success "Frontend API URL configured"
    else
        print_warning "Frontend API URL not configured"
        ((issues_found++))
    fi
    
    if grep -q "DATABASE_URL" "$APP_DIR/.env" 2>/dev/null; then
        print_success "Database URL configured"
    else
        print_warning "Database URL not configured"
        ((issues_found++))
    fi
    
    if grep -q "JWT_SECRET" "$APP_DIR/.env" 2>/dev/null; then
        print_success "JWT secret configured"
    else
        print_warning "JWT secret not configured"
        ((issues_found++))
    fi
    
    # Check for common permission issues
    if [[ -w "$APP_DIR" ]]; then
        print_success "Application directory is writable"
    else
        print_warning "Application directory is not writable"
        ((issues_found++))
    fi
    
    if [[ -w "$APP_DIR/frontend/dist" ]]; then
        print_success "Frontend dist directory is writable"
    else
        print_warning "Frontend dist directory is not writable"
        ((issues_found++))
    fi
    
    # Check for common dependency issues
    if command -v node >/dev/null 2>&1; then
        local node_version=$(node --version)
        print_success "Node.js found: $node_version"
    else
        print_error "Node.js not found!"
        ((issues_found++))
    fi
    
    if command -v npm >/dev/null 2>&1; then
        local npm_version=$(npm --version)
        print_success "npm found: $npm_version"
    else
        print_error "npm not found!"
        ((issues_found++))
    fi
    
    if command -v nginx >/dev/null 2>&1; then
        print_success "Nginx found"
    else
        print_warning "Nginx not found"
        ((issues_found++))
    fi
    
    if command -v postgres >/dev/null 2>&1; then
        print_success "PostgreSQL found"
    else
        print_warning "PostgreSQL not found"
        ((issues_found++))
    fi
    
    # Summary
    echo ""
    if [[ $issues_found -eq 0 ]]; then
        print_success "No issues found! Setup appears to be complete."
    else
        print_warning "Found $issues_found potential issues. Please review the warnings above."
    fi
    return 0
}

# Run main function
main "$@"
